{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1},{"_id":"source/img/shinhai/1.jpeg","path":"img/shinhai/1.jpeg","modified":0,"renderable":0},{"_id":"source/img/shinhai/10.jpeg","path":"img/shinhai/10.jpeg","modified":0,"renderable":0},{"_id":"source/img/shinhai/12.jpeg","path":"img/shinhai/12.jpeg","modified":0,"renderable":0},{"_id":"source/img/shinhai/2.jpeg","path":"img/shinhai/2.jpeg","modified":0,"renderable":0},{"_id":"source/img/shinhai/3.jpeg","path":"img/shinhai/3.jpeg","modified":0,"renderable":0},{"_id":"source/img/shinhai/4.jpeg","path":"img/shinhai/4.jpeg","modified":0,"renderable":0},{"_id":"source/img/shinhai/5.jpeg","path":"img/shinhai/5.jpeg","modified":0,"renderable":0},{"_id":"source/img/shinhai/5_1.jpeg","path":"img/shinhai/5_1.jpeg","modified":0,"renderable":0},{"_id":"source/img/shinhai/6.jpeg","path":"img/shinhai/6.jpeg","modified":0,"renderable":0},{"_id":"source/img/shinhai/7.jpeg","path":"img/shinhai/7.jpeg","modified":0,"renderable":0},{"_id":"source/img/shinhai/8.jpeg","path":"img/shinhai/8.jpeg","modified":0,"renderable":0},{"_id":"source/img/shinhai/9.jpeg","path":"img/shinhai/9.jpeg","modified":0,"renderable":0}],"Cache":[{"_id":"themes/landscape/.gitignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1514008587178},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1514008587178},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1514008587178},{"_id":"themes/landscape/README.md","hash":"37fae88639ef60d63bd0de22314d7cc4c5d94b07","modified":1514008587179},{"_id":"themes/landscape/_config.yml","hash":"5a77091e0deb5967a6493f39fd1216593140c2c3","modified":1514015301532},{"_id":"themes/landscape/package.json","hash":"544f21a0b2c7034998b36ae94dba6e3e0f39f228","modified":1514008587187},{"_id":"source/_posts/Be-predictable-not-correct-by-Pete-Hunt-from-Instagram.md","hash":"67d74d654fb010b78802ee8ce41a1a4e14428868","modified":1514009288300},{"_id":"source/_posts/Firebase：前端工程師的神兵利器.md","hash":"d1f979e24cc9d97602bdb0932c78ee204057e083","modified":1514009288299},{"_id":"source/_posts/Hey-Underscore-You-re-doing-it-Wrong-介紹函數編程.md","hash":"14d8cb0111fa7c65c2a3414797c7c1f813dd0b8d","modified":1514168393075},{"_id":"source/_posts/Javascript-中的函數式編程-a-talk-ReactiveConf-2015.md","hash":"06769cee1572e24b0547314a590345b66983ff71","modified":1514009288299},{"_id":"source/_posts/Node-js-的發明人-Ryan-Dahl-在-Yahoo-介紹-Node-js-2010.md","hash":"c55f73839951de77067f3fa937f7d42be30e2275","modified":1514009288301},{"_id":"source/_posts/React-UI-心得文之一.md","hash":"866fb9e22942ad35d4fefdef4ec316b4f9862675","modified":1514009288299},{"_id":"source/_posts/React-和-Flux-到底在做什麼.md","hash":"8749fa5c0501f617b5020efdf28840c11dfa3d1f","modified":1514009288299},{"_id":"source/_posts/Redux-事件驅動系統-伺服器.md","hash":"407bee0714c73266504e2bb6c7cf131dbad4922f","modified":1514009288299},{"_id":"source/_posts/Redux-簡介：我終於看穿它了.md","hash":"06dbf52f42415e945f5a4b30d5fb8c54f1690397","modified":1514168393075},{"_id":"source/_posts/”redux-js-可預測的狀態容器“-的-API-使用說明.md","hash":"6fa6fef260477c365fb4511c55574baa23752760","modified":1514168393075},{"_id":"source/_posts/什麼是設計？.md","hash":"1479ed15f88a9129c7694d864947ac1d1aaf3a5a","modified":1514009288298},{"_id":"source/_posts/介紹-React-js-2013-by-Facebook.md","hash":"bc3f783d003953188a96d0797d106ebb37a4a99e","modified":1514009288299},{"_id":"source/_posts/使用者故事對照-地圖演講摘要-User-Story-Mapping.md","hash":"3fd23e792dd5feabd48ff122f7815a618a5c1731","modified":1514168393076},{"_id":"source/_posts/做-Prototype-的工具-framer-js.md","hash":"6854dad2f193ea69cef995ccd195e8eabb8c0741","modified":1514009288299},{"_id":"source/_posts/函數式編程介紹-1-2.md","hash":"b8fad0811a21a4517daa081b29c990b10a9ae181","modified":1514009288299},{"_id":"source/_posts/參加-FB-Hackathon-2015-感想.md","hash":"7c287de4d0b6adb3f1ce79f17c5497dc43395a3e","modified":1514009288299},{"_id":"source/_posts/台大不一樣思考社：設計思考工作坊-Day-1.md","hash":"6f809575e90a3db7bb99b9fb6f36ca88dc29030e","modified":1514009288299},{"_id":"source/_posts/台大不一樣思考社：設計思考工作坊-Day-2.md","hash":"a90f3747bee957fa9ff45fe4e91d95e7d21fca21","modified":1514009288299},{"_id":"source/_posts/大腦超載時代的思考學-The-Organized-Mind-Thinking-Straight-in-the-Age-of-Information-Overload.md","hash":"fe8133a5c2b8df9ec87a8e661cc4fd1b8fe684f0","modified":1514168393076},{"_id":"source/_posts/如何讓程式可維護-重構的方向-程式開發中的互動設計.md","hash":"cbcba87af1c84a1632c4f9403753be02140aaec6","modified":1514168393077},{"_id":"source/_posts/從買蘋果看工程師和設計師的差別？.md","hash":"e186980c484b934a99d58caef7b93f0c3324e0cc","modified":1514168393077},{"_id":"source/_posts/淺談函數式編程和-React.md","hash":"20d5c17e9fe8ed3eff01779edf2d8d61df3eb38d","modified":1514168393077},{"_id":"source/_posts/用-Redux-實踐「狀態機導向的介面開發」.md","hash":"aa48562a28d52fee0811b06aa01d15e901f5d0db","modified":1514009288299},{"_id":"source/_posts/研究-Node-js-和-Express-js-有感.md","hash":"717e694a2e3be816590f191b9a9b946abe77fc1a","modified":1514009288301},{"_id":"source/_posts/程式設計法與人生-Programming-Paradigm-and-Life.md","hash":"1cbb021cb3ae8b34a4c2da50c106f7342ff53544","modified":1514009288299},{"_id":"source/_posts/聊預測自己未來的能力.md","hash":"5d87ca638e5173392800693f315ca7c00c894be2","modified":1514009288299},{"_id":"source/_posts/見樹又見林-書摘-心得.md","hash":"fb9866addbc492035bc758618d8d15a1fadaeb27","modified":1514168393078},{"_id":"source/_posts/訓練英文的閱讀能力.md","hash":"1a6e5fe285b7aab63f7abb8d7455c449970cd809","modified":1514009288299},{"_id":"source/_posts/資訊架構學是什麼？.md","hash":"a0b40c8b9c7c1b15c435da47cc2bc4c0ee1a90f3","modified":1514168393078},{"_id":"themes/landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1514008587179},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1514008587179},{"_id":"themes/landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1514008587179},{"_id":"themes/landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1514008587180},{"_id":"themes/landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1514008587180},{"_id":"themes/landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1514008587180},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1514008587180},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1514008587180},{"_id":"themes/landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1514008587180},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1514008587180},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1514008587181},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1514008587181},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1514008587185},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1514008587185},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1514008587185},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1514008587186},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1514008587186},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1514008587186},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1514008587187},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1514008587187},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"d0d753d39038284d52b10e5075979cc97db9cd20","modified":1514008587181},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1514008587181},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"950ddd91db8718153b329b96dc14439ab8463ba5","modified":1514008587181},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1514008587182},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1514008587182},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1514008587182},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1514008587182},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"5abf77aec957d9445fc71a8310252f0013c84578","modified":1514008587182},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"7e749050be126eadbc42decfbea75124ae430413","modified":1514008587182},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1514008587183},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1514008587184},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1514008587184},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1514008587184},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1514008587184},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1514008587185},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1514008587185},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1514008587188},{"_id":"themes/landscape/source/css/_variables.styl","hash":"628e307579ea46b5928424313993f17b8d729e92","modified":1514008587191},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1514008587196},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1514008587197},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1514008587197},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1514008587197},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1514008587197},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1514008587198},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1514008587198},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1514008587199},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1514008587199},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1514008587200},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1514008587200},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1514008587183},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1514008587183},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1514008587183},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1514008587183},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1514008587183},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1514008587184},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1514008587188},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1514008587189},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1514008587188},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1514008587189},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1514008587189},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1514008587189},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1514008587189},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1514008587190},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1514008587190},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1514008587190},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1514008587190},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1514008587190},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1514008587191},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1514008587191},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1514008587194},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1514008587198},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1514008587198},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1514008587198},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1514008587198},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1514008587199},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1514008587199},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1514008587194},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1514008587193},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1514008587196},{"_id":"public/2016/11/06/Redux-簡介：我終於看穿它了/index.html","hash":"628a21569f0cb78c80021faf3dca4532b667c338","modified":1514337301422},{"_id":"public/2016/01/29/淺談函數式編程和-React/index.html","hash":"5c8d27b8ffca2b43b4196d54f1d3b8fc703762b7","modified":1514337301431},{"_id":"public/2015/12/20/台大不一樣思考社：設計思考工作坊-Day-2/index.html","hash":"01aee88e61173fc920f41f07674118a3627988a9","modified":1514337301431},{"_id":"public/2015/12/20/台大不一樣思考社：設計思考工作坊-Day-1/index.html","hash":"053dede8489fa22a65d5942cf3c50cf4810b2547","modified":1514337301423},{"_id":"public/2015/12/06/Firebase：前端工程師的神兵利器/index.html","hash":"1e7d1d26e87992d9dec93275ad6d282790935b71","modified":1514337301423},{"_id":"public/2015/11/28/聊預測自己未來的能力/index.html","hash":"ab06be2eaa6a7545e7aa5b09a1b60b0f961329e1","modified":1514337301423},{"_id":"public/2015/11/21/程式設計法與人生-Programming-Paradigm-and-Life/index.html","hash":"056552350bde9ddf9e84d7bde3bc1a5ba69538d8","modified":1514337301431},{"_id":"public/2015/11/15/參加-FB-Hackathon-2015-感想/index.html","hash":"96db01184b4c86474c28faf7a71da58fe5afa0e5","modified":1514337301431},{"_id":"public/2015/11/07/訓練英文的閱讀能力/index.html","hash":"7f52879874093a97ebf0e64c90b1b03e04920250","modified":1514337301423},{"_id":"public/2015/11/06/用-Redux-實踐「狀態機導向的介面開發」/index.html","hash":"111308abf938ed8ba480fcf150806b54134428e3","modified":1514337301432},{"_id":"public/2015/11/04/Be-predictable-not-correct-by-Pete-Hunt-from-Instagram/index.html","hash":"eb6056df416bc7760bb4e63696ef4257835be958","modified":1514337301423},{"_id":"public/2015/11/04/研究-Node-js-和-Express-js-有感/index.html","hash":"f0301684fac7e1961609587a53a049285d7c5f26","modified":1514337301423},{"_id":"public/archives/index.html","hash":"60e117ed03fe80922ce642839ab4c0031a99566d","modified":1514337301423},{"_id":"public/archives/page/2/index.html","hash":"9bf9f348f7dd38866a552e08a6786d6f63b15776","modified":1514337301424},{"_id":"public/archives/page/3/index.html","hash":"f5b561573fef60de8b7b9038e59109b69fa88acf","modified":1514337301424},{"_id":"public/archives/2015/index.html","hash":"75168a82fd6d76b4446178824ad0effdd32f95e2","modified":1514337301424},{"_id":"public/archives/2015/page/2/index.html","hash":"09d868207329e72101e506e74482d50e3dfd130c","modified":1514337301424},{"_id":"public/archives/2015/11/index.html","hash":"4db725f07aed8b10ccd39f330f2af8feba58735b","modified":1514337301424},{"_id":"public/archives/2015/11/page/2/index.html","hash":"92b8a762a24e772f4870a7673e9464de3eba169a","modified":1514337301424},{"_id":"public/archives/2015/12/index.html","hash":"35d83938563b371b2a293d923dcc4c033e37e6c0","modified":1514337301424},{"_id":"public/archives/2016/index.html","hash":"05e0f8da55750f68d846367fd16c19cc3237904b","modified":1514337301424},{"_id":"public/archives/2016/page/2/index.html","hash":"f70031a9eb8773b1524def4543427900f599b2e2","modified":1514337301425},{"_id":"public/archives/2016/01/index.html","hash":"388df0558a9635da3a9fe336cd087acc75eb6cf5","modified":1514337301425},{"_id":"public/archives/2016/02/index.html","hash":"e3d64fd97efad8712fb396b8233202c02728c780","modified":1514337301425},{"_id":"public/archives/2016/03/index.html","hash":"1941a3fed6e5285e5cf2aed59e10b4dbeefc1a2c","modified":1514337301425},{"_id":"public/archives/2016/04/index.html","hash":"f36243d6139a9cf3a9b191e751269ebbe3d9a0f2","modified":1514337301425},{"_id":"public/archives/2016/05/index.html","hash":"119246dd5cf900f49d106b1e9e39c433b26e8791","modified":1514337301425},{"_id":"public/archives/2016/06/index.html","hash":"f2c368614aca364ab337d9338b880618d9664ac7","modified":1514337301425},{"_id":"public/archives/2016/07/index.html","hash":"be3461cd9fc99e4bd47e5d5326c243763a8eaa31","modified":1514337301425},{"_id":"public/archives/2016/11/index.html","hash":"89bfad107b2d3e17ebf70334f83efcc676f15842","modified":1514337301425},{"_id":"public/tags/functional-programming/index.html","hash":"5e61658da81599e502bf007462e51a1df376d359","modified":1514337301425},{"_id":"public/tags/react/index.html","hash":"508476fe21d4a181d8d728a188d62558393f7e83","modified":1514337301425},{"_id":"public/tags/state-machine/index.html","hash":"631e54526aa66c3fe4043d0d2a8369f4124c64d6","modified":1514337301426},{"_id":"public/tags/composition/index.html","hash":"dbb1a7cee922f9c59373d9dd94e8b979c3ab7c32","modified":1514337301426},{"_id":"public/tags/currying/index.html","hash":"2041276d31f0758548c20bec42cd7a01b449ff75","modified":1514337301426},{"_id":"public/tags/functors/index.html","hash":"86dbb61eba7e247423b77ca96f474f7a8e7ee948","modified":1514337301426},{"_id":"public/tags/baas/index.html","hash":"4b11dd015ff22a0a1311bfc4ffcdca166c76300e","modified":1514337301426},{"_id":"public/tags/backend/index.html","hash":"4a83e3d9e4bfcc77f1390549d1b208774d6425f8","modified":1514337301426},{"_id":"public/tags/firebase/index.html","hash":"ec79079d8e906abb5458b8311a10a9ab4cf87793","modified":1514337301426},{"_id":"public/tags/frontend/index.html","hash":"0482c382cd763df136fdbac091e2fcb85dd12899","modified":1514337301426},{"_id":"public/tags/pure-function/index.html","hash":"4b4a0f5ae1c3e7b464df4c003609fdf92a42da37","modified":1514337301426},{"_id":"public/tags/node/index.html","hash":"39e25d64138f00f17bf643ff1e4c1b98225b13a1","modified":1514337301426},{"_id":"public/tags/yahoo/index.html","hash":"01335619abc9d2e9191607fa2f03b2f2271ffdc3","modified":1514337301426},{"_id":"public/tags/flux/index.html","hash":"f4c4e645585b560888d146ed20c8892d3db62368","modified":1514337301426},{"_id":"public/tags/event-system/index.html","hash":"95d9df0b523f1fd8c65b5aaec408af2598ad5a17","modified":1514337301426},{"_id":"public/tags/one-way-data-flow/index.html","hash":"1e64ee98b2794ac6e48f125e83988bac5b7652c3","modified":1514337301426},{"_id":"public/tags/redux/index.html","hash":"d9867475be29595f5c9020c3d1495795d22fd36a","modified":1514337301426},{"_id":"public/tags/MobX/index.html","hash":"1b82aaa4a0e41ace856dac41475ca43a41c996ed","modified":1514337301426},{"_id":"public/tags/Model/index.html","hash":"8bea39d15e50e102f8ef6198a43e0bf0182aa2b0","modified":1514337301426},{"_id":"public/tags/design/index.html","hash":"47029583a382f58134c78b12f63c1fe247572029","modified":1514337301426},{"_id":"public/tags/facebook/index.html","hash":"fd7d42fbfdc4892a1c98e53315554e8dc78e1c0a","modified":1514337301426},{"_id":"public/tags/agile/index.html","hash":"8be8d81c888e39a85507109cd88a6780cd794ed3","modified":1514337301426},{"_id":"public/tags/IA/index.html","hash":"fb84b0834a55484ae3d7b9ff3daa928df2c0272e","modified":1514337301427},{"_id":"public/tags/System-Thinking/index.html","hash":"9bfdb4e1ad233736365b466462b3533a0d565fa5","modified":1514337301427},{"_id":"public/tags/UCD/index.html","hash":"13e5621ee8fb191d19da68257a8933b05d08fc81","modified":1514337301427},{"_id":"public/tags/user-story-mapping/index.html","hash":"b86cea1f31a666c9c2ee3e9ea969f6ae8de1f66a","modified":1514337301427},{"_id":"public/tags/framer/index.html","hash":"36f14dd3815439fbfd2ef2f0e000677a28a8dc2f","modified":1514337301427},{"_id":"public/tags/prototyping/index.html","hash":"0f942f3c4b7a7d9ad0af01210085ce9ac9b00a03","modified":1514337301427},{"_id":"public/tags/ui/index.html","hash":"a172b956ff4c46de292a12be0cea5fd82e3ab56a","modified":1514337301427},{"_id":"public/tags/empathy/index.html","hash":"35fff2cf65778f152e697d29c4bf5a03b6661bf4","modified":1514337301427},{"_id":"public/tags/hackathon/index.html","hash":"5b92cae76370229f25a1dbfc2967c92a6a573b39","modified":1514337301427},{"_id":"public/tags/ux/index.html","hash":"93aabc9964d1b02a9cce2e6585074b366acedb7a","modified":1514337301427},{"_id":"public/tags/attention/index.html","hash":"bab1f672b0aa7cc81a9e1ded665d4f18adf286a4","modified":1514337301427},{"_id":"public/tags/cognitive-psychology/index.html","hash":"f7602b44001c541d9aa01f13eb8027cfc991c3f8","modified":1514337301427},{"_id":"public/tags/information/index.html","hash":"4616b3736eb7795458acc80777a78b8e93f6a2d1","modified":1514337301427},{"_id":"public/tags/psychology/index.html","hash":"dd30dc061a32dce249ec1c3a24ad8da477be627b","modified":1514337301427},{"_id":"public/tags/coding/index.html","hash":"dd03336d1c5a5359bc5be5baeab013360cb6f18b","modified":1514337301427},{"_id":"public/tags/interaction-design/index.html","hash":"0d6ba4c87b1d15cc167dba90c56eb2d7e7f8535d","modified":1514337301427},{"_id":"public/tags/refactoring/index.html","hash":"195ff84aea33291c841ec96a029f8f60bb9b0ebe","modified":1514337301427},{"_id":"public/tags/separation-of-concerns/index.html","hash":"3c0c55c4462ad59334486a439de18ebd258d32fa","modified":1514337301427},{"_id":"public/tags/design-thinking/index.html","hash":"9051eadd6573be7544e6f48c1799d012a228a41d","modified":1514337301427},{"_id":"public/tags/designer/index.html","hash":"5a2fd5b718b1b9652e60731d1d46c6bf58914015","modified":1514337301428},{"_id":"public/tags/engineering/index.html","hash":"42c4104aa7ed31a8fc629087a41cc3f7d72d026f","modified":1514337301428},{"_id":"public/tags/express/index.html","hash":"1db06ba82644311fe38dae9328649e2e70d55ff2","modified":1514337301428},{"_id":"public/tags/oop/index.html","hash":"48fc64f82fdc7c1e9ecea79e92b648806057e07a","modified":1514337301428},{"_id":"public/tags/vivid-dream/index.html","hash":"68c4dbac578fd934c4f5913819543c4ac507ce24","modified":1514337301428},{"_id":"public/tags/老子/index.html","hash":"ee7896fb2e2eaea0bf201e0472d638c1a8ec28e0","modified":1514337301428},{"_id":"public/tags/sociology/index.html","hash":"ee48ae7a7b43cde4c0374d2e3db65d2c918663b2","modified":1514337301428},{"_id":"public/tags/社會學/index.html","hash":"e9ae0e09493477d8f39b5bab0d137032c36d9161","modified":1514337301428},{"_id":"public/tags/information-architecture/index.html","hash":"0e7b8a166730fba46134e186576bc55268955a9b","modified":1514337301428},{"_id":"public/2016/07/23/見樹又見林-書摘-心得/index.html","hash":"59dadef010a3ae38a9c7145eba6464262db5b50f","modified":1514337301429},{"_id":"public/2016/06/01/大腦超載時代的思考學-The-Organized-Mind-Thinking-Straight-in-the-Age-of-Information-Overload/index.html","hash":"05032836ea24c8b27fc082bdc66a83f25f647f62","modified":1514337301429},{"_id":"public/2016/05/28/使用者故事對照-地圖演講摘要-User-Story-Mapping/index.html","hash":"98ae377146cb0420c54bdfa4603c1082f84b44a9","modified":1514337301431},{"_id":"public/2016/04/29/資訊架構學是什麼？/index.html","hash":"bad8e746fd032df39cbb4eb332b97ce564fa1957","modified":1514337301431},{"_id":"public/2016/04/10/”redux-js-可預測的狀態容器“-的-API-使用說明/index.html","hash":"252a6971897d891be93c455a83108297e505aded","modified":1514337301431},{"_id":"public/2016/03/04/如何讓程式可維護-重構的方向-程式開發中的互動設計/index.html","hash":"30d75b9a9029f766dc248c87ca53d266b2c2d1f2","modified":1514337301431},{"_id":"public/2016/02/08/從買蘋果看工程師和設計師的差別？/index.html","hash":"f80d912f25d406ad1f7194ce78324bd520361919","modified":1514337301431},{"_id":"public/2016/01/28/Hey-Underscore-You-re-doing-it-Wrong-介紹函數編程/index.html","hash":"8808335ca347c690d321b0b317c3c78255732137","modified":1514337301431},{"_id":"public/2016/01/01/什麼是設計？/index.html","hash":"eb6aab7102c81fbfd033cb0254e0e8c59c3b733d","modified":1514337301431},{"_id":"public/2015/12/02/React-UI-心得文之一/index.html","hash":"7c1bc6c304c74456188e2604d82000f641a0b837","modified":1514337301431},{"_id":"public/2015/11/11/做-Prototype-的工具-framer-js/index.html","hash":"8e1f82ce6fe752222984ed4c60cdc96690c743ab","modified":1514337301432},{"_id":"public/2015/11/09/函數式編程介紹-1-2/index.html","hash":"3b2ed934bb3501ba6aedc0074239ffbaaddedca2","modified":1514337301432},{"_id":"public/2015/11/08/Javascript-中的函數式編程-a-talk-ReactiveConf-2015/index.html","hash":"5ca2eab9f390fd626e2fc58df85ee7f1bcfde2d5","modified":1514337301432},{"_id":"public/2015/11/08/Redux-事件驅動系統-伺服器/index.html","hash":"760d8748b2b99ca7af152caedb9e28cb1a0ee4df","modified":1514337301432},{"_id":"public/2015/11/05/React-和-Flux-到底在做什麼/index.html","hash":"3195f7a92dd00a294f6e3d690e9dc57e16151202","modified":1514337301432},{"_id":"public/2015/11/05/介紹-React-js-2013-by-Facebook/index.html","hash":"da8c6cdec56007220b8b12bd96598b4411051872","modified":1514337301432},{"_id":"public/2015/11/03/Node-js-的發明人-Ryan-Dahl-在-Yahoo-介紹-Node-js-2010/index.html","hash":"7a3d89b2f257f62ac79d4b7de17c612a2eb501eb","modified":1514337301432},{"_id":"public/index.html","hash":"003c699142892c49320eebda5caa98a3455fad4b","modified":1514337433227},{"_id":"public/page/2/index.html","hash":"f806d82df3934d5a2d2bf1f099a7d4efa6b6172e","modified":1514337301432},{"_id":"public/page/3/index.html","hash":"d866b4fe9bc9a7b88d9c386f6cd19ab1a3e91066","modified":1514337301432},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1514168756203},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1514168756203},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1514168756203},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1514168756203},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1514168756203},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1514168756203},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1514168756203},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1514168756203},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1514168756204},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1514168756204},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1514168756661},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1514168756661},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1514168756661},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1514168756662},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1514168756662},{"_id":"public/css/style.css","hash":"5f8dadd37d0052c557061018fe6f568f64fced9b","modified":1514168756662},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1514168756662},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1514168756662},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1514168756662},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1514168756668},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1514168756668},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1514168756671},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1514168756671},{"_id":"source/.DS_Store","hash":"ca93c4d3a9e2b142059da564c8b32d05b071395f","modified":1514276428272},{"_id":"source/_posts/新海誠展-十五年動畫歷程.md","hash":"5d364a20e113ea1a0058bcab7f6fee889d1efc9c","modified":1514337427740},{"_id":"source/img/shinhai/12.jpeg","hash":"5be7a378488783eeff537df9dd9267906eb32990","modified":1514328798639},{"_id":"source/img/shinhai/2.jpeg","hash":"edc2f4d889335f565baea628b095d62b76ed93b3","modified":1514328798730},{"_id":"source/img/shinhai/5_1.jpeg","hash":"af3a2a80a3938f6367d15fe9379690e71aaad26b","modified":1514328799163},{"_id":"source/img/shinhai/9.jpeg","hash":"bb3de48e38435eccd99c95fdcbbff7bf85fb3785","modified":1514328799589},{"_id":"source/img/shinhai/6.jpeg","hash":"d7320b8c2381e5769417c8dcccd9cb90b797255b","modified":1514328799262},{"_id":"source/img/shinhai/4.jpeg","hash":"a032b70dab5cf17ee0e7f9d1914fbd9845713083","modified":1514328798944},{"_id":"source/img/shinhai/8.jpeg","hash":"2f0300d0557e066932d33f6b3e29fc7209859106","modified":1514328799486},{"_id":"source/img/shinhai/1.jpeg","hash":"cb6d6c46247613e6c18d3c7169cf0248f65586db","modified":1514328798452},{"_id":"source/img/shinhai/10.jpeg","hash":"e1a44728b5b54a5855e3e952dbe45b3c4c3e0924","modified":1514328798548},{"_id":"source/img/shinhai/5.jpeg","hash":"60c09b40ed241d80180911f89bf119f69108aa50","modified":1514328799055},{"_id":"source/img/shinhai/3.jpeg","hash":"3aa1f5aa0e1c4657d9638216ffc91d2958786b40","modified":1514328798849},{"_id":"source/img/shinhai/7.jpeg","hash":"e5141da5461aa22408702b2d6274ecdf5b3eb2f1","modified":1514328799373},{"_id":"public/archives/2017/index.html","hash":"f5e03c361a7748ecd87d5867a91c49ea0d0ad0dc","modified":1514337301425},{"_id":"public/archives/2017/12/index.html","hash":"0304daac33b611a09a1abbbcf126a44fa84b57b5","modified":1514337301425},{"_id":"public/tags/ACGN/index.html","hash":"c7e96b5f8c44766f655c5e1f05ac9dcc600ebd96","modified":1514337301429},{"_id":"public/tags/分鏡/index.html","hash":"b4deb390126fcfabd74b9dce8dd82e4f69f69af4","modified":1514337301429},{"_id":"public/2017/12/26/新海誠展-十五年動畫歷程/index.html","hash":"00084417773ca8c2c07a9580354337c304873d46","modified":1514337433227},{"_id":"public/img/shinhai/12.jpeg","hash":"5be7a378488783eeff537df9dd9267906eb32990","modified":1514337301467},{"_id":"public/img/shinhai/2.jpeg","hash":"edc2f4d889335f565baea628b095d62b76ed93b3","modified":1514337301468},{"_id":"public/img/shinhai/5_1.jpeg","hash":"af3a2a80a3938f6367d15fe9379690e71aaad26b","modified":1514337301468},{"_id":"public/img/shinhai/9.jpeg","hash":"bb3de48e38435eccd99c95fdcbbff7bf85fb3785","modified":1514337301468},{"_id":"public/img/shinhai/4.jpeg","hash":"a032b70dab5cf17ee0e7f9d1914fbd9845713083","modified":1514337301469},{"_id":"public/img/shinhai/6.jpeg","hash":"d7320b8c2381e5769417c8dcccd9cb90b797255b","modified":1514337301469},{"_id":"public/img/shinhai/8.jpeg","hash":"2f0300d0557e066932d33f6b3e29fc7209859106","modified":1514337301469},{"_id":"public/img/shinhai/1.jpeg","hash":"cb6d6c46247613e6c18d3c7169cf0248f65586db","modified":1514337301470},{"_id":"public/img/shinhai/10.jpeg","hash":"e1a44728b5b54a5855e3e952dbe45b3c4c3e0924","modified":1514337301470},{"_id":"public/img/shinhai/5.jpeg","hash":"60c09b40ed241d80180911f89bf119f69108aa50","modified":1514337301470},{"_id":"public/img/shinhai/3.jpeg","hash":"3aa1f5aa0e1c4657d9638216ffc91d2958786b40","modified":1514337301471},{"_id":"public/img/shinhai/7.jpeg","hash":"e5141da5461aa22408702b2d6274ecdf5b3eb2f1","modified":1514337301471}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Be predictable, not correct. by Pete Hunt (from Instagram)","date":"2015-11-04T12:27:00.000Z","_content":"\n<div class=\"separator\" style=\"clear: both; text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><iframe allowfullscreen=\"\" class=\"YOUTUBE-iframe-video\" data-thumbnail-src=\"https://i.ytimg.com/vi/e7A6EUe3XGM/0.jpg\" frameborder=\"0\" height=\"266\" src=\"https://www.youtube.com/embed/e7A6EUe3XGM?feature=player_embedded\" width=\"320\"></iframe></span></div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Pete Hunt from Instagram Web Team.</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span>**<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">What makes UI hard?</span>**\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">最難的是管理所有使用者的狀態 ( state )，更可怕的是隨時間改變的狀態。然後 Unit Test 不能完全測試 UI 的所有情況 ( 太多例外 )、靜態分析 ( JSLint / JSHint ) 也不行。因為這樣的複雜度，我不曾試著讓 UI 完全正確。我只是試著讓 UI 變得可預測。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Two silver bullet:</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">1\\. Composition: 讓簡單的 function 組合成更大的 function。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">2\\. Idempotence: 讓每次同樣的 Input 得到同樣的 Output。不變性 ( Immutability ) 的資料結構讓我免費得到 Idempotence。努力讓 mutable state 的數量越少越少，mutable state只有一個owner。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">React.js 讓工程師照著上面的兩個規則。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">React 是 宣告式的 ( declarative ) JQuery。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">**\n****React**</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp;&gt; Data 輸入 =&gt; virtual DOM 輸出。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp;&gt; 當資料改變的時候，就整個重繪，所以少掉很多 State。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span>**<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Demo Example (從15- 分)</span>**\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Demo on jsfiddle.net jsbin.com</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">一直在看Code</span>","source":"_posts/Be-predictable-not-correct-by-Pete-Hunt-from-Instagram.md","raw":"---\ntitle: 'Be predictable, not correct. by Pete Hunt (from Instagram)'\ntags:\n  - functional programming\n  - react\n  - state machine\ndate: 2015-11-04 20:27:00\n---\n\n<div class=\"separator\" style=\"clear: both; text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><iframe allowfullscreen=\"\" class=\"YOUTUBE-iframe-video\" data-thumbnail-src=\"https://i.ytimg.com/vi/e7A6EUe3XGM/0.jpg\" frameborder=\"0\" height=\"266\" src=\"https://www.youtube.com/embed/e7A6EUe3XGM?feature=player_embedded\" width=\"320\"></iframe></span></div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Pete Hunt from Instagram Web Team.</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span>**<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">What makes UI hard?</span>**\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">最難的是管理所有使用者的狀態 ( state )，更可怕的是隨時間改變的狀態。然後 Unit Test 不能完全測試 UI 的所有情況 ( 太多例外 )、靜態分析 ( JSLint / JSHint ) 也不行。因為這樣的複雜度，我不曾試著讓 UI 完全正確。我只是試著讓 UI 變得可預測。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Two silver bullet:</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">1\\. Composition: 讓簡單的 function 組合成更大的 function。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">2\\. Idempotence: 讓每次同樣的 Input 得到同樣的 Output。不變性 ( Immutability ) 的資料結構讓我免費得到 Idempotence。努力讓 mutable state 的數量越少越少，mutable state只有一個owner。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">React.js 讓工程師照著上面的兩個規則。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">React 是 宣告式的 ( declarative ) JQuery。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">**\n****React**</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp;&gt; Data 輸入 =&gt; virtual DOM 輸出。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp;&gt; 當資料改變的時候，就整個重繪，所以少掉很多 State。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span>**<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Demo Example (從15- 分)</span>**\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Demo on jsfiddle.net jsbin.com</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">一直在看Code</span>","slug":"Be-predictable-not-correct-by-Pete-Hunt-from-Instagram","published":1,"updated":"2017-12-23T06:08:08.300Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjblkzcjo0000xq9kzrac4xli","content":"<p><div class=\"separator\" style=\"clear: both; text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><iframe allowfullscreen class=\"YOUTUBE-iframe-video\" data-thumbnail-src=\"https://i.ytimg.com/vi/e7A6EUe3XGM/0.jpg\" frameborder=\"0\" height=\"266\" src=\"https://www.youtube.com/embed/e7A6EUe3XGM?feature=player_embedded\" width=\"320\"></iframe></span></div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Pete Hunt from Instagram Web Team.</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><strong><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">What makes UI hard?</span></strong><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">最難的是管理所有使用者的狀態 ( state )，更可怕的是隨時間改變的狀態。然後 Unit Test 不能完全測試 UI 的所有情況 ( 太多例外 )、靜態分析 ( JSLint / JSHint ) 也不行。因為這樣的複雜度，我不曾試著讓 UI 完全正確。我只是試著讓 UI 變得可預測。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Two silver bullet:</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">1. Composition: 讓簡單的 function 組合成更大的 function。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">2. Idempotence: 讓每次同樣的 Input 得到同樣的 Output。不變性 ( Immutability ) 的資料結構讓我免費得到 Idempotence。努力讓 mutable state 的數量越少越少，mutable state只有一個owner。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">React.js 讓工程師照著上面的兩個規則。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">React 是 宣告式的 ( declarative ) JQuery。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><strong><br>**</strong>React<strong></strong></span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp;&gt; Data 輸入 =&gt; virtual DOM 輸出。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp;&gt; 當資料改變的時候，就整個重繪，所以少掉很多 State。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Demo Example (從15- 分)</span>**<br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Demo on jsfiddle.net jsbin.com</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">一直在看Code</span></p>\n","site":{"data":{}},"excerpt":"","more":"<p><div class=\"separator\" style=\"clear: both; text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><iframe allowfullscreen class=\"YOUTUBE-iframe-video\" data-thumbnail-src=\"https://i.ytimg.com/vi/e7A6EUe3XGM/0.jpg\" frameborder=\"0\" height=\"266\" src=\"https://www.youtube.com/embed/e7A6EUe3XGM?feature=player_embedded\" width=\"320\"></iframe></span></div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Pete Hunt from Instagram Web Team.</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><strong><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">What makes UI hard?</span></strong><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">最難的是管理所有使用者的狀態 ( state )，更可怕的是隨時間改變的狀態。然後 Unit Test 不能完全測試 UI 的所有情況 ( 太多例外 )、靜態分析 ( JSLint / JSHint ) 也不行。因為這樣的複雜度，我不曾試著讓 UI 完全正確。我只是試著讓 UI 變得可預測。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Two silver bullet:</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">1. Composition: 讓簡單的 function 組合成更大的 function。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">2. Idempotence: 讓每次同樣的 Input 得到同樣的 Output。不變性 ( Immutability ) 的資料結構讓我免費得到 Idempotence。努力讓 mutable state 的數量越少越少，mutable state只有一個owner。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">React.js 讓工程師照著上面的兩個規則。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">React 是 宣告式的 ( declarative ) JQuery。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><strong><br>**</strong>React<strong></strong></span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp;&gt; Data 輸入 =&gt; virtual DOM 輸出。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp;&gt; 當資料改變的時候，就整個重繪，所以少掉很多 State。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Demo Example (從15- 分)</span>**<br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Demo on jsfiddle.net jsbin.com</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">一直在看Code</span></p>\n"},{"title":"Hey Underscore, You're doing it Wrong! (介紹函數編程)","date":"2016-01-28T14:05:00.000Z","_content":"\n<iframe allowfullscreen=\"\" class=\"YOUTUBE-iframe-video\" data-thumbnail-src=\"https://i.ytimg.com/vi/m3svKOdZijA/0.jpg\" frameborder=\"0\" height=\"266\" src=\"https://www.youtube.com/embed/m3svKOdZijA?feature=player_embedded\" width=\"320\"></iframe>\n\n----------------------------------------------------------\nCurried Function：到拿到所有需要的參數前... 一直回傳新函數的函數。\n```js\nvar add = function(x) {\n  return function(y) {\n    return x + y;\n  }\n}\n\nvar add3 = add(3);\nadd3(4); //return 7\n\nadd(3)(4); //weird thing \n``` \nautoCurry in Wu.js will save us \n```js\nvar add = function(x, y) {\n  return x + y;\n}.autoCurry();\n\nvar add3 = add(3);\nadd3(4) //7\n\nadd(3,5) //8 => not weird any more!!!\n``` \n但我們為什麼需要 curry？參考下面這個組成新 function getTheOdds 的例子。 有了currying，我們可以透過給予不同參數來建立新的函數。 \n```js\nvar filter = function(f, xs) {\n  return xs.filter(f);\n}\n\nfilter(isOdd, [1,2,3,4,5]) // [1,3,5]\n\nvar getTheOdds = filter(isOdd);\ngetTheOdds([1,2,3,4,5]) //[1,3,5]\n``` \n再來一個用loadash的酷例子 \n```js\n//沒用currying、不函數化的寫法\nvar firstTwoLetters = function(words){\n  return _.map(words, function(word){\n    return _.first(word, 2);\n  });\n}\n\n//函數化的寫法(如果underscore吃參數的方式是反過來的話)\nvar firstTwoLetters = _.map(_.first(2));\n\n//更函數化的寫法\n_.map(_.first(2), ['jim', 'kate']) //['ji', 'ka'] \n``` \n=> Underscore.js的參數排列法讓currying變得不可能  總結currying的優點有下面四個： \n* 一般化函數、要傳的變數名消失了 \n* 透過給不同參數就可以生成不同的函數 \n* 更簡潔的定義 \n* 讓函式的組合/合成 (composition) 變的可能  \n---------------------------------------------------------- \n組合/合成 (composition):用多個函數來組成新函數  簡單的例子，用 first() 和 reverse() 來合成 last 函數 \n```js\nvar last = function(xs) {\n  var sx = reverse(xs);\n  return first(sx);\n}\n\nvar last = compose(first, reverse);\n\nlast([1,2,3]) //3\n``` \n另一個例子，chain backwardly \n```js\nvar wordCount = function(str){\n  var words = split(' ', str);\n  return length(words);\n}\n\nvar wordCount = compose(length, split(' '));\nwordCount(\"There is a way to save the world\") //8\n``` \n**Category Theory:** 多個函數組合(compose)，作用域互相對應的理論。Connecting the dot.  總結組合：\n* 能從其他函數組成新函數 \n* 組合過程中把參數藏起來 \n* 極為高階的寫程式 \n* 有數學理論在後面支持  \n------------------------------------------------------------------ \nFunctors  map 打開了後面的 object 然後做一些事、再放回 object \n```js\nvar plus1 = function(x){ return x + 1 }\n\nplus1([3]) //wrong!!\n\nmap(plus1, [3]) //4\n```\n剛剛舉的例子，map 只能操作 array object、但下面試圖用 map 操作所有 object \n```js\nmap(plus1, MyObject(3)) //MyObject(4)\n\nMyObject = function(val) {\n  this.val = val;\n}\n\nMyObject.prototype.map = function(f) {\n  return MyObject(f(this.val));\n}\n``` \n如果對 object 定義了 map function，它就變成 functor null check的例子、Dynamic Safety： \n```js\nmap(plus1, Maybe(3)) //=> Maybe(4)\n\nmap(plus1, Maybe(null)) //=> Maybe(null)\n\nMaybe = function(val) {\n  this.val = val;\n}\n\nMaybe.prototype.map = function(f){\n  return this.val ? Maybe(f(this.val)) : Maybe(null);\n}\n``` \n把 ES6 promise 變 functor 的例子 \n```js\nmap(populateTable, $.ajax.get('/posts');\n\nPromise.prototype.map = function(f) {\n  var promise = new Promise();\n  this.then(function(response){\n    promise.resolve(f(response));\n  });\n  return promise;\n}\n``` \n再來一個和 html 合作的例子：對有和沒有 user_login 的情況下，更新歡迎頁面。 \n```js\n$div = $(\"#myDiv\");\n\n//dot 會把 user.name 拿出來\nvar getGreeting = compose(concat('Welcome '), dot('name'));\n\nvar updateGreetingHtml = compose($div.html, getGreeting);\n\nmap(updateGreetingHtml, Maybe(App.current_user));\n``` \nunderscore 不讓人 extend map  總結 functor 能: \n* 改變函數的行為卻不用變動 open/closed principle \n* 不光只有 map, 還有 reduce & compose *\n直覺且非私人的 api \n* free formulas \n* 動態型別安全/檢查 \n\n------------------------------------------------------------- \n\n總結：underscore 能變得更加 functional。希望有更 functional 的 library\n","source":"_posts/Hey-Underscore-You-re-doing-it-Wrong-介紹函數編程.md","raw":"---\ntitle: 'Hey Underscore, You''re doing it Wrong! (介紹函數編程)'\ntags:\n  - composition\n  - currying\n  - functional programming\n  - functors\ndate: 2016-01-28 22:05:00\n---\n\n<iframe allowfullscreen=\"\" class=\"YOUTUBE-iframe-video\" data-thumbnail-src=\"https://i.ytimg.com/vi/m3svKOdZijA/0.jpg\" frameborder=\"0\" height=\"266\" src=\"https://www.youtube.com/embed/m3svKOdZijA?feature=player_embedded\" width=\"320\"></iframe>\n\n----------------------------------------------------------\nCurried Function：到拿到所有需要的參數前... 一直回傳新函數的函數。\n```js\nvar add = function(x) {\n  return function(y) {\n    return x + y;\n  }\n}\n\nvar add3 = add(3);\nadd3(4); //return 7\n\nadd(3)(4); //weird thing \n``` \nautoCurry in Wu.js will save us \n```js\nvar add = function(x, y) {\n  return x + y;\n}.autoCurry();\n\nvar add3 = add(3);\nadd3(4) //7\n\nadd(3,5) //8 => not weird any more!!!\n``` \n但我們為什麼需要 curry？參考下面這個組成新 function getTheOdds 的例子。 有了currying，我們可以透過給予不同參數來建立新的函數。 \n```js\nvar filter = function(f, xs) {\n  return xs.filter(f);\n}\n\nfilter(isOdd, [1,2,3,4,5]) // [1,3,5]\n\nvar getTheOdds = filter(isOdd);\ngetTheOdds([1,2,3,4,5]) //[1,3,5]\n``` \n再來一個用loadash的酷例子 \n```js\n//沒用currying、不函數化的寫法\nvar firstTwoLetters = function(words){\n  return _.map(words, function(word){\n    return _.first(word, 2);\n  });\n}\n\n//函數化的寫法(如果underscore吃參數的方式是反過來的話)\nvar firstTwoLetters = _.map(_.first(2));\n\n//更函數化的寫法\n_.map(_.first(2), ['jim', 'kate']) //['ji', 'ka'] \n``` \n=> Underscore.js的參數排列法讓currying變得不可能  總結currying的優點有下面四個： \n* 一般化函數、要傳的變數名消失了 \n* 透過給不同參數就可以生成不同的函數 \n* 更簡潔的定義 \n* 讓函式的組合/合成 (composition) 變的可能  \n---------------------------------------------------------- \n組合/合成 (composition):用多個函數來組成新函數  簡單的例子，用 first() 和 reverse() 來合成 last 函數 \n```js\nvar last = function(xs) {\n  var sx = reverse(xs);\n  return first(sx);\n}\n\nvar last = compose(first, reverse);\n\nlast([1,2,3]) //3\n``` \n另一個例子，chain backwardly \n```js\nvar wordCount = function(str){\n  var words = split(' ', str);\n  return length(words);\n}\n\nvar wordCount = compose(length, split(' '));\nwordCount(\"There is a way to save the world\") //8\n``` \n**Category Theory:** 多個函數組合(compose)，作用域互相對應的理論。Connecting the dot.  總結組合：\n* 能從其他函數組成新函數 \n* 組合過程中把參數藏起來 \n* 極為高階的寫程式 \n* 有數學理論在後面支持  \n------------------------------------------------------------------ \nFunctors  map 打開了後面的 object 然後做一些事、再放回 object \n```js\nvar plus1 = function(x){ return x + 1 }\n\nplus1([3]) //wrong!!\n\nmap(plus1, [3]) //4\n```\n剛剛舉的例子，map 只能操作 array object、但下面試圖用 map 操作所有 object \n```js\nmap(plus1, MyObject(3)) //MyObject(4)\n\nMyObject = function(val) {\n  this.val = val;\n}\n\nMyObject.prototype.map = function(f) {\n  return MyObject(f(this.val));\n}\n``` \n如果對 object 定義了 map function，它就變成 functor null check的例子、Dynamic Safety： \n```js\nmap(plus1, Maybe(3)) //=> Maybe(4)\n\nmap(plus1, Maybe(null)) //=> Maybe(null)\n\nMaybe = function(val) {\n  this.val = val;\n}\n\nMaybe.prototype.map = function(f){\n  return this.val ? Maybe(f(this.val)) : Maybe(null);\n}\n``` \n把 ES6 promise 變 functor 的例子 \n```js\nmap(populateTable, $.ajax.get('/posts');\n\nPromise.prototype.map = function(f) {\n  var promise = new Promise();\n  this.then(function(response){\n    promise.resolve(f(response));\n  });\n  return promise;\n}\n``` \n再來一個和 html 合作的例子：對有和沒有 user_login 的情況下，更新歡迎頁面。 \n```js\n$div = $(\"#myDiv\");\n\n//dot 會把 user.name 拿出來\nvar getGreeting = compose(concat('Welcome '), dot('name'));\n\nvar updateGreetingHtml = compose($div.html, getGreeting);\n\nmap(updateGreetingHtml, Maybe(App.current_user));\n``` \nunderscore 不讓人 extend map  總結 functor 能: \n* 改變函數的行為卻不用變動 open/closed principle \n* 不光只有 map, 還有 reduce & compose *\n直覺且非私人的 api \n* free formulas \n* 動態型別安全/檢查 \n\n------------------------------------------------------------- \n\n總結：underscore 能變得更加 functional。希望有更 functional 的 library\n","slug":"Hey-Underscore-You-re-doing-it-Wrong-介紹函數編程","published":1,"updated":"2017-12-25T02:19:53.075Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjblkzcjv0001xq9kxvf5crh9","content":"<iframe allowfullscreen class=\"YOUTUBE-iframe-video\" data-thumbnail-src=\"https://i.ytimg.com/vi/m3svKOdZijA/0.jpg\" frameborder=\"0\" height=\"266\" src=\"https://www.youtube.com/embed/m3svKOdZijA?feature=player_embedded\" width=\"320\"></iframe>\n\n<hr>\n<p>Curried Function：到拿到所有需要的參數前… 一直回傳新函數的函數。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> add3 = add(<span class=\"number\">3</span>);</span><br><span class=\"line\">add3(<span class=\"number\">4</span>); <span class=\"comment\">//return 7</span></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">3</span>)(<span class=\"number\">4</span>); <span class=\"comment\">//weird thing </span></span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></span><br><span class=\"line\"><span class=\"string\">autoCurry in Wu.js will save us </span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\"><span class=\"keyword\">var</span> add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;.autoCurry();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> add3 = add(<span class=\"number\">3</span>);</span><br><span class=\"line\">add3(<span class=\"number\">4</span>) <span class=\"comment\">//7</span></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">3</span>,<span class=\"number\">5</span>) <span class=\"comment\">//8 =&gt; not weird any more!!!</span></span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></span><br><span class=\"line\"><span class=\"string\">但我們為什麼需要 curry？參考下面這個組成新 function getTheOdds 的例子。 有了currying，我們可以透過給予不同參數來建立新的函數。 </span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\"><span class=\"keyword\">var</span> filter = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f, xs</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> xs.filter(f);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">filter(isOdd, [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]) <span class=\"comment\">// [1,3,5]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> getTheOdds = filter(isOdd);</span><br><span class=\"line\">getTheOdds([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]) <span class=\"comment\">//[1,3,5]</span></span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></span><br><span class=\"line\"><span class=\"string\">再來一個用loadash的酷例子 </span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\"><span class=\"comment\">//沒用currying、不函數化的寫法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> firstTwoLetters = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">words</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> _.map(words, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">word</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _.first(word, <span class=\"number\">2</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//函數化的寫法(如果underscore吃參數的方式是反過來的話)</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> firstTwoLetters = _.map(_.first(<span class=\"number\">2</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//更函數化的寫法</span></span><br><span class=\"line\">_.map(_.first(<span class=\"number\">2</span>), [<span class=\"string\">'jim'</span>, <span class=\"string\">'kate'</span>]) <span class=\"comment\">//['ji', 'ka'] </span></span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></span><br><span class=\"line\"><span class=\"string\">=&gt; Underscore.js的參數排列法讓currying變得不可能  總結currying的優點有下面四個： </span></span><br><span class=\"line\"><span class=\"string\">* 一般化函數、要傳的變數名消失了 </span></span><br><span class=\"line\"><span class=\"string\">* 透過給不同參數就可以生成不同的函數 </span></span><br><span class=\"line\"><span class=\"string\">* 更簡潔的定義 </span></span><br><span class=\"line\"><span class=\"string\">* 讓函式的組合/合成 (composition) 變的可能  </span></span><br><span class=\"line\"><span class=\"string\">---------------------------------------------------------- </span></span><br><span class=\"line\"><span class=\"string\">組合/合成 (composition):用多個函數來組成新函數  簡單的例子，用 first() 和 reverse() 來合成 last 函數 </span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\"><span class=\"keyword\">var</span> last = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">xs</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> sx = reverse(xs);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> first(sx);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> last = compose(first, reverse);</span><br><span class=\"line\"></span><br><span class=\"line\">last([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]) <span class=\"comment\">//3</span></span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></span><br><span class=\"line\"><span class=\"string\">另一個例子，chain backwardly </span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\"><span class=\"keyword\">var</span> wordCount = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">str</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> words = split(<span class=\"string\">' '</span>, str);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> length(words);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> wordCount = compose(length, split(<span class=\"string\">' '</span>));</span><br><span class=\"line\">wordCount(<span class=\"string\">\"There is a way to save the world\"</span>) <span class=\"comment\">//8</span></span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></span><br><span class=\"line\"><span class=\"string\">**Category Theory:** 多個函數組合(compose)，作用域互相對應的理論。Connecting the dot.  總結組合：</span></span><br><span class=\"line\"><span class=\"string\">* 能從其他函數組成新函數 </span></span><br><span class=\"line\"><span class=\"string\">* 組合過程中把參數藏起來 </span></span><br><span class=\"line\"><span class=\"string\">* 極為高階的寫程式 </span></span><br><span class=\"line\"><span class=\"string\">* 有數學理論在後面支持  </span></span><br><span class=\"line\"><span class=\"string\">------------------------------------------------------------------ </span></span><br><span class=\"line\"><span class=\"string\">Functors  map 打開了後面的 object 然後做一些事、再放回 object </span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\"><span class=\"keyword\">var</span> plus1 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123; <span class=\"keyword\">return</span> x + <span class=\"number\">1</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">plus1([<span class=\"number\">3</span>]) <span class=\"comment\">//wrong!!</span></span><br><span class=\"line\"></span><br><span class=\"line\">map(plus1, [<span class=\"number\">3</span>]) <span class=\"comment\">//4</span></span><br></pre></td></tr></table></figure></p>\n<p>剛剛舉的例子，map 只能操作 array object、但下面試圖用 map 操作所有 object </p>\n<pre><code class=\"js\">map(plus1, MyObject(<span class=\"number\">3</span>)) <span class=\"comment\">//MyObject(4)</span>\n\nMyObject = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">val</span>) </span>{\n  <span class=\"keyword\">this</span>.val = val;\n}\n\nMyObject.prototype.map = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>{\n  <span class=\"keyword\">return</span> MyObject(f(<span class=\"keyword\">this</span>.val));\n}\n</code></pre>\n<p>如果對 object 定義了 map function，它就變成 functor null check的例子、Dynamic Safety： </p>\n<pre><code class=\"js\">map(plus1, Maybe(<span class=\"number\">3</span>)) <span class=\"comment\">//=&gt; Maybe(4)</span>\n\nmap(plus1, Maybe(<span class=\"literal\">null</span>)) <span class=\"comment\">//=&gt; Maybe(null)</span>\n\nMaybe = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">val</span>) </span>{\n  <span class=\"keyword\">this</span>.val = val;\n}\n\nMaybe.prototype.map = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>)</span>{\n  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.val ? Maybe(f(<span class=\"keyword\">this</span>.val)) : Maybe(<span class=\"literal\">null</span>);\n}\n</code></pre>\n<p>把 ES6 promise 變 functor 的例子 </p>\n<pre><code class=\"js\">map(populateTable, $.ajax.get(<span class=\"string\">'/posts'</span>);\n\n<span class=\"built_in\">Promise</span>.prototype.map = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>{\n  <span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>();\n  <span class=\"keyword\">this</span>.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">response</span>)</span>{\n    promise.resolve(f(response));\n  });\n  <span class=\"keyword\">return</span> promise;\n}\n</code></pre>\n<p>再來一個和 html 合作的例子：對有和沒有 user_login 的情況下，更新歡迎頁面。 </p>\n<pre><code class=\"js\">$div = $(<span class=\"string\">\"#myDiv\"</span>);\n\n<span class=\"comment\">//dot 會把 user.name 拿出來</span>\n<span class=\"keyword\">var</span> getGreeting = compose(concat(<span class=\"string\">'Welcome '</span>), dot(<span class=\"string\">'name'</span>));\n\n<span class=\"keyword\">var</span> updateGreetingHtml = compose($div.html, getGreeting);\n\nmap(updateGreetingHtml, Maybe(App.current_user));\n</code></pre>\n<p>underscore 不讓人 extend map  總結 functor 能: </p>\n<ul>\n<li>改變函數的行為卻不用變動 open/closed principle </li>\n<li>不光只有 map, 還有 reduce &amp; compose *<br>直覺且非私人的 api </li>\n<li>free formulas </li>\n<li>動態型別安全/檢查 </li>\n</ul>\n<hr>\n<p>總結：underscore 能變得更加 functional。希望有更 functional 的 library</p>\n","site":{"data":{}},"excerpt":"","more":"<iframe allowfullscreen class=\"YOUTUBE-iframe-video\" data-thumbnail-src=\"https://i.ytimg.com/vi/m3svKOdZijA/0.jpg\" frameborder=\"0\" height=\"266\" src=\"https://www.youtube.com/embed/m3svKOdZijA?feature=player_embedded\" width=\"320\"></iframe>\n\n<hr>\n<p>Curried Function：到拿到所有需要的參數前… 一直回傳新函數的函數。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> add3 = add(<span class=\"number\">3</span>);</span><br><span class=\"line\">add3(<span class=\"number\">4</span>); <span class=\"comment\">//return 7</span></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">3</span>)(<span class=\"number\">4</span>); <span class=\"comment\">//weird thing </span></span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></span><br><span class=\"line\"><span class=\"string\">autoCurry in Wu.js will save us </span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\"><span class=\"keyword\">var</span> add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;.autoCurry();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> add3 = add(<span class=\"number\">3</span>);</span><br><span class=\"line\">add3(<span class=\"number\">4</span>) <span class=\"comment\">//7</span></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">3</span>,<span class=\"number\">5</span>) <span class=\"comment\">//8 =&gt; not weird any more!!!</span></span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></span><br><span class=\"line\"><span class=\"string\">但我們為什麼需要 curry？參考下面這個組成新 function getTheOdds 的例子。 有了currying，我們可以透過給予不同參數來建立新的函數。 </span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\"><span class=\"keyword\">var</span> filter = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f, xs</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> xs.filter(f);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">filter(isOdd, [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]) <span class=\"comment\">// [1,3,5]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> getTheOdds = filter(isOdd);</span><br><span class=\"line\">getTheOdds([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]) <span class=\"comment\">//[1,3,5]</span></span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></span><br><span class=\"line\"><span class=\"string\">再來一個用loadash的酷例子 </span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\"><span class=\"comment\">//沒用currying、不函數化的寫法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> firstTwoLetters = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">words</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> _.map(words, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">word</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _.first(word, <span class=\"number\">2</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//函數化的寫法(如果underscore吃參數的方式是反過來的話)</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> firstTwoLetters = _.map(_.first(<span class=\"number\">2</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//更函數化的寫法</span></span><br><span class=\"line\">_.map(_.first(<span class=\"number\">2</span>), [<span class=\"string\">'jim'</span>, <span class=\"string\">'kate'</span>]) <span class=\"comment\">//['ji', 'ka'] </span></span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></span><br><span class=\"line\"><span class=\"string\">=&gt; Underscore.js的參數排列法讓currying變得不可能  總結currying的優點有下面四個： </span></span><br><span class=\"line\"><span class=\"string\">* 一般化函數、要傳的變數名消失了 </span></span><br><span class=\"line\"><span class=\"string\">* 透過給不同參數就可以生成不同的函數 </span></span><br><span class=\"line\"><span class=\"string\">* 更簡潔的定義 </span></span><br><span class=\"line\"><span class=\"string\">* 讓函式的組合/合成 (composition) 變的可能  </span></span><br><span class=\"line\"><span class=\"string\">---------------------------------------------------------- </span></span><br><span class=\"line\"><span class=\"string\">組合/合成 (composition):用多個函數來組成新函數  簡單的例子，用 first() 和 reverse() 來合成 last 函數 </span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\"><span class=\"keyword\">var</span> last = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">xs</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> sx = reverse(xs);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> first(sx);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> last = compose(first, reverse);</span><br><span class=\"line\"></span><br><span class=\"line\">last([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]) <span class=\"comment\">//3</span></span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></span><br><span class=\"line\"><span class=\"string\">另一個例子，chain backwardly </span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\"><span class=\"keyword\">var</span> wordCount = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">str</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> words = split(<span class=\"string\">' '</span>, str);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> length(words);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> wordCount = compose(length, split(<span class=\"string\">' '</span>));</span><br><span class=\"line\">wordCount(<span class=\"string\">\"There is a way to save the world\"</span>) <span class=\"comment\">//8</span></span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></span><br><span class=\"line\"><span class=\"string\">**Category Theory:** 多個函數組合(compose)，作用域互相對應的理論。Connecting the dot.  總結組合：</span></span><br><span class=\"line\"><span class=\"string\">* 能從其他函數組成新函數 </span></span><br><span class=\"line\"><span class=\"string\">* 組合過程中把參數藏起來 </span></span><br><span class=\"line\"><span class=\"string\">* 極為高階的寫程式 </span></span><br><span class=\"line\"><span class=\"string\">* 有數學理論在後面支持  </span></span><br><span class=\"line\"><span class=\"string\">------------------------------------------------------------------ </span></span><br><span class=\"line\"><span class=\"string\">Functors  map 打開了後面的 object 然後做一些事、再放回 object </span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\"><span class=\"keyword\">var</span> plus1 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123; <span class=\"keyword\">return</span> x + <span class=\"number\">1</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">plus1([<span class=\"number\">3</span>]) <span class=\"comment\">//wrong!!</span></span><br><span class=\"line\"></span><br><span class=\"line\">map(plus1, [<span class=\"number\">3</span>]) <span class=\"comment\">//4</span></span><br></pre></td></tr></table></figure></p>\n<p>剛剛舉的例子，map 只能操作 array object、但下面試圖用 map 操作所有 object </p>\n<pre><code class=\"js\">map(plus1, MyObject(<span class=\"number\">3</span>)) <span class=\"comment\">//MyObject(4)</span>\n\nMyObject = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">val</span>) </span>{\n  <span class=\"keyword\">this</span>.val = val;\n}\n\nMyObject.prototype.map = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>{\n  <span class=\"keyword\">return</span> MyObject(f(<span class=\"keyword\">this</span>.val));\n}\n</code></pre>\n<p>如果對 object 定義了 map function，它就變成 functor null check的例子、Dynamic Safety： </p>\n<pre><code class=\"js\">map(plus1, Maybe(<span class=\"number\">3</span>)) <span class=\"comment\">//=&gt; Maybe(4)</span>\n\nmap(plus1, Maybe(<span class=\"literal\">null</span>)) <span class=\"comment\">//=&gt; Maybe(null)</span>\n\nMaybe = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">val</span>) </span>{\n  <span class=\"keyword\">this</span>.val = val;\n}\n\nMaybe.prototype.map = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>)</span>{\n  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.val ? Maybe(f(<span class=\"keyword\">this</span>.val)) : Maybe(<span class=\"literal\">null</span>);\n}\n</code></pre>\n<p>把 ES6 promise 變 functor 的例子 </p>\n<pre><code class=\"js\">map(populateTable, $.ajax.get(<span class=\"string\">'/posts'</span>);\n\n<span class=\"built_in\">Promise</span>.prototype.map = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>{\n  <span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>();\n  <span class=\"keyword\">this</span>.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">response</span>)</span>{\n    promise.resolve(f(response));\n  });\n  <span class=\"keyword\">return</span> promise;\n}\n</code></pre>\n<p>再來一個和 html 合作的例子：對有和沒有 user_login 的情況下，更新歡迎頁面。 </p>\n<pre><code class=\"js\">$div = $(<span class=\"string\">\"#myDiv\"</span>);\n\n<span class=\"comment\">//dot 會把 user.name 拿出來</span>\n<span class=\"keyword\">var</span> getGreeting = compose(concat(<span class=\"string\">'Welcome '</span>), dot(<span class=\"string\">'name'</span>));\n\n<span class=\"keyword\">var</span> updateGreetingHtml = compose($div.html, getGreeting);\n\nmap(updateGreetingHtml, Maybe(App.current_user));\n</code></pre>\n<p>underscore 不讓人 extend map  總結 functor 能: </p>\n<ul>\n<li>改變函數的行為卻不用變動 open/closed principle </li>\n<li>不光只有 map, 還有 reduce &amp; compose *<br>直覺且非私人的 api </li>\n<li>free formulas </li>\n<li>動態型別安全/檢查 </li>\n</ul>\n<hr>\n<p>總結：underscore 能變得更加 functional。希望有更 functional 的 library</p>\n"},{"title":"Firebase：前端工程師的神兵利器","date":"2015-12-06T14:12:00.000Z","_content":"\nFirebase.com 像其他的「後端即服務」( Baas, backend as a service ) 一樣，不過他的 Tutorial 超簡單，你只要會用 node 的 npm 大概就夠了。\n\n[Firebase官方超簡短教學](https://www.firebase.com/docs/hosting/quickstart.html)，看了這個我就被吸引住了。\n\nReact 讓人解決 MVC 中的 View。Firebase 讓人不用建 server、遠端登入，只需要用 web user &nbsp;interface 就建出以 Json 為格式的即時資料庫、Rest Web API、One command deploy ( firebase deploy )、社交帳號的管理 ( Oauth 介面的 Facebook、Google、Twitter blah blah 的登入管理) ，還有靜態 CDN 資料發佈、Custom domain mapping ( 這個要花一點時間等 DNS Propagate )。\n\nFirebase.com 去年被 Google 買走、Parse.com 前年被 Facebook 買走、Apple 也推出了自家的 CloudKit，這些「後端即服務」的公司，讓你&nbsp;**<u>不用再管 Server &amp; 資料庫</u>**。你只需要有整理資料的能力 ( Structure Data ) 和前端設計的能力，就能當全端工程師了 :)\n\n各家都有基本的免費流量，一個月 100 GB ~ 2TB 都有，但一旦升級之後就會變很貴喔 要小心。簡單說，以後 Hackathon 不用找後端工程師了，也不要再傻傻的去 github 找看都看不懂的 Hackathon Starter Kit。\n\n---\n真心覺得，Startup 剛開始用 Baas 就好，省 Server 和後端工程師的錢。","source":"_posts/Firebase：前端工程師的神兵利器.md","raw":"---\ntitle: Firebase：前端工程師的神兵利器\ntags:\n  - baas\n  - backend\n  - firebase\n  - frontend\ndate: 2015-12-06 22:12:00\n---\n\nFirebase.com 像其他的「後端即服務」( Baas, backend as a service ) 一樣，不過他的 Tutorial 超簡單，你只要會用 node 的 npm 大概就夠了。\n\n[Firebase官方超簡短教學](https://www.firebase.com/docs/hosting/quickstart.html)，看了這個我就被吸引住了。\n\nReact 讓人解決 MVC 中的 View。Firebase 讓人不用建 server、遠端登入，只需要用 web user &nbsp;interface 就建出以 Json 為格式的即時資料庫、Rest Web API、One command deploy ( firebase deploy )、社交帳號的管理 ( Oauth 介面的 Facebook、Google、Twitter blah blah 的登入管理) ，還有靜態 CDN 資料發佈、Custom domain mapping ( 這個要花一點時間等 DNS Propagate )。\n\nFirebase.com 去年被 Google 買走、Parse.com 前年被 Facebook 買走、Apple 也推出了自家的 CloudKit，這些「後端即服務」的公司，讓你&nbsp;**<u>不用再管 Server &amp; 資料庫</u>**。你只需要有整理資料的能力 ( Structure Data ) 和前端設計的能力，就能當全端工程師了 :)\n\n各家都有基本的免費流量，一個月 100 GB ~ 2TB 都有，但一旦升級之後就會變很貴喔 要小心。簡單說，以後 Hackathon 不用找後端工程師了，也不要再傻傻的去 github 找看都看不懂的 Hackathon Starter Kit。\n\n---\n真心覺得，Startup 剛開始用 Baas 就好，省 Server 和後端工程師的錢。","slug":"Firebase：前端工程師的神兵利器","published":1,"updated":"2017-12-23T06:08:08.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjblkzck50003xq9kqdt8rlu5","content":"<p>Firebase.com 像其他的「後端即服務」( Baas, backend as a service ) 一樣，不過他的 Tutorial 超簡單，你只要會用 node 的 npm 大概就夠了。</p>\n<p><a href=\"https://www.firebase.com/docs/hosting/quickstart.html\" target=\"_blank\" rel=\"noopener\">Firebase官方超簡短教學</a>，看了這個我就被吸引住了。</p>\n<p>React 讓人解決 MVC 中的 View。Firebase 讓人不用建 server、遠端登入，只需要用 web user &nbsp;interface 就建出以 Json 為格式的即時資料庫、Rest Web API、One command deploy ( firebase deploy )、社交帳號的管理 ( Oauth 介面的 Facebook、Google、Twitter blah blah 的登入管理) ，還有靜態 CDN 資料發佈、Custom domain mapping ( 這個要花一點時間等 DNS Propagate )。</p>\n<p>Firebase.com 去年被 Google 買走、Parse.com 前年被 Facebook 買走、Apple 也推出了自家的 CloudKit，這些「後端即服務」的公司，讓你&nbsp;<strong><u>不用再管 Server &amp; 資料庫</u></strong>。你只需要有整理資料的能力 ( Structure Data ) 和前端設計的能力，就能當全端工程師了 :)</p>\n<p>各家都有基本的免費流量，一個月 100 GB ~ 2TB 都有，但一旦升級之後就會變很貴喔 要小心。簡單說，以後 Hackathon 不用找後端工程師了，也不要再傻傻的去 github 找看都看不懂的 Hackathon Starter Kit。</p>\n<hr>\n<p>真心覺得，Startup 剛開始用 Baas 就好，省 Server 和後端工程師的錢。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Firebase.com 像其他的「後端即服務」( Baas, backend as a service ) 一樣，不過他的 Tutorial 超簡單，你只要會用 node 的 npm 大概就夠了。</p>\n<p><a href=\"https://www.firebase.com/docs/hosting/quickstart.html\" target=\"_blank\" rel=\"noopener\">Firebase官方超簡短教學</a>，看了這個我就被吸引住了。</p>\n<p>React 讓人解決 MVC 中的 View。Firebase 讓人不用建 server、遠端登入，只需要用 web user &nbsp;interface 就建出以 Json 為格式的即時資料庫、Rest Web API、One command deploy ( firebase deploy )、社交帳號的管理 ( Oauth 介面的 Facebook、Google、Twitter blah blah 的登入管理) ，還有靜態 CDN 資料發佈、Custom domain mapping ( 這個要花一點時間等 DNS Propagate )。</p>\n<p>Firebase.com 去年被 Google 買走、Parse.com 前年被 Facebook 買走、Apple 也推出了自家的 CloudKit，這些「後端即服務」的公司，讓你&nbsp;<strong><u>不用再管 Server &amp; 資料庫</u></strong>。你只需要有整理資料的能力 ( Structure Data ) 和前端設計的能力，就能當全端工程師了 :)</p>\n<p>各家都有基本的免費流量，一個月 100 GB ~ 2TB 都有，但一旦升級之後就會變很貴喔 要小心。簡單說，以後 Hackathon 不用找後端工程師了，也不要再傻傻的去 github 找看都看不懂的 Hackathon Starter Kit。</p>\n<hr>\n<p>真心覺得，Startup 剛開始用 Baas 就好，省 Server 和後端工程師的錢。</p>\n"},{"title":"Javascript 中的函數式編程 (a talk @ ReactiveConf 2015)","date":"2015-11-08T13:12:00.000Z","_content":"\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">影片：[Functional Programming in Javascript By Daniel Steigerwald](https://www.youtube.com/watch?v=BfzjuhX4wJ0&amp;feature=youtu.be&amp;t=2h16m7s)&nbsp;</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Daniel 是 google 前員工、也是 https://github.com/este/este 這個 React + Redux + immutable.js Starter Kit 的作者，在 Github 上有 1800 顆星。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">我認為函數式編程 ( Functional Programming ) 將在明年成為主流。像在 C++11 和 Java 8 中已經開始有 lambda function。我接下來聊我已經用在 Production 的東西。我認為函數式編程已經在前端的世界已經被 React 引入。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span>**<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">什麼是函數式編程？</span>**\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">沒有什麼神秘的東西，到處都是純函式 ( Pure functions everywhere )、不可變的數值 ( Immutable values )、用組成而不用繼承 ( composition over inheritance )、紀錄代替類別 (records over classes)、處理好副作用 ( taming side-effects )。我覺得 functional programming 有點像是人工智慧，聽起來有點酷、有點奇怪，但當你了解了它以後，就只是無聊、很平常的寫程式而已。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">**為什麼要函數化 ( functional )？&nbsp;**</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">因為軟體正在吃掉這個世界，它必須要做到最好。函數式編程已經被證明，比較少臭蟲 ( less bugs)、較不複雜 ( less complexity )、程式碼更可讀 ( more readable code ) 和更好的效能 ( more performance )。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">**物件導向程式設計 ( OOP ) 有什麼問題？**</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">沒有問題，只是很難、常被誤用，而且有時是難以避免的。整個物件導向程式設計的模式 (paradigm) 是基於「送訊息給物件是唯一跟狀態 ( state ) 互動的方法」，因此狀態就會被分散。於是在分散式系統中狀態的一致的難度是跟世界和平一樣的 XD</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span>\n<table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"><tbody><tr><td style=\"text-align: center;\">[<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">![](http://2.bp.blogspot.com/-NqF8whIlX1E/Vj9BEosEl7I/AAAAAAAA35w/csXWLMH0e3w/s640/Screen%2BShot%2B2015-11-08%2Bat%2B8.32.45%2BPM.jpg)</span>](http://2.bp.blogspot.com/-NqF8whIlX1E/Vj9BEosEl7I/AAAAAAAA35w/csXWLMH0e3w/s1600/Screen%2BShot%2B2015-11-08%2Bat%2B8.32.45%2BPM.jpg)</td></tr><tr><td class=\"tr-caption\" style=\"text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">物件導向程式設計 和 函數式編程的設計模式比較</span></td></tr></tbody></table><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Scott Wlaschin是很好的講者，不像我鼓勵大家去聽他的演講。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">在 OOP 中，每次方法在某個實體上被呼叫其實就是副作用。副作用很難被追蹤、被理解，沒有人喜歡驚喜。驚喜在生活中是好的，但驚喜在程式碼裡面沒有任何好的地方。我們被教導要用繼承，但他是陷阱，程式碼會不夠彈性、很難之後改變。設計模式最難的是如何幫這些模式取名字，動詞偽裝成名詞。策略、工廠、Commands...</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">React 中最耀眼的原則是函式組成法 ( function composition )。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span>**<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">純函數 ( pure function ) vs 髒類別 (dirty class)</span>**\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">純函數沒有任何副作用。他很難去違反只負責一件事的原則 ( single responsibility principle) 因為純函數只有一個明顯的目的 --- 把輸入轉成輸出。所以測試就變得超簡單。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">類別是髒的。互叫一個簡單的類別函式，就會改變它。誰做的？為什麼做？我們永遠不知道 ( 直到我們 debug 後)...</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">推薦這本 github 上的書[適當的函數式編成指南](https://github.com/MostlyAdequate/mostly-adequate-guide)&nbsp;( 在 github 上有 6000 顆星)</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span>\n<table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"><tbody><tr><td style=\"text-align: center;\">[<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">![](http://4.bp.blogspot.com/-trYOXa5g8dY/Vj9HW1kBZYI/AAAAAAAA36A/XOIr5LVtpiI/s640/Screen%2BShot%2B2015-11-08%2Bat%2B8.59.38%2BPM.jpg)</span>](http://4.bp.blogspot.com/-trYOXa5g8dY/Vj9HW1kBZYI/AAAAAAAA36A/XOIr5LVtpiI/s1600/Screen%2BShot%2B2015-11-08%2Bat%2B8.59.38%2BPM.jpg)</td></tr><tr><td class=\"tr-caption\" style=\"text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">如果你不理解這個程式，沒關係。我也不懂。在函數式編程裡它等於 ( (4 + 0) * 2) + (4 * 2)</span></td></tr></tbody></table><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">**Immutable.js**</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">不可變資料一旦被建立就不能被改變，這使得更簡單的應用程式開發，不用預防性的回傳複製品，更可以使用間單的邏輯來達到進階的 memoization 和改變偵測。一個針對不變資料的可變 API 並不改變原來資料，而是總是產生新的資料。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp; &nbsp;- 和 原生的 Javascript array 有很相似的 API</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp; &nbsp;- 保持永遠的不可變 (List, stack, map, orderedMap, Set, OrderedSet and Record)</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp; &nbsp;- 非常快</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">---</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">PS：作者講的不多，上面很多都是照投影片上大量文字打的。</span>","source":"_posts/Javascript-中的函數式編程-a-talk-ReactiveConf-2015.md","raw":"---\ntitle: Javascript 中的函數式編程 (a talk @ ReactiveConf 2015)\ntags:\n  - functional programming\n  - pure function\ndate: 2015-11-08 21:12:00\n---\n\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">影片：[Functional Programming in Javascript By Daniel Steigerwald](https://www.youtube.com/watch?v=BfzjuhX4wJ0&amp;feature=youtu.be&amp;t=2h16m7s)&nbsp;</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Daniel 是 google 前員工、也是 https://github.com/este/este 這個 React + Redux + immutable.js Starter Kit 的作者，在 Github 上有 1800 顆星。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">我認為函數式編程 ( Functional Programming ) 將在明年成為主流。像在 C++11 和 Java 8 中已經開始有 lambda function。我接下來聊我已經用在 Production 的東西。我認為函數式編程已經在前端的世界已經被 React 引入。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span>**<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">什麼是函數式編程？</span>**\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">沒有什麼神秘的東西，到處都是純函式 ( Pure functions everywhere )、不可變的數值 ( Immutable values )、用組成而不用繼承 ( composition over inheritance )、紀錄代替類別 (records over classes)、處理好副作用 ( taming side-effects )。我覺得 functional programming 有點像是人工智慧，聽起來有點酷、有點奇怪，但當你了解了它以後，就只是無聊、很平常的寫程式而已。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">**為什麼要函數化 ( functional )？&nbsp;**</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">因為軟體正在吃掉這個世界，它必須要做到最好。函數式編程已經被證明，比較少臭蟲 ( less bugs)、較不複雜 ( less complexity )、程式碼更可讀 ( more readable code ) 和更好的效能 ( more performance )。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">**物件導向程式設計 ( OOP ) 有什麼問題？**</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">沒有問題，只是很難、常被誤用，而且有時是難以避免的。整個物件導向程式設計的模式 (paradigm) 是基於「送訊息給物件是唯一跟狀態 ( state ) 互動的方法」，因此狀態就會被分散。於是在分散式系統中狀態的一致的難度是跟世界和平一樣的 XD</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span>\n<table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"><tbody><tr><td style=\"text-align: center;\">[<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">![](http://2.bp.blogspot.com/-NqF8whIlX1E/Vj9BEosEl7I/AAAAAAAA35w/csXWLMH0e3w/s640/Screen%2BShot%2B2015-11-08%2Bat%2B8.32.45%2BPM.jpg)</span>](http://2.bp.blogspot.com/-NqF8whIlX1E/Vj9BEosEl7I/AAAAAAAA35w/csXWLMH0e3w/s1600/Screen%2BShot%2B2015-11-08%2Bat%2B8.32.45%2BPM.jpg)</td></tr><tr><td class=\"tr-caption\" style=\"text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">物件導向程式設計 和 函數式編程的設計模式比較</span></td></tr></tbody></table><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Scott Wlaschin是很好的講者，不像我鼓勵大家去聽他的演講。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">在 OOP 中，每次方法在某個實體上被呼叫其實就是副作用。副作用很難被追蹤、被理解，沒有人喜歡驚喜。驚喜在生活中是好的，但驚喜在程式碼裡面沒有任何好的地方。我們被教導要用繼承，但他是陷阱，程式碼會不夠彈性、很難之後改變。設計模式最難的是如何幫這些模式取名字，動詞偽裝成名詞。策略、工廠、Commands...</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">React 中最耀眼的原則是函式組成法 ( function composition )。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span>**<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">純函數 ( pure function ) vs 髒類別 (dirty class)</span>**\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">純函數沒有任何副作用。他很難去違反只負責一件事的原則 ( single responsibility principle) 因為純函數只有一個明顯的目的 --- 把輸入轉成輸出。所以測試就變得超簡單。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">類別是髒的。互叫一個簡單的類別函式，就會改變它。誰做的？為什麼做？我們永遠不知道 ( 直到我們 debug 後)...</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">推薦這本 github 上的書[適當的函數式編成指南](https://github.com/MostlyAdequate/mostly-adequate-guide)&nbsp;( 在 github 上有 6000 顆星)</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span>\n<table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"><tbody><tr><td style=\"text-align: center;\">[<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">![](http://4.bp.blogspot.com/-trYOXa5g8dY/Vj9HW1kBZYI/AAAAAAAA36A/XOIr5LVtpiI/s640/Screen%2BShot%2B2015-11-08%2Bat%2B8.59.38%2BPM.jpg)</span>](http://4.bp.blogspot.com/-trYOXa5g8dY/Vj9HW1kBZYI/AAAAAAAA36A/XOIr5LVtpiI/s1600/Screen%2BShot%2B2015-11-08%2Bat%2B8.59.38%2BPM.jpg)</td></tr><tr><td class=\"tr-caption\" style=\"text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">如果你不理解這個程式，沒關係。我也不懂。在函數式編程裡它等於 ( (4 + 0) * 2) + (4 * 2)</span></td></tr></tbody></table><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">**Immutable.js**</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">不可變資料一旦被建立就不能被改變，這使得更簡單的應用程式開發，不用預防性的回傳複製品，更可以使用間單的邏輯來達到進階的 memoization 和改變偵測。一個針對不變資料的可變 API 並不改變原來資料，而是總是產生新的資料。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp; &nbsp;- 和 原生的 Javascript array 有很相似的 API</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp; &nbsp;- 保持永遠的不可變 (List, stack, map, orderedMap, Set, OrderedSet and Record)</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp; &nbsp;- 非常快</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">---</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">PS：作者講的不多，上面很多都是照投影片上大量文字打的。</span>","slug":"Javascript-中的函數式編程-a-talk-ReactiveConf-2015","published":1,"updated":"2017-12-23T06:08:08.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjblkzck80004xq9kup27sh2j","content":"<p><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">影片：<a href=\"https://www.youtube.com/watch?v=BfzjuhX4wJ0&amp;feature=youtu.be&amp;t=2h16m7s\" target=\"_blank\" rel=\"noopener\">Functional Programming in Javascript By Daniel Steigerwald</a>&nbsp;</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Daniel 是 google 前員工、也是 <a href=\"https://github.com/este/este\" target=\"_blank\" rel=\"noopener\">https://github.com/este/este</a> 這個 React + Redux + immutable.js Starter Kit 的作者，在 Github 上有 1800 顆星。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">我認為函數式編程 ( Functional Programming ) 將在明年成為主流。像在 C++11 和 Java 8 中已經開始有 lambda function。我接下來聊我已經用在 Production 的東西。我認為函數式編程已經在前端的世界已經被 React 引入。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><strong><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">什麼是函數式編程？</span></strong><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">沒有什麼神秘的東西，到處都是純函式 ( Pure functions everywhere )、不可變的數值 ( Immutable values )、用組成而不用繼承 ( composition over inheritance )、紀錄代替類別 (records over classes)、處理好副作用 ( taming side-effects )。我覺得 functional programming 有點像是人工智慧，聽起來有點酷、有點奇怪，但當你了解了它以後，就只是無聊、很平常的寫程式而已。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><strong>為什麼要函數化 ( functional )？&nbsp;</strong></span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">因為軟體正在吃掉這個世界，它必須要做到最好。函數式編程已經被證明，比較少臭蟲 ( less bugs)、較不複雜 ( less complexity )、程式碼更可讀 ( more readable code ) 和更好的效能 ( more performance )。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><strong>物件導向程式設計 ( OOP ) 有什麼問題？</strong></span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">沒有問題，只是很難、常被誤用，而且有時是難以避免的。整個物件導向程式設計的模式 (paradigm) 是基於「送訊息給物件是唯一跟狀態 ( state ) 互動的方法」，因此狀態就會被分散。於是在分散式系統中狀態的一致的難度是跟世界和平一樣的 XD</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></p>\n<p><table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"><tbody><tr><td style=\"text-align: center;\"><a href=\"http://2.bp.blogspot.com/-NqF8whIlX1E/Vj9BEosEl7I/AAAAAAAA35w/csXWLMH0e3w/s1600/Screen%2BShot%2B2015-11-08%2Bat%2B8.32.45%2BPM.jpg\" target=\"_blank\" rel=\"noopener\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><img src=\"http://2.bp.blogspot.com/-NqF8whIlX1E/Vj9BEosEl7I/AAAAAAAA35w/csXWLMH0e3w/s640/Screen%2BShot%2B2015-11-08%2Bat%2B8.32.45%2BPM.jpg\" alt=\"\"></span></a></td></tr><tr><td class=\"tr-caption\" style=\"text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">物件導向程式設計 和 函數式編程的設計模式比較</span></td></tr></tbody></table><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Scott Wlaschin是很好的講者，不像我鼓勵大家去聽他的演講。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">在 OOP 中，每次方法在某個實體上被呼叫其實就是副作用。副作用很難被追蹤、被理解，沒有人喜歡驚喜。驚喜在生活中是好的，但驚喜在程式碼裡面沒有任何好的地方。我們被教導要用繼承，但他是陷阱，程式碼會不夠彈性、很難之後改變。設計模式最難的是如何幫這些模式取名字，動詞偽裝成名詞。策略、工廠、Commands…</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">React 中最耀眼的原則是函式組成法 ( function composition )。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><strong><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">純函數 ( pure function ) vs 髒類別 (dirty class)</span></strong><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">純函數沒有任何副作用。他很難去違反只負責一件事的原則 ( single responsibility principle) 因為純函數只有一個明顯的目的 — 把輸入轉成輸出。所以測試就變得超簡單。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">類別是髒的。互叫一個簡單的類別函式，就會改變它。誰做的？為什麼做？我們永遠不知道 ( 直到我們 debug 後)…</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">推薦這本 github 上的書<a href=\"https://github.com/MostlyAdequate/mostly-adequate-guide\" target=\"_blank\" rel=\"noopener\">適當的函數式編成指南</a>&nbsp;( 在 github 上有 6000 顆星)</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></p>\n<p><table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"><tbody><tr><td style=\"text-align: center;\"><a href=\"http://4.bp.blogspot.com/-trYOXa5g8dY/Vj9HW1kBZYI/AAAAAAAA36A/XOIr5LVtpiI/s1600/Screen%2BShot%2B2015-11-08%2Bat%2B8.59.38%2BPM.jpg\" target=\"_blank\" rel=\"noopener\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><img src=\"http://4.bp.blogspot.com/-trYOXa5g8dY/Vj9HW1kBZYI/AAAAAAAA36A/XOIr5LVtpiI/s640/Screen%2BShot%2B2015-11-08%2Bat%2B8.59.38%2BPM.jpg\" alt=\"\"></span></a></td></tr><tr><td class=\"tr-caption\" style=\"text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">如果你不理解這個程式，沒關係。我也不懂。在函數式編程裡它等於 ( (4 + 0) <em> 2) + (4 </em> 2)</span></td></tr></tbody></table><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><strong>Immutable.js</strong></span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">不可變資料一旦被建立就不能被改變，這使得更簡單的應用程式開發，不用預防性的回傳複製品，更可以使用間單的邏輯來達到進階的 memoization 和改變偵測。一個針對不變資料的可變 API 並不改變原來資料，而是總是產生新的資料。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp; &nbsp;- 和 原生的 Javascript array 有很相似的 API</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp; &nbsp;- 保持永遠的不可變 (List, stack, map, orderedMap, Set, OrderedSet and Record)</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp; &nbsp;- 非常快</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">—</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">PS：作者講的不多，上面很多都是照投影片上大量文字打的。</span></p>\n","site":{"data":{}},"excerpt":"","more":"<p><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">影片：<a href=\"https://www.youtube.com/watch?v=BfzjuhX4wJ0&amp;feature=youtu.be&amp;t=2h16m7s\" target=\"_blank\" rel=\"noopener\">Functional Programming in Javascript By Daniel Steigerwald</a>&nbsp;</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Daniel 是 google 前員工、也是 <a href=\"https://github.com/este/este\" target=\"_blank\" rel=\"noopener\">https://github.com/este/este</a> 這個 React + Redux + immutable.js Starter Kit 的作者，在 Github 上有 1800 顆星。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">我認為函數式編程 ( Functional Programming ) 將在明年成為主流。像在 C++11 和 Java 8 中已經開始有 lambda function。我接下來聊我已經用在 Production 的東西。我認為函數式編程已經在前端的世界已經被 React 引入。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><strong><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">什麼是函數式編程？</span></strong><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">沒有什麼神秘的東西，到處都是純函式 ( Pure functions everywhere )、不可變的數值 ( Immutable values )、用組成而不用繼承 ( composition over inheritance )、紀錄代替類別 (records over classes)、處理好副作用 ( taming side-effects )。我覺得 functional programming 有點像是人工智慧，聽起來有點酷、有點奇怪，但當你了解了它以後，就只是無聊、很平常的寫程式而已。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><strong>為什麼要函數化 ( functional )？&nbsp;</strong></span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">因為軟體正在吃掉這個世界，它必須要做到最好。函數式編程已經被證明，比較少臭蟲 ( less bugs)、較不複雜 ( less complexity )、程式碼更可讀 ( more readable code ) 和更好的效能 ( more performance )。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><strong>物件導向程式設計 ( OOP ) 有什麼問題？</strong></span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">沒有問題，只是很難、常被誤用，而且有時是難以避免的。整個物件導向程式設計的模式 (paradigm) 是基於「送訊息給物件是唯一跟狀態 ( state ) 互動的方法」，因此狀態就會被分散。於是在分散式系統中狀態的一致的難度是跟世界和平一樣的 XD</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></p>\n<p><table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"><tbody><tr><td style=\"text-align: center;\"><a href=\"http://2.bp.blogspot.com/-NqF8whIlX1E/Vj9BEosEl7I/AAAAAAAA35w/csXWLMH0e3w/s1600/Screen%2BShot%2B2015-11-08%2Bat%2B8.32.45%2BPM.jpg\" target=\"_blank\" rel=\"noopener\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><img src=\"http://2.bp.blogspot.com/-NqF8whIlX1E/Vj9BEosEl7I/AAAAAAAA35w/csXWLMH0e3w/s640/Screen%2BShot%2B2015-11-08%2Bat%2B8.32.45%2BPM.jpg\" alt=\"\"></span></a></td></tr><tr><td class=\"tr-caption\" style=\"text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">物件導向程式設計 和 函數式編程的設計模式比較</span></td></tr></tbody></table><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Scott Wlaschin是很好的講者，不像我鼓勵大家去聽他的演講。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">在 OOP 中，每次方法在某個實體上被呼叫其實就是副作用。副作用很難被追蹤、被理解，沒有人喜歡驚喜。驚喜在生活中是好的，但驚喜在程式碼裡面沒有任何好的地方。我們被教導要用繼承，但他是陷阱，程式碼會不夠彈性、很難之後改變。設計模式最難的是如何幫這些模式取名字，動詞偽裝成名詞。策略、工廠、Commands…</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">React 中最耀眼的原則是函式組成法 ( function composition )。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><strong><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">純函數 ( pure function ) vs 髒類別 (dirty class)</span></strong><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">純函數沒有任何副作用。他很難去違反只負責一件事的原則 ( single responsibility principle) 因為純函數只有一個明顯的目的 — 把輸入轉成輸出。所以測試就變得超簡單。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">類別是髒的。互叫一個簡單的類別函式，就會改變它。誰做的？為什麼做？我們永遠不知道 ( 直到我們 debug 後)…</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">推薦這本 github 上的書<a href=\"https://github.com/MostlyAdequate/mostly-adequate-guide\" target=\"_blank\" rel=\"noopener\">適當的函數式編成指南</a>&nbsp;( 在 github 上有 6000 顆星)</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></p>\n<p><table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"><tbody><tr><td style=\"text-align: center;\"><a href=\"http://4.bp.blogspot.com/-trYOXa5g8dY/Vj9HW1kBZYI/AAAAAAAA36A/XOIr5LVtpiI/s1600/Screen%2BShot%2B2015-11-08%2Bat%2B8.59.38%2BPM.jpg\" target=\"_blank\" rel=\"noopener\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><img src=\"http://4.bp.blogspot.com/-trYOXa5g8dY/Vj9HW1kBZYI/AAAAAAAA36A/XOIr5LVtpiI/s640/Screen%2BShot%2B2015-11-08%2Bat%2B8.59.38%2BPM.jpg\" alt=\"\"></span></a></td></tr><tr><td class=\"tr-caption\" style=\"text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">如果你不理解這個程式，沒關係。我也不懂。在函數式編程裡它等於 ( (4 + 0) <em> 2) + (4 </em> 2)</span></td></tr></tbody></table><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><strong>Immutable.js</strong></span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">不可變資料一旦被建立就不能被改變，這使得更簡單的應用程式開發，不用預防性的回傳複製品，更可以使用間單的邏輯來達到進階的 memoization 和改變偵測。一個針對不變資料的可變 API 並不改變原來資料，而是總是產生新的資料。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp; &nbsp;- 和 原生的 Javascript array 有很相似的 API</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp; &nbsp;- 保持永遠的不可變 (List, stack, map, orderedMap, Set, OrderedSet and Record)</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp; &nbsp;- 非常快</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">—</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">PS：作者講的不多，上面很多都是照投影片上大量文字打的。</span></p>\n"},{"title":"Node.js 的發明人 Ryan Dahl 在 Yahoo 介紹 Node.js (2010)","date":"2015-11-03T15:04:00.000Z","_content":"\n<div class=\"separator\" style=\"clear: both; text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><iframe allowfullscreen=\"\" class=\"YOUTUBE-iframe-video\" data-thumbnail-src=\"https://i.ytimg.com/vi/M-sc73Y-zQA/0.jpg\" frameborder=\"0\" height=\"266\" src=\"https://www.youtube.com/embed/M-sc73Y-zQA?feature=player_embedded\" width=\"320\"></iframe></span></div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Node.js主要專注在Performance。Node的特點是對I/O有特別的處理方式，特別快。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">在有100個client下，每次回應1MB的Benchmark</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">node &nbsp;822 reqs/secs</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">nginx 7xx reqs/secs</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">others &nbsp;1x reqs/secs</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">node用javascript寫，但居然跑的比純C寫的nginx還要快!!! nginx快的原因是它不用一個Process來接處理一個 client，而是用Event Loop。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">All about non-blocking I/O</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">non-blocking I/O: &nbsp; L1 / L2 / L3/Memory &lt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 250 cycles</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">blocking I/O: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;disk / network &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &gt; 41,000,000 cycles (ex: select .. from database)</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">應該用不同的方式來處理這兩種I/O，他們從根本上根本不一樣。L1 cache像是拉開抽屜拿東西，存取memory像是到樓下買個東西回來，但從硬碟上拿東西像是跳上飛機、飛到地球的另一邊再飛回來一樣。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">要用non-blocking I/O，就要全部的API Call都用non-blocking I/O，即時用了第三方的程式庫去存取資料庫，可能就變成blocking I/O了。要實現的方法有幾種，event loop、using callback function。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">database_query(\"select ...\", &nbsp;callback function); //應該這樣做</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">但是大部份的語言都不預設這種寫程式的方式，如果要達成這種功能，通常要花很大的心力，最後大部份程式員最多就做到多個執行緒，然用用一個執行緒去處理一個I/O Operation。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">但Javascript是個特別的例外，因為這語言從第一天就一直在處理瀏覽器的Event Loop，**callback function、anonymous function、Closure&nbsp;**是在平常也不過的方法了。Javascript的文化就是Event Programming。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Node.js 就是讓你單純只用Event、non-blocking的infrastructure來寫高度concurrent的程式。設計的目標是任何的function都不能直接存取I/O，一定要用callback的function來處理。其他特性還有專注在Low level、什麼都用串流、不強迫buffering、提供DNS/HTTP/TLS的內建支援。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">HTTP包含: Chunked encoding, Pipelined message, hanging message.</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Node的API要用client side JS Programmer熟悉的慣例，幾乎100% MIT/BSD Licensed。(唯一例外是openssl)</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">架構</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span>\nJavascript &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node standard library\n------------------------------------------------------------\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Node binding\nC &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -------------------------------------\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;V8 &nbsp; Thread pool &amp; event pool\n\n努力把使用者關在non-blocking的環境，用C語言當作屏障... XD\n\n**Node execution stack : only one stack**\n\n| load(index.html) &nbsp; &nbsp;|\n-------------------------\n| http_parse(1) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|\n-------------------------\n| socket_readable(1) |\n-------------------------\n| ev_loop &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|\n-------------------------\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| |\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;V\n\n| file_loaded() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |\n-------------------------\n| ev_loop &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|\n-------------------------\n\n然後是一大堆的小段程式範例。\n包含web server和 file system的non-blocking I/O.\n然後是2010年接下來的 Road Map。","source":"_posts/Node-js-的發明人-Ryan-Dahl-在-Yahoo-介紹-Node-js-2010.md","raw":"---\ntitle: Node.js 的發明人 Ryan Dahl 在 Yahoo 介紹 Node.js (2010)\ntags:\n  - node\n  - yahoo\ndate: 2015-11-03 23:04:00\n---\n\n<div class=\"separator\" style=\"clear: both; text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><iframe allowfullscreen=\"\" class=\"YOUTUBE-iframe-video\" data-thumbnail-src=\"https://i.ytimg.com/vi/M-sc73Y-zQA/0.jpg\" frameborder=\"0\" height=\"266\" src=\"https://www.youtube.com/embed/M-sc73Y-zQA?feature=player_embedded\" width=\"320\"></iframe></span></div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Node.js主要專注在Performance。Node的特點是對I/O有特別的處理方式，特別快。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">在有100個client下，每次回應1MB的Benchmark</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">node &nbsp;822 reqs/secs</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">nginx 7xx reqs/secs</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">others &nbsp;1x reqs/secs</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">node用javascript寫，但居然跑的比純C寫的nginx還要快!!! nginx快的原因是它不用一個Process來接處理一個 client，而是用Event Loop。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">All about non-blocking I/O</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">non-blocking I/O: &nbsp; L1 / L2 / L3/Memory &lt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 250 cycles</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">blocking I/O: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;disk / network &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &gt; 41,000,000 cycles (ex: select .. from database)</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">應該用不同的方式來處理這兩種I/O，他們從根本上根本不一樣。L1 cache像是拉開抽屜拿東西，存取memory像是到樓下買個東西回來，但從硬碟上拿東西像是跳上飛機、飛到地球的另一邊再飛回來一樣。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">要用non-blocking I/O，就要全部的API Call都用non-blocking I/O，即時用了第三方的程式庫去存取資料庫，可能就變成blocking I/O了。要實現的方法有幾種，event loop、using callback function。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">database_query(\"select ...\", &nbsp;callback function); //應該這樣做</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">但是大部份的語言都不預設這種寫程式的方式，如果要達成這種功能，通常要花很大的心力，最後大部份程式員最多就做到多個執行緒，然用用一個執行緒去處理一個I/O Operation。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">但Javascript是個特別的例外，因為這語言從第一天就一直在處理瀏覽器的Event Loop，**callback function、anonymous function、Closure&nbsp;**是在平常也不過的方法了。Javascript的文化就是Event Programming。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Node.js 就是讓你單純只用Event、non-blocking的infrastructure來寫高度concurrent的程式。設計的目標是任何的function都不能直接存取I/O，一定要用callback的function來處理。其他特性還有專注在Low level、什麼都用串流、不強迫buffering、提供DNS/HTTP/TLS的內建支援。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">HTTP包含: Chunked encoding, Pipelined message, hanging message.</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Node的API要用client side JS Programmer熟悉的慣例，幾乎100% MIT/BSD Licensed。(唯一例外是openssl)</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">架構</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span>\nJavascript &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node standard library\n------------------------------------------------------------\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Node binding\nC &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -------------------------------------\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;V8 &nbsp; Thread pool &amp; event pool\n\n努力把使用者關在non-blocking的環境，用C語言當作屏障... XD\n\n**Node execution stack : only one stack**\n\n| load(index.html) &nbsp; &nbsp;|\n-------------------------\n| http_parse(1) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|\n-------------------------\n| socket_readable(1) |\n-------------------------\n| ev_loop &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|\n-------------------------\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| |\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;V\n\n| file_loaded() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |\n-------------------------\n| ev_loop &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|\n-------------------------\n\n然後是一大堆的小段程式範例。\n包含web server和 file system的non-blocking I/O.\n然後是2010年接下來的 Road Map。","slug":"Node-js-的發明人-Ryan-Dahl-在-Yahoo-介紹-Node-js-2010","published":1,"updated":"2017-12-23T06:08:08.301Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjblkzckd0005xq9kbdrk6jkb","content":"<p><div class=\"separator\" style=\"clear: both; text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><iframe allowfullscreen class=\"YOUTUBE-iframe-video\" data-thumbnail-src=\"https://i.ytimg.com/vi/M-sc73Y-zQA/0.jpg\" frameborder=\"0\" height=\"266\" src=\"https://www.youtube.com/embed/M-sc73Y-zQA?feature=player_embedded\" width=\"320\"></iframe></span></div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Node.js主要專注在Performance。Node的特點是對I/O有特別的處理方式，特別快。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">在有100個client下，每次回應1MB的Benchmark</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">node &nbsp;822 reqs/secs</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">nginx 7xx reqs/secs</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">others &nbsp;1x reqs/secs</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">node用javascript寫，但居然跑的比純C寫的nginx還要快!!! nginx快的原因是它不用一個Process來接處理一個 client，而是用Event Loop。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">All about non-blocking I/O</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">non-blocking I/O: &nbsp; L1 / L2 / L3/Memory &lt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 250 cycles</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">blocking I/O: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;disk / network &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &gt; 41,000,000 cycles (ex: select .. from database)</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">應該用不同的方式來處理這兩種I/O，他們從根本上根本不一樣。L1 cache像是拉開抽屜拿東西，存取memory像是到樓下買個東西回來，但從硬碟上拿東西像是跳上飛機、飛到地球的另一邊再飛回來一樣。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">要用non-blocking I/O，就要全部的API Call都用non-blocking I/O，即時用了第三方的程式庫去存取資料庫，可能就變成blocking I/O了。要實現的方法有幾種，event loop、using callback function。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">database_query(“select …”, &nbsp;callback function); //應該這樣做</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">但是大部份的語言都不預設這種寫程式的方式，如果要達成這種功能，通常要花很大的心力，最後大部份程式員最多就做到多個執行緒，然用用一個執行緒去處理一個I/O Operation。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">但Javascript是個特別的例外，因為這語言從第一天就一直在處理瀏覽器的Event Loop，<strong>callback function、anonymous function、Closure&nbsp;</strong>是在平常也不過的方法了。Javascript的文化就是Event Programming。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Node.js 就是讓你單純只用Event、non-blocking的infrastructure來寫高度concurrent的程式。設計的目標是任何的function都不能直接存取I/O，一定要用callback的function來處理。其他特性還有專注在Low level、什麼都用串流、不強迫buffering、提供DNS/HTTP/TLS的內建支援。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">HTTP包含: Chunked encoding, Pipelined message, hanging message.</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Node的API要用client side JS Programmer熟悉的慣例，幾乎100% MIT/BSD Licensed。(唯一例外是openssl)</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">架構</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></p>\n<h2 id=\"Javascript-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-Node-standard-library\"><a href=\"#Javascript-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-Node-standard-library\" class=\"headerlink\" title=\"Javascript &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node standard library\"></a>Javascript &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node standard library</h2><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Node binding<br>C &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ————————————-<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;V8 &nbsp; Thread pool &amp; event pool</p>\n<p>努力把使用者關在non-blocking的環境，用C語言當作屏障… XD</p>\n<p><strong>Node execution stack : only one stack</strong></p>\n<h2 id=\"load-index-html-nbsp-nbsp\"><a href=\"#load-index-html-nbsp-nbsp\" class=\"headerlink\" title=\"| load(index.html) &nbsp; &nbsp;|\"></a>| load(index.html) &nbsp; &nbsp;|</h2><h2 id=\"http-parse-1-nbsp-nbsp-nbsp-nbsp-nbsp\"><a href=\"#http-parse-1-nbsp-nbsp-nbsp-nbsp-nbsp\" class=\"headerlink\" title=\"| http_parse(1) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|\"></a>| http_parse(1) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|</h2><h2 id=\"socket-readable-1\"><a href=\"#socket-readable-1\" class=\"headerlink\" title=\"| socket_readable(1) |\"></a>| socket_readable(1) |</h2><h2 id=\"ev-loop-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp\"><a href=\"#ev-loop-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp\" class=\"headerlink\" title=\"| ev_loop &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|\"></a>| ev_loop &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|</h2><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| |<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;V</p>\n<h2 id=\"file-loaded-nbsp-nbsp-nbsp-nbsp-nbsp\"><a href=\"#file-loaded-nbsp-nbsp-nbsp-nbsp-nbsp\" class=\"headerlink\" title=\"| file_loaded() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |\"></a>| file_loaded() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |</h2><h2 id=\"ev-loop-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-1\"><a href=\"#ev-loop-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-1\" class=\"headerlink\" title=\"| ev_loop &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|\"></a>| ev_loop &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|</h2><p>然後是一大堆的小段程式範例。<br>包含web server和 file system的non-blocking I/O.<br>然後是2010年接下來的 Road Map。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><div class=\"separator\" style=\"clear: both; text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><iframe allowfullscreen class=\"YOUTUBE-iframe-video\" data-thumbnail-src=\"https://i.ytimg.com/vi/M-sc73Y-zQA/0.jpg\" frameborder=\"0\" height=\"266\" src=\"https://www.youtube.com/embed/M-sc73Y-zQA?feature=player_embedded\" width=\"320\"></iframe></span></div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Node.js主要專注在Performance。Node的特點是對I/O有特別的處理方式，特別快。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">在有100個client下，每次回應1MB的Benchmark</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">node &nbsp;822 reqs/secs</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">nginx 7xx reqs/secs</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">others &nbsp;1x reqs/secs</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">node用javascript寫，但居然跑的比純C寫的nginx還要快!!! nginx快的原因是它不用一個Process來接處理一個 client，而是用Event Loop。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">All about non-blocking I/O</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">non-blocking I/O: &nbsp; L1 / L2 / L3/Memory &lt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 250 cycles</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">blocking I/O: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;disk / network &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &gt; 41,000,000 cycles (ex: select .. from database)</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">應該用不同的方式來處理這兩種I/O，他們從根本上根本不一樣。L1 cache像是拉開抽屜拿東西，存取memory像是到樓下買個東西回來，但從硬碟上拿東西像是跳上飛機、飛到地球的另一邊再飛回來一樣。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">要用non-blocking I/O，就要全部的API Call都用non-blocking I/O，即時用了第三方的程式庫去存取資料庫，可能就變成blocking I/O了。要實現的方法有幾種，event loop、using callback function。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">database_query(“select …”, &nbsp;callback function); //應該這樣做</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">但是大部份的語言都不預設這種寫程式的方式，如果要達成這種功能，通常要花很大的心力，最後大部份程式員最多就做到多個執行緒，然用用一個執行緒去處理一個I/O Operation。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">但Javascript是個特別的例外，因為這語言從第一天就一直在處理瀏覽器的Event Loop，<strong>callback function、anonymous function、Closure&nbsp;</strong>是在平常也不過的方法了。Javascript的文化就是Event Programming。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Node.js 就是讓你單純只用Event、non-blocking的infrastructure來寫高度concurrent的程式。設計的目標是任何的function都不能直接存取I/O，一定要用callback的function來處理。其他特性還有專注在Low level、什麼都用串流、不強迫buffering、提供DNS/HTTP/TLS的內建支援。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">HTTP包含: Chunked encoding, Pipelined message, hanging message.</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Node的API要用client side JS Programmer熟悉的慣例，幾乎100% MIT/BSD Licensed。(唯一例外是openssl)</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">架構</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></p>\n<h2 id=\"Javascript-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-Node-standard-library\"><a href=\"#Javascript-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-Node-standard-library\" class=\"headerlink\" title=\"Javascript &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node standard library\"></a>Javascript &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node standard library</h2><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Node binding<br>C &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ————————————-<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;V8 &nbsp; Thread pool &amp; event pool</p>\n<p>努力把使用者關在non-blocking的環境，用C語言當作屏障… XD</p>\n<p><strong>Node execution stack : only one stack</strong></p>\n<h2 id=\"load-index-html-nbsp-nbsp\"><a href=\"#load-index-html-nbsp-nbsp\" class=\"headerlink\" title=\"| load(index.html) &nbsp; &nbsp;|\"></a>| load(index.html) &nbsp; &nbsp;|</h2><h2 id=\"http-parse-1-nbsp-nbsp-nbsp-nbsp-nbsp\"><a href=\"#http-parse-1-nbsp-nbsp-nbsp-nbsp-nbsp\" class=\"headerlink\" title=\"| http_parse(1) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|\"></a>| http_parse(1) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|</h2><h2 id=\"socket-readable-1\"><a href=\"#socket-readable-1\" class=\"headerlink\" title=\"| socket_readable(1) |\"></a>| socket_readable(1) |</h2><h2 id=\"ev-loop-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp\"><a href=\"#ev-loop-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp\" class=\"headerlink\" title=\"| ev_loop &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|\"></a>| ev_loop &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|</h2><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| |<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;V</p>\n<h2 id=\"file-loaded-nbsp-nbsp-nbsp-nbsp-nbsp\"><a href=\"#file-loaded-nbsp-nbsp-nbsp-nbsp-nbsp\" class=\"headerlink\" title=\"| file_loaded() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |\"></a>| file_loaded() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |</h2><h2 id=\"ev-loop-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-1\"><a href=\"#ev-loop-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-1\" class=\"headerlink\" title=\"| ev_loop &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|\"></a>| ev_loop &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|</h2><p>然後是一大堆的小段程式範例。<br>包含web server和 file system的non-blocking I/O.<br>然後是2010年接下來的 Road Map。</p>\n"},{"title":"React UI 心得文之一","date":"2015-12-01T18:07:00.000Z","_content":"\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">這週在忙著刻一個大元件，中間有包兩三個中元件、然後中元件下面又會有小元件。要記得React 是負責 UI 的啊，千萬個不該在小元件裡面存 state。存了改了兩天還是會有問題，小元件如果存了狀態，常會有那大元件重 render 的時候，設 property 卻無法更新小元件，因為小元件的 state 不一樣了。兩天之後把大中小元件全部改成 dumb component 真的快樂的不得了，程式碼變少了、邏輯也清楚了。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">刻 React 元件的方法：</span></span>\n\n1.  <span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">盡量刻 Dumb Component，把它當成 function 去想要提供什麼參數</span>\n2.  <span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">parent component 要對 child componet 命名和設 handler(childId, value)</span>\n3.  <span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">事件發生時就呼叫 parent 傳來的 handler，說你是哪個 child和發生了什麼</span><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">就這樣遞迴做下去，最上層的 App component 就可以知道，哪第三個child component 的第四個 child component 發生了什麼事，然後做一些處理。</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">客制化 React 元件外觀的方法：</span></div><div>\n\n1.  <span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">幫元件的各種 property 類別放置對應的className</span>\n2.  <span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">用 webpack 的 css loader 幫元件建立 local 的 css scope，然後用一個 scss 檔去管理一個元件，這樣一切都會輕鬆的多。( 參考 React Toolbox )</span><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">其他刻外觀小心得：</span></div>\n\n1.  <span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">多用 em, rem</span>\n2.  <span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">用 css 幫背景上色的方式，快速看物件是否對齊</span>\n3.  <span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">用 Mac 的放大鏡 ( ctrl + 雙指滑動 trackpad )</span>\n4.  <span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">用 css trick cursor 去引導 behavior</span>\n5.  <span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">用 font-weight 和 color 的 alpha channel 去做細部微調</span><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">學各種 React 相關 Library的方法：一定要**<span style=\"font-size: x-large;\"><u>從看完官方的 Tutorial/Guide 開始</u></span>**，網路上的介紹文章通常都挑簡單的地方說，十篇有九篇都講一樣的東西，還不如看官方的 Tutorial/Guide 把重要的東西有系統的一次學會。很重要所以特別粗體一下...</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">使用者經驗部分：</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">碰到客戶想要重新客製化系統的時候</span></div><div>\n\n1.  <span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">照他們舊有的行為，模擬跑自己刻的新系統幾次，很快就可以知道缺了什麼、哪裡會生出問題，這樣的方法比在那邊天馬行空的猜測會方便的很多。例子: 新報表系統拿舊系統的許多報表重新打一次。</span>\n2.  <span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">用心智圖的方式窮舉可能的行為，不然光是用腦袋想一定會漏掉很多細節。</span><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">和他人合作的部分</span></div></div></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">一定要定時 Sync 進度，時常 commit。不要隱匿進度落後、缺失、維護 local state，想說這樣可以加班追回來。因為很多事從他人的角度來看會清楚的很多，也方便別人調整。不要裝弱、裝強，快放棄那沒用的自尊心吧。</span></div>","source":"_posts/React-UI-心得文之一.md","raw":"---\ntitle: React UI 心得文之一\ntags:\n  - react\ndate: 2015-12-02 02:07:00\n---\n\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">這週在忙著刻一個大元件，中間有包兩三個中元件、然後中元件下面又會有小元件。要記得React 是負責 UI 的啊，千萬個不該在小元件裡面存 state。存了改了兩天還是會有問題，小元件如果存了狀態，常會有那大元件重 render 的時候，設 property 卻無法更新小元件，因為小元件的 state 不一樣了。兩天之後把大中小元件全部改成 dumb component 真的快樂的不得了，程式碼變少了、邏輯也清楚了。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">刻 React 元件的方法：</span></span>\n\n1.  <span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">盡量刻 Dumb Component，把它當成 function 去想要提供什麼參數</span>\n2.  <span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">parent component 要對 child componet 命名和設 handler(childId, value)</span>\n3.  <span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">事件發生時就呼叫 parent 傳來的 handler，說你是哪個 child和發生了什麼</span><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">就這樣遞迴做下去，最上層的 App component 就可以知道，哪第三個child component 的第四個 child component 發生了什麼事，然後做一些處理。</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">客制化 React 元件外觀的方法：</span></div><div>\n\n1.  <span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">幫元件的各種 property 類別放置對應的className</span>\n2.  <span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">用 webpack 的 css loader 幫元件建立 local 的 css scope，然後用一個 scss 檔去管理一個元件，這樣一切都會輕鬆的多。( 參考 React Toolbox )</span><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">其他刻外觀小心得：</span></div>\n\n1.  <span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">多用 em, rem</span>\n2.  <span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">用 css 幫背景上色的方式，快速看物件是否對齊</span>\n3.  <span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">用 Mac 的放大鏡 ( ctrl + 雙指滑動 trackpad )</span>\n4.  <span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">用 css trick cursor 去引導 behavior</span>\n5.  <span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">用 font-weight 和 color 的 alpha channel 去做細部微調</span><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">學各種 React 相關 Library的方法：一定要**<span style=\"font-size: x-large;\"><u>從看完官方的 Tutorial/Guide 開始</u></span>**，網路上的介紹文章通常都挑簡單的地方說，十篇有九篇都講一樣的東西，還不如看官方的 Tutorial/Guide 把重要的東西有系統的一次學會。很重要所以特別粗體一下...</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">使用者經驗部分：</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">碰到客戶想要重新客製化系統的時候</span></div><div>\n\n1.  <span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">照他們舊有的行為，模擬跑自己刻的新系統幾次，很快就可以知道缺了什麼、哪裡會生出問題，這樣的方法比在那邊天馬行空的猜測會方便的很多。例子: 新報表系統拿舊系統的許多報表重新打一次。</span>\n2.  <span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">用心智圖的方式窮舉可能的行為，不然光是用腦袋想一定會漏掉很多細節。</span><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">和他人合作的部分</span></div></div></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">一定要定時 Sync 進度，時常 commit。不要隱匿進度落後、缺失、維護 local state，想說這樣可以加班追回來。因為很多事從他人的角度來看會清楚的很多，也方便別人調整。不要裝弱、裝強，快放棄那沒用的自尊心吧。</span></div>","slug":"React-UI-心得文之一","published":1,"updated":"2017-12-23T06:08:08.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjblkzckg0007xq9kubu23iom","content":"<p><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">這週在忙著刻一個大元件，中間有包兩三個中元件、然後中元件下面又會有小元件。要記得React 是負責 UI 的啊，千萬個不該在小元件裡面存 state。存了改了兩天還是會有問題，小元件如果存了狀態，常會有那大元件重 render 的時候，設 property 卻無法更新小元件，因為小元件的 state 不一樣了。兩天之後把大中小元件全部改成 dumb component 真的快樂的不得了，程式碼變少了、邏輯也清楚了。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">刻 React 元件的方法：</span></span></p>\n<ol>\n<li><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">盡量刻 Dumb Component，把它當成 function 去想要提供什麼參數</span></li>\n<li><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">parent component 要對 child componet 命名和設 handler(childId, value)</span></li>\n<li><p><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">事件發生時就呼叫 parent 傳來的 handler，說你是哪個 child和發生了什麼</span><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">就這樣遞迴做下去，最上層的 App component 就可以知道，哪第三個child component 的第四個 child component 發生了什麼事，然後做一些處理。</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">客制化 React 元件外觀的方法：</span></div><div></div></p>\n</li>\n<li><p><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">幫元件的各種 property 類別放置對應的className</span></p>\n</li>\n<li><p><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">用 webpack 的 css loader 幫元件建立 local 的 css scope，然後用一個 scss 檔去管理一個元件，這樣一切都會輕鬆的多。( 參考 React Toolbox )</span><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">其他刻外觀小心得：</span></div></p>\n</li>\n<li><p><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">多用 em, rem</span></p>\n</li>\n<li><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">用 css 幫背景上色的方式，快速看物件是否對齊</span></li>\n<li><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">用 Mac 的放大鏡 ( ctrl + 雙指滑動 trackpad )</span></li>\n<li><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">用 css trick cursor 去引導 behavior</span></li>\n<li><p><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">用 font-weight 和 color 的 alpha channel 去做細部微調</span><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">學各種 React 相關 Library的方法：一定要<strong><span style=\"font-size: x-large;\"><u>從看完官方的 Tutorial/Guide 開始</u></span></strong>，網路上的介紹文章通常都挑簡單的地方說，十篇有九篇都講一樣的東西，還不如看官方的 Tutorial/Guide 把重要的東西有系統的一次學會。很重要所以特別粗體一下…</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">使用者經驗部分：</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">碰到客戶想要重新客製化系統的時候</span></div><div></div></p>\n</li>\n<li><p><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">照他們舊有的行為，模擬跑自己刻的新系統幾次，很快就可以知道缺了什麼、哪裡會生出問題，這樣的方法比在那邊天馬行空的猜測會方便的很多。例子: 新報表系統拿舊系統的許多報表重新打一次。</span></p>\n</li>\n<li><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">用心智圖的方式窮舉可能的行為，不然光是用腦袋想一定會漏掉很多細節。</span><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">和他人合作的部分</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">一定要定時 Sync 進度，時常 commit。不要隱匿進度落後、缺失、維護 local state，想說這樣可以加班追回來。因為很多事從他人的角度來看會清楚的很多，也方便別人調整。不要裝弱、裝強，快放棄那沒用的自尊心吧。</span></div></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">這週在忙著刻一個大元件，中間有包兩三個中元件、然後中元件下面又會有小元件。要記得React 是負責 UI 的啊，千萬個不該在小元件裡面存 state。存了改了兩天還是會有問題，小元件如果存了狀態，常會有那大元件重 render 的時候，設 property 卻無法更新小元件，因為小元件的 state 不一樣了。兩天之後把大中小元件全部改成 dumb component 真的快樂的不得了，程式碼變少了、邏輯也清楚了。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">刻 React 元件的方法：</span></span></p>\n<ol>\n<li><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">盡量刻 Dumb Component，把它當成 function 去想要提供什麼參數</span></li>\n<li><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">parent component 要對 child componet 命名和設 handler(childId, value)</span></li>\n<li><p><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">事件發生時就呼叫 parent 傳來的 handler，說你是哪個 child和發生了什麼</span><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">就這樣遞迴做下去，最上層的 App component 就可以知道，哪第三個child component 的第四個 child component 發生了什麼事，然後做一些處理。</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">客制化 React 元件外觀的方法：</span></div><div></div></p>\n</li>\n<li><p><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">幫元件的各種 property 類別放置對應的className</span></p>\n</li>\n<li><p><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">用 webpack 的 css loader 幫元件建立 local 的 css scope，然後用一個 scss 檔去管理一個元件，這樣一切都會輕鬆的多。( 參考 React Toolbox )</span><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">其他刻外觀小心得：</span></div></p>\n</li>\n<li><p><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">多用 em, rem</span></p>\n</li>\n<li><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">用 css 幫背景上色的方式，快速看物件是否對齊</span></li>\n<li><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">用 Mac 的放大鏡 ( ctrl + 雙指滑動 trackpad )</span></li>\n<li><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">用 css trick cursor 去引導 behavior</span></li>\n<li><p><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">用 font-weight 和 color 的 alpha channel 去做細部微調</span><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">學各種 React 相關 Library的方法：一定要<strong><span style=\"font-size: x-large;\"><u>從看完官方的 Tutorial/Guide 開始</u></span></strong>，網路上的介紹文章通常都挑簡單的地方說，十篇有九篇都講一樣的東西，還不如看官方的 Tutorial/Guide 把重要的東西有系統的一次學會。很重要所以特別粗體一下…</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">使用者經驗部分：</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">碰到客戶想要重新客製化系統的時候</span></div><div></div></p>\n</li>\n<li><p><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">照他們舊有的行為，模擬跑自己刻的新系統幾次，很快就可以知道缺了什麼、哪裡會生出問題，這樣的方法比在那邊天馬行空的猜測會方便的很多。例子: 新報表系統拿舊系統的許多報表重新打一次。</span></p>\n</li>\n<li><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">用心智圖的方式窮舉可能的行為，不然光是用腦袋想一定會漏掉很多細節。</span><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">和他人合作的部分</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">一定要定時 Sync 進度，時常 commit。不要隱匿進度落後、缺失、維護 local state，想說這樣可以加班追回來。因為很多事從他人的角度來看會清楚的很多，也方便別人調整。不要裝弱、裝強，快放棄那沒用的自尊心吧。</span></div></li>\n</ol>\n"},{"title":"React 和 Flux 到底在做什麼?","date":"2015-11-05T15:52:00.000Z","_content":"\n看了下面兩個文章，終於知道 React 和 Flux 在做什麼了。\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">1.&nbsp;[ReactJS For Stupid People](http://blog.andrewray.me/reactjs-for-stupid-people/)</span>\n2.&nbsp;[Flux For Stupid People](http://blog.andrewray.me/flux-for-stupid-people/)\n\n以下開始和主題不很相關的廢話，可以直接跳到最後一段「好啦，說了一大堆廢話。」\n\n前兩天一直迷惑，到底這套新的 UI 開發流程和我過去接觸過的 framework 們有什麼不同？以前用過 Java AWT, JAVA SWING, ZK Markup Language, JQuery UI, iOS UI Kit, Android, QT Component, OpenGL, xxxRendering Engine ... 列出來才發現，真的是有的沒的一大堆。\n\n在螢幕上生出畫面大概可以分成三群：\n1\\. 網頁開發\n2\\. 桌上 / 手機的原生應用程式\n3\\. 遊戲 / 動畫\n\n3) 寫遊戲和動畫的流程最簡單，大二用組語刻了魔法氣泡遊戲 / 大三參加趨勢比賽徒手硬幹JAVA Swing ( 真的超慢的 T.T ) / 研究所用 3DS Max 和 Blender 做動畫 / 工作上用 OpenGL 做了動態路徑規劃的資料展示。這一類大概每次就是重畫，隨時檢查物件狀態一直重畫。看一下 FPS 有到 Real-Time 就好。\n\n2) 開發原生應用程式的流程就是用原生的物件，不管太元件長什麼樣子，反正就是設計互動，註冊事件，最多就小改一下背景、顏色之類的。反正最差就是比較醜，功能都沒問題啊。話說 MFC 到底是什麼鬼東西啊... 記得花了兩三天從來沒搞懂過。\n\n1) 網頁開發不像開發原生應用程式，有功能性較大完整的原生元件。只有一堆小到不行的 HTML 元件。然後問題就來了... 網頁上一塊塊重複的物件，像是 部落格、購物網站、討論區上面一個個的模組要怎麼搞。\n\n如果是靜態的網頁，就背後用 php 弄個模組 ( 喔 交作業而已別太嚴格啦 )，Header 一個Template、商品一個 Template、側邊欄一個 Template、導覽列一個 Template，然後就很開心地從資料庫抓一些資料填進去Template就好啦。有什麼事件發生就傳資料到伺服器端，整個重新畫頁面就好。老實說還挺簡單的，怎麼流程聽起來很像ReactJS。但是 2004 年，總是有一些天才們發明了一些讓人很累的東西叫做 Ajax 把 Gmail 推上了時代尖端。Ajax 告訴所有開發者：「喔 什麼!!! 你把使用者輸入送到伺服器再傳回來，然後才更新 UI，太慢了喔 弱~」。然後從這時候開始，網頁設計師就很苦情的開始在客戶端開始亂刻元件，MVC 邏輯的重擔就移交給 HTML、CSS、Javascript。但主流的開法方式是，不管 MVC 也行啦，反正網頁會動看起來有設計感就好。\n\nJQuery Library 在這亂世中應運而生，讓我苦讀 vanilla Javascript 的經典「ppk談Javascript」變得英雄無用武之地，JQuery 的 selector 就像用 matlab 來處理資料的有快感、dot chain rule 讓語法看起來糖分很高、不用打 getElementById 就像 C++11 中用 STL 不用打 Iterator 一樣清爽。可以快速開發出很難維護的網頁。解決了 Javascript 操作 DOM 會讓人想罵髒話的問題。為什麼很難維護，因為沒有元件化，Javascript有很有力量，讓人在網頁裡隨性的的東改西改，但不知道誰改的就很難 Debug，漸漸變得複雜就不能開發大型網頁。\n\n然後 AngularJS 把後端流行的 資料綁定搬到瀏覽器來，用 Javascript 的 Closure 來做封裝、一區區的資料分別藏起來，限制一部分 Javascript 只能操作 一部分的資料和 HTML，充分發揮了各個擊破的演算法 ( Divide and Conquer )，可是問題又來了... 媽的我花了兩天，學不會 AngularJS 啊一直 Typos 很煩，雙向綁定怎麼那麼複雜，讓我寫程式一直 NG NG。所以我沒太多研究，只聽說是雙向資料綁定會引起 DOM Tree 的 Cacading Update，導致效能容易有問題。另外 HTML 裡塞了太多髒髒的東西，容易消化不良。\n\n### **<u>好啦，說了一大堆廢話，React 和 Flux 到底做了什麼？</u>**\nReact 讓人用 Javascript 和 HTML 刻更高級的元件 ( Virtual DOM )，像是 Angular 元件做的限制 讓一小段 Javascript只負責一小塊的UI / HTML更新，使用各個擊破的演算法，刻完元件之後就像開發原生應用程式時一樣，有了較大的元件，讓人跳脫低級 ( low level ) 的思考，少說一點髒話，透過 JSX 讓人從模組化的角度看 UI。簡單的譬喻就是讓人用組語開發高階語言的語法，之後可以用高階語言寫程式。\n\nReact 只 Update 新的 DOM Tree 中和前一次 DOM Tree 差異之處，他們管這叫 一致 (reconciliation) 讓重繪的速度快很多，當重繪夠快，網頁的開發者就可以回到 pre-AJAX時代，回憶2004年之前的寫開發體驗：把資料送回伺服器，然後收到新資料，整個網頁重繪。\n\n只是這回，資料來源的不是 Database，是 <u>Flux 資料集中管理辦法</u>中的各個 Store ( Client-side Database )。Flux的單向資料流理念，強迫你在客戶端有一個像資料庫的資料集中處，Store裡有來自使用者輸入的資料、有來自伺服器端的資料更新。然後這個資料商店把每一家元件訂閱的資料送上門，元件看了看送來的資料商品然後就更新。Store 像是介於 CPU 和 硬碟中間的 Cache / Memory，是資料的 暫存處和Hub，或是你叫它客戶端的暫存資料庫也行 ( 用 Javascript 物件存的 )。\n\n原來：\nBrowser -- Client Side ......................................... Server\n\n有了 React + Flux 之後 :\nBrowser -- Client Side -- Client Side VM + Server ( React + Flux ) .......................................... Server\n\n有點像是在 Client Side 包了一層 VM + Server 一樣，會把 JSX 轉譯成JS / HTML、集中把資料放在客戶端資料庫裡 ( Flux 的 Store )。\n\n簡單總結一下：\nReact + Flux 是大規模動態資料網頁的解法。\n\nReact 讓需要大型互動元件的客戶端，可以用自己刻的、封裝良好的元件，並在新元件的高度思考。用了個 Reconciliation 的 Trick使得重繪很快，和 <u>Flux 的資料集中管理辦法</u>，讓開發者只要專注做好一件事「當資料來到元件時，把元件要畫好」。\n\n---\nFlux 目的是提出一個客戶端的資料管理辦法。其中的單向資料流 / 資料環其實隱含了 Two way Data Binding，只是不是綁死，比較像是 Two way Data Notification。Dispatcher 管的是 <span style=\"color: blue;\">View Actions -&gt; Store ( Models )</span>。Store 除了存資料外還包含了 <span style=\"color: blue;\">Store ( Models ) -&gt; View&nbsp;</span>的通知。還有人覺得 Dispatcher 很多餘，就寫了一個 reflux.js 把 Dispatcher 拿掉。\n\n延伸閱讀：\n[聊一聊基於Flux的前端系統](http://bbs.react-china.org/t/flux/615)","source":"_posts/React-和-Flux-到底在做什麼.md","raw":"---\ntitle: React 和 Flux 到底在做什麼?\ntags:\n  - flux\n  - react\ndate: 2015-11-05 23:52:00\n---\n\n看了下面兩個文章，終於知道 React 和 Flux 在做什麼了。\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">1.&nbsp;[ReactJS For Stupid People](http://blog.andrewray.me/reactjs-for-stupid-people/)</span>\n2.&nbsp;[Flux For Stupid People](http://blog.andrewray.me/flux-for-stupid-people/)\n\n以下開始和主題不很相關的廢話，可以直接跳到最後一段「好啦，說了一大堆廢話。」\n\n前兩天一直迷惑，到底這套新的 UI 開發流程和我過去接觸過的 framework 們有什麼不同？以前用過 Java AWT, JAVA SWING, ZK Markup Language, JQuery UI, iOS UI Kit, Android, QT Component, OpenGL, xxxRendering Engine ... 列出來才發現，真的是有的沒的一大堆。\n\n在螢幕上生出畫面大概可以分成三群：\n1\\. 網頁開發\n2\\. 桌上 / 手機的原生應用程式\n3\\. 遊戲 / 動畫\n\n3) 寫遊戲和動畫的流程最簡單，大二用組語刻了魔法氣泡遊戲 / 大三參加趨勢比賽徒手硬幹JAVA Swing ( 真的超慢的 T.T ) / 研究所用 3DS Max 和 Blender 做動畫 / 工作上用 OpenGL 做了動態路徑規劃的資料展示。這一類大概每次就是重畫，隨時檢查物件狀態一直重畫。看一下 FPS 有到 Real-Time 就好。\n\n2) 開發原生應用程式的流程就是用原生的物件，不管太元件長什麼樣子，反正就是設計互動，註冊事件，最多就小改一下背景、顏色之類的。反正最差就是比較醜，功能都沒問題啊。話說 MFC 到底是什麼鬼東西啊... 記得花了兩三天從來沒搞懂過。\n\n1) 網頁開發不像開發原生應用程式，有功能性較大完整的原生元件。只有一堆小到不行的 HTML 元件。然後問題就來了... 網頁上一塊塊重複的物件，像是 部落格、購物網站、討論區上面一個個的模組要怎麼搞。\n\n如果是靜態的網頁，就背後用 php 弄個模組 ( 喔 交作業而已別太嚴格啦 )，Header 一個Template、商品一個 Template、側邊欄一個 Template、導覽列一個 Template，然後就很開心地從資料庫抓一些資料填進去Template就好啦。有什麼事件發生就傳資料到伺服器端，整個重新畫頁面就好。老實說還挺簡單的，怎麼流程聽起來很像ReactJS。但是 2004 年，總是有一些天才們發明了一些讓人很累的東西叫做 Ajax 把 Gmail 推上了時代尖端。Ajax 告訴所有開發者：「喔 什麼!!! 你把使用者輸入送到伺服器再傳回來，然後才更新 UI，太慢了喔 弱~」。然後從這時候開始，網頁設計師就很苦情的開始在客戶端開始亂刻元件，MVC 邏輯的重擔就移交給 HTML、CSS、Javascript。但主流的開法方式是，不管 MVC 也行啦，反正網頁會動看起來有設計感就好。\n\nJQuery Library 在這亂世中應運而生，讓我苦讀 vanilla Javascript 的經典「ppk談Javascript」變得英雄無用武之地，JQuery 的 selector 就像用 matlab 來處理資料的有快感、dot chain rule 讓語法看起來糖分很高、不用打 getElementById 就像 C++11 中用 STL 不用打 Iterator 一樣清爽。可以快速開發出很難維護的網頁。解決了 Javascript 操作 DOM 會讓人想罵髒話的問題。為什麼很難維護，因為沒有元件化，Javascript有很有力量，讓人在網頁裡隨性的的東改西改，但不知道誰改的就很難 Debug，漸漸變得複雜就不能開發大型網頁。\n\n然後 AngularJS 把後端流行的 資料綁定搬到瀏覽器來，用 Javascript 的 Closure 來做封裝、一區區的資料分別藏起來，限制一部分 Javascript 只能操作 一部分的資料和 HTML，充分發揮了各個擊破的演算法 ( Divide and Conquer )，可是問題又來了... 媽的我花了兩天，學不會 AngularJS 啊一直 Typos 很煩，雙向綁定怎麼那麼複雜，讓我寫程式一直 NG NG。所以我沒太多研究，只聽說是雙向資料綁定會引起 DOM Tree 的 Cacading Update，導致效能容易有問題。另外 HTML 裡塞了太多髒髒的東西，容易消化不良。\n\n### **<u>好啦，說了一大堆廢話，React 和 Flux 到底做了什麼？</u>**\nReact 讓人用 Javascript 和 HTML 刻更高級的元件 ( Virtual DOM )，像是 Angular 元件做的限制 讓一小段 Javascript只負責一小塊的UI / HTML更新，使用各個擊破的演算法，刻完元件之後就像開發原生應用程式時一樣，有了較大的元件，讓人跳脫低級 ( low level ) 的思考，少說一點髒話，透過 JSX 讓人從模組化的角度看 UI。簡單的譬喻就是讓人用組語開發高階語言的語法，之後可以用高階語言寫程式。\n\nReact 只 Update 新的 DOM Tree 中和前一次 DOM Tree 差異之處，他們管這叫 一致 (reconciliation) 讓重繪的速度快很多，當重繪夠快，網頁的開發者就可以回到 pre-AJAX時代，回憶2004年之前的寫開發體驗：把資料送回伺服器，然後收到新資料，整個網頁重繪。\n\n只是這回，資料來源的不是 Database，是 <u>Flux 資料集中管理辦法</u>中的各個 Store ( Client-side Database )。Flux的單向資料流理念，強迫你在客戶端有一個像資料庫的資料集中處，Store裡有來自使用者輸入的資料、有來自伺服器端的資料更新。然後這個資料商店把每一家元件訂閱的資料送上門，元件看了看送來的資料商品然後就更新。Store 像是介於 CPU 和 硬碟中間的 Cache / Memory，是資料的 暫存處和Hub，或是你叫它客戶端的暫存資料庫也行 ( 用 Javascript 物件存的 )。\n\n原來：\nBrowser -- Client Side ......................................... Server\n\n有了 React + Flux 之後 :\nBrowser -- Client Side -- Client Side VM + Server ( React + Flux ) .......................................... Server\n\n有點像是在 Client Side 包了一層 VM + Server 一樣，會把 JSX 轉譯成JS / HTML、集中把資料放在客戶端資料庫裡 ( Flux 的 Store )。\n\n簡單總結一下：\nReact + Flux 是大規模動態資料網頁的解法。\n\nReact 讓需要大型互動元件的客戶端，可以用自己刻的、封裝良好的元件，並在新元件的高度思考。用了個 Reconciliation 的 Trick使得重繪很快，和 <u>Flux 的資料集中管理辦法</u>，讓開發者只要專注做好一件事「當資料來到元件時，把元件要畫好」。\n\n---\nFlux 目的是提出一個客戶端的資料管理辦法。其中的單向資料流 / 資料環其實隱含了 Two way Data Binding，只是不是綁死，比較像是 Two way Data Notification。Dispatcher 管的是 <span style=\"color: blue;\">View Actions -&gt; Store ( Models )</span>。Store 除了存資料外還包含了 <span style=\"color: blue;\">Store ( Models ) -&gt; View&nbsp;</span>的通知。還有人覺得 Dispatcher 很多餘，就寫了一個 reflux.js 把 Dispatcher 拿掉。\n\n延伸閱讀：\n[聊一聊基於Flux的前端系統](http://bbs.react-china.org/t/flux/615)","slug":"React-和-Flux-到底在做什麼","published":1,"updated":"2017-12-23T06:08:08.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjblkzcki0008xq9klfctylwc","content":"<p>看了下面兩個文章，終於知道 React 和 Flux 在做什麼了。<br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">1.&nbsp;<a href=\"http://blog.andrewray.me/reactjs-for-stupid-people/\" target=\"_blank\" rel=\"noopener\">ReactJS For Stupid People</a></span><br>2.&nbsp;<a href=\"http://blog.andrewray.me/flux-for-stupid-people/\" target=\"_blank\" rel=\"noopener\">Flux For Stupid People</a></p>\n<p>以下開始和主題不很相關的廢話，可以直接跳到最後一段「好啦，說了一大堆廢話。」</p>\n<p>前兩天一直迷惑，到底這套新的 UI 開發流程和我過去接觸過的 framework 們有什麼不同？以前用過 Java AWT, JAVA SWING, ZK Markup Language, JQuery UI, iOS UI Kit, Android, QT Component, OpenGL, xxxRendering Engine … 列出來才發現，真的是有的沒的一大堆。</p>\n<p>在螢幕上生出畫面大概可以分成三群：<br>1. 網頁開發<br>2. 桌上 / 手機的原生應用程式<br>3. 遊戲 / 動畫</p>\n<p>3) 寫遊戲和動畫的流程最簡單，大二用組語刻了魔法氣泡遊戲 / 大三參加趨勢比賽徒手硬幹JAVA Swing ( 真的超慢的 T.T ) / 研究所用 3DS Max 和 Blender 做動畫 / 工作上用 OpenGL 做了動態路徑規劃的資料展示。這一類大概每次就是重畫，隨時檢查物件狀態一直重畫。看一下 FPS 有到 Real-Time 就好。</p>\n<p>2) 開發原生應用程式的流程就是用原生的物件，不管太元件長什麼樣子，反正就是設計互動，註冊事件，最多就小改一下背景、顏色之類的。反正最差就是比較醜，功能都沒問題啊。話說 MFC 到底是什麼鬼東西啊… 記得花了兩三天從來沒搞懂過。</p>\n<p>1) 網頁開發不像開發原生應用程式，有功能性較大完整的原生元件。只有一堆小到不行的 HTML 元件。然後問題就來了… 網頁上一塊塊重複的物件，像是 部落格、購物網站、討論區上面一個個的模組要怎麼搞。</p>\n<p>如果是靜態的網頁，就背後用 php 弄個模組 ( 喔 交作業而已別太嚴格啦 )，Header 一個Template、商品一個 Template、側邊欄一個 Template、導覽列一個 Template，然後就很開心地從資料庫抓一些資料填進去Template就好啦。有什麼事件發生就傳資料到伺服器端，整個重新畫頁面就好。老實說還挺簡單的，怎麼流程聽起來很像ReactJS。但是 2004 年，總是有一些天才們發明了一些讓人很累的東西叫做 Ajax 把 Gmail 推上了時代尖端。Ajax 告訴所有開發者：「喔 什麼!!! 你把使用者輸入送到伺服器再傳回來，然後才更新 UI，太慢了喔 弱~」。然後從這時候開始，網頁設計師就很苦情的開始在客戶端開始亂刻元件，MVC 邏輯的重擔就移交給 HTML、CSS、Javascript。但主流的開法方式是，不管 MVC 也行啦，反正網頁會動看起來有設計感就好。</p>\n<p>JQuery Library 在這亂世中應運而生，讓我苦讀 vanilla Javascript 的經典「ppk談Javascript」變得英雄無用武之地，JQuery 的 selector 就像用 matlab 來處理資料的有快感、dot chain rule 讓語法看起來糖分很高、不用打 getElementById 就像 C++11 中用 STL 不用打 Iterator 一樣清爽。可以快速開發出很難維護的網頁。解決了 Javascript 操作 DOM 會讓人想罵髒話的問題。為什麼很難維護，因為沒有元件化，Javascript有很有力量，讓人在網頁裡隨性的的東改西改，但不知道誰改的就很難 Debug，漸漸變得複雜就不能開發大型網頁。</p>\n<p>然後 AngularJS 把後端流行的 資料綁定搬到瀏覽器來，用 Javascript 的 Closure 來做封裝、一區區的資料分別藏起來，限制一部分 Javascript 只能操作 一部分的資料和 HTML，充分發揮了各個擊破的演算法 ( Divide and Conquer )，可是問題又來了… 媽的我花了兩天，學不會 AngularJS 啊一直 Typos 很煩，雙向綁定怎麼那麼複雜，讓我寫程式一直 NG NG。所以我沒太多研究，只聽說是雙向資料綁定會引起 DOM Tree 的 Cacading Update，導致效能容易有問題。另外 HTML 裡塞了太多髒髒的東西，容易消化不良。</p>\n<h3 id=\"好啦，說了一大堆廢話，React-和-Flux-到底做了什麼？\"><a href=\"#好啦，說了一大堆廢話，React-和-Flux-到底做了什麼？\" class=\"headerlink\" title=\"好啦，說了一大堆廢話，React 和 Flux 到底做了什麼？\"></a><strong><u>好啦，說了一大堆廢話，React 和 Flux 到底做了什麼？</u></strong></h3><p>React 讓人用 Javascript 和 HTML 刻更高級的元件 ( Virtual DOM )，像是 Angular 元件做的限制 讓一小段 Javascript只負責一小塊的UI / HTML更新，使用各個擊破的演算法，刻完元件之後就像開發原生應用程式時一樣，有了較大的元件，讓人跳脫低級 ( low level ) 的思考，少說一點髒話，透過 JSX 讓人從模組化的角度看 UI。簡單的譬喻就是讓人用組語開發高階語言的語法，之後可以用高階語言寫程式。</p>\n<p>React 只 Update 新的 DOM Tree 中和前一次 DOM Tree 差異之處，他們管這叫 一致 (reconciliation) 讓重繪的速度快很多，當重繪夠快，網頁的開發者就可以回到 pre-AJAX時代，回憶2004年之前的寫開發體驗：把資料送回伺服器，然後收到新資料，整個網頁重繪。</p>\n<p>只是這回，資料來源的不是 Database，是 <u>Flux 資料集中管理辦法</u>中的各個 Store ( Client-side Database )。Flux的單向資料流理念，強迫你在客戶端有一個像資料庫的資料集中處，Store裡有來自使用者輸入的資料、有來自伺服器端的資料更新。然後這個資料商店把每一家元件訂閱的資料送上門，元件看了看送來的資料商品然後就更新。Store 像是介於 CPU 和 硬碟中間的 Cache / Memory，是資料的 暫存處和Hub，或是你叫它客戶端的暫存資料庫也行 ( 用 Javascript 物件存的 )。</p>\n<p>原來：<br>Browser – Client Side ………………………………….. Server</p>\n<p>有了 React + Flux 之後 :<br>Browser – Client Side – Client Side VM + Server ( React + Flux ) …………………………………… Server</p>\n<p>有點像是在 Client Side 包了一層 VM + Server 一樣，會把 JSX 轉譯成JS / HTML、集中把資料放在客戶端資料庫裡 ( Flux 的 Store )。</p>\n<p>簡單總結一下：<br>React + Flux 是大規模動態資料網頁的解法。</p>\n<p>React 讓需要大型互動元件的客戶端，可以用自己刻的、封裝良好的元件，並在新元件的高度思考。用了個 Reconciliation 的 Trick使得重繪很快，和 <u>Flux 的資料集中管理辦法</u>，讓開發者只要專注做好一件事「當資料來到元件時，把元件要畫好」。</p>\n<hr>\n<p>Flux 目的是提出一個客戶端的資料管理辦法。其中的單向資料流 / 資料環其實隱含了 Two way Data Binding，只是不是綁死，比較像是 Two way Data Notification。Dispatcher 管的是 <span style=\"color: blue;\">View Actions -&gt; Store ( Models )</span>。Store 除了存資料外還包含了 <span style=\"color: blue;\">Store ( Models ) -&gt; View&nbsp;</span>的通知。還有人覺得 Dispatcher 很多餘，就寫了一個 reflux.js 把 Dispatcher 拿掉。</p>\n<p>延伸閱讀：<br><a href=\"http://bbs.react-china.org/t/flux/615\" target=\"_blank\" rel=\"noopener\">聊一聊基於Flux的前端系統</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>看了下面兩個文章，終於知道 React 和 Flux 在做什麼了。<br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">1.&nbsp;<a href=\"http://blog.andrewray.me/reactjs-for-stupid-people/\" target=\"_blank\" rel=\"noopener\">ReactJS For Stupid People</a></span><br>2.&nbsp;<a href=\"http://blog.andrewray.me/flux-for-stupid-people/\" target=\"_blank\" rel=\"noopener\">Flux For Stupid People</a></p>\n<p>以下開始和主題不很相關的廢話，可以直接跳到最後一段「好啦，說了一大堆廢話。」</p>\n<p>前兩天一直迷惑，到底這套新的 UI 開發流程和我過去接觸過的 framework 們有什麼不同？以前用過 Java AWT, JAVA SWING, ZK Markup Language, JQuery UI, iOS UI Kit, Android, QT Component, OpenGL, xxxRendering Engine … 列出來才發現，真的是有的沒的一大堆。</p>\n<p>在螢幕上生出畫面大概可以分成三群：<br>1. 網頁開發<br>2. 桌上 / 手機的原生應用程式<br>3. 遊戲 / 動畫</p>\n<p>3) 寫遊戲和動畫的流程最簡單，大二用組語刻了魔法氣泡遊戲 / 大三參加趨勢比賽徒手硬幹JAVA Swing ( 真的超慢的 T.T ) / 研究所用 3DS Max 和 Blender 做動畫 / 工作上用 OpenGL 做了動態路徑規劃的資料展示。這一類大概每次就是重畫，隨時檢查物件狀態一直重畫。看一下 FPS 有到 Real-Time 就好。</p>\n<p>2) 開發原生應用程式的流程就是用原生的物件，不管太元件長什麼樣子，反正就是設計互動，註冊事件，最多就小改一下背景、顏色之類的。反正最差就是比較醜，功能都沒問題啊。話說 MFC 到底是什麼鬼東西啊… 記得花了兩三天從來沒搞懂過。</p>\n<p>1) 網頁開發不像開發原生應用程式，有功能性較大完整的原生元件。只有一堆小到不行的 HTML 元件。然後問題就來了… 網頁上一塊塊重複的物件，像是 部落格、購物網站、討論區上面一個個的模組要怎麼搞。</p>\n<p>如果是靜態的網頁，就背後用 php 弄個模組 ( 喔 交作業而已別太嚴格啦 )，Header 一個Template、商品一個 Template、側邊欄一個 Template、導覽列一個 Template，然後就很開心地從資料庫抓一些資料填進去Template就好啦。有什麼事件發生就傳資料到伺服器端，整個重新畫頁面就好。老實說還挺簡單的，怎麼流程聽起來很像ReactJS。但是 2004 年，總是有一些天才們發明了一些讓人很累的東西叫做 Ajax 把 Gmail 推上了時代尖端。Ajax 告訴所有開發者：「喔 什麼!!! 你把使用者輸入送到伺服器再傳回來，然後才更新 UI，太慢了喔 弱~」。然後從這時候開始，網頁設計師就很苦情的開始在客戶端開始亂刻元件，MVC 邏輯的重擔就移交給 HTML、CSS、Javascript。但主流的開法方式是，不管 MVC 也行啦，反正網頁會動看起來有設計感就好。</p>\n<p>JQuery Library 在這亂世中應運而生，讓我苦讀 vanilla Javascript 的經典「ppk談Javascript」變得英雄無用武之地，JQuery 的 selector 就像用 matlab 來處理資料的有快感、dot chain rule 讓語法看起來糖分很高、不用打 getElementById 就像 C++11 中用 STL 不用打 Iterator 一樣清爽。可以快速開發出很難維護的網頁。解決了 Javascript 操作 DOM 會讓人想罵髒話的問題。為什麼很難維護，因為沒有元件化，Javascript有很有力量，讓人在網頁裡隨性的的東改西改，但不知道誰改的就很難 Debug，漸漸變得複雜就不能開發大型網頁。</p>\n<p>然後 AngularJS 把後端流行的 資料綁定搬到瀏覽器來，用 Javascript 的 Closure 來做封裝、一區區的資料分別藏起來，限制一部分 Javascript 只能操作 一部分的資料和 HTML，充分發揮了各個擊破的演算法 ( Divide and Conquer )，可是問題又來了… 媽的我花了兩天，學不會 AngularJS 啊一直 Typos 很煩，雙向綁定怎麼那麼複雜，讓我寫程式一直 NG NG。所以我沒太多研究，只聽說是雙向資料綁定會引起 DOM Tree 的 Cacading Update，導致效能容易有問題。另外 HTML 裡塞了太多髒髒的東西，容易消化不良。</p>\n<h3 id=\"好啦，說了一大堆廢話，React-和-Flux-到底做了什麼？\"><a href=\"#好啦，說了一大堆廢話，React-和-Flux-到底做了什麼？\" class=\"headerlink\" title=\"好啦，說了一大堆廢話，React 和 Flux 到底做了什麼？\"></a><strong><u>好啦，說了一大堆廢話，React 和 Flux 到底做了什麼？</u></strong></h3><p>React 讓人用 Javascript 和 HTML 刻更高級的元件 ( Virtual DOM )，像是 Angular 元件做的限制 讓一小段 Javascript只負責一小塊的UI / HTML更新，使用各個擊破的演算法，刻完元件之後就像開發原生應用程式時一樣，有了較大的元件，讓人跳脫低級 ( low level ) 的思考，少說一點髒話，透過 JSX 讓人從模組化的角度看 UI。簡單的譬喻就是讓人用組語開發高階語言的語法，之後可以用高階語言寫程式。</p>\n<p>React 只 Update 新的 DOM Tree 中和前一次 DOM Tree 差異之處，他們管這叫 一致 (reconciliation) 讓重繪的速度快很多，當重繪夠快，網頁的開發者就可以回到 pre-AJAX時代，回憶2004年之前的寫開發體驗：把資料送回伺服器，然後收到新資料，整個網頁重繪。</p>\n<p>只是這回，資料來源的不是 Database，是 <u>Flux 資料集中管理辦法</u>中的各個 Store ( Client-side Database )。Flux的單向資料流理念，強迫你在客戶端有一個像資料庫的資料集中處，Store裡有來自使用者輸入的資料、有來自伺服器端的資料更新。然後這個資料商店把每一家元件訂閱的資料送上門，元件看了看送來的資料商品然後就更新。Store 像是介於 CPU 和 硬碟中間的 Cache / Memory，是資料的 暫存處和Hub，或是你叫它客戶端的暫存資料庫也行 ( 用 Javascript 物件存的 )。</p>\n<p>原來：<br>Browser – Client Side ………………………………….. Server</p>\n<p>有了 React + Flux 之後 :<br>Browser – Client Side – Client Side VM + Server ( React + Flux ) …………………………………… Server</p>\n<p>有點像是在 Client Side 包了一層 VM + Server 一樣，會把 JSX 轉譯成JS / HTML、集中把資料放在客戶端資料庫裡 ( Flux 的 Store )。</p>\n<p>簡單總結一下：<br>React + Flux 是大規模動態資料網頁的解法。</p>\n<p>React 讓需要大型互動元件的客戶端，可以用自己刻的、封裝良好的元件，並在新元件的高度思考。用了個 Reconciliation 的 Trick使得重繪很快，和 <u>Flux 的資料集中管理辦法</u>，讓開發者只要專注做好一件事「當資料來到元件時，把元件要畫好」。</p>\n<hr>\n<p>Flux 目的是提出一個客戶端的資料管理辦法。其中的單向資料流 / 資料環其實隱含了 Two way Data Binding，只是不是綁死，比較像是 Two way Data Notification。Dispatcher 管的是 <span style=\"color: blue;\">View Actions -&gt; Store ( Models )</span>。Store 除了存資料外還包含了 <span style=\"color: blue;\">Store ( Models ) -&gt; View&nbsp;</span>的通知。還有人覺得 Dispatcher 很多餘，就寫了一個 reflux.js 把 Dispatcher 拿掉。</p>\n<p>延伸閱讀：<br><a href=\"http://bbs.react-china.org/t/flux/615\" target=\"_blank\" rel=\"noopener\">聊一聊基於Flux的前端系統</a></p>\n"},{"title":"Redux = 事件驅動系統 = 伺服器","date":"2015-11-08T06:58:00.000Z","_content":"\n<span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Redux 做的事情其實很簡單 ( [主程式才99行](https://gist.github.com/gaearon/ffd88b0e4f00b22c3159)&nbsp;)，就是可客制 Event 的 Event System。這概念在別的領域已經很成熟。但因為 Redux 的目標使用者是 Flux 的使用者，套用了很多原來 Flux 裡的專有名詞，所以對非 Flux 使用者變得很難懂。這邊透過類比大家都知道的名詞，目標讓 Redux 的概念連六歲小孩都能理解。</span>\n<span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">\n</span>\n\n## <span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Flux：</span>\n<span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Actions trigger reducer to update states in the store.</span>\n<span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">\n</span><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">\n</span>\n\n## <span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Redux 的行為等於事件驅動系統 ( Event-driven System ) / 有限狀態機 ( FSM )：</span>\n<span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Events trigger event handler to update states in the machine.</span>\n<span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">\n</span><table class=\"graytable\">  <tbody><tr>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Action</span></td>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Event | Signal | Message</span></td>    </tr><tr>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Reducer</span></td>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Event Handler | Finite State Machine 中的 transducer</span></td>    </tr></tbody></table><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">\n</span><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">\n</span>\n\n## <span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Redux 的行為等於一個網頁伺服器：</span>\n<span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">When a request came, using route table mapping to get a method to process it。 </span>\n<span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">\n</span><table class=\"graytable\">  <tbody><tr>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Action</span></td>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Http Request</span></td>    </tr><tr>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Store.dispatch(Action)</span></td>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">送 Request 到 Server</span></td>    </tr><tr>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Reducer</span></td>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Router 把 Request 送到對應的 Router Method，更新 Database</span></td>    </tr><tr>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Store</span></td>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Database</span></td>    </tr><tr>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">UI / React</span></td>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Http Response</span></td>    </tr></tbody></table><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">\n</span><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">\n</span><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Redux的行為等於巷口那家... 哎 想不出來比較生活的說法。</span>\n<span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">\n</span><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">現在有沒有覺得 Redux 很 Awesome？好像沒有啊... 但我們回到瀏覽器的環境重新看一下，因為 HTML 的元件很小，開發者會組合 HTML元件成為可重複使用的「大元件」。但問題是瀏覽器中的 「事件處理系統」 是針對 HTML 小元件的，沒有給「大元件」的。於是Redux 提供了給開發者可以自行定義事件的「大元件」事件處理系統，因為你可以控制整個事件處理系統，重播和紀錄事件都變成毫不費力的事。現在又感覺到 &nbsp;Redux 很 Awesome了吧!!!</span>\n<span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">\n</span><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">故事到了這邊，一定會想這樣解說，哪個六歲小孩能了解啊，相信這是大家共同的疑惑，不過 「投資一定有風險，基金投資有賺有賠，申購前應詳閱公開說明書」，我會反省的...</span>\n<span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">\n</span><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">---</span>\n<span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">\n</span><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">延伸閱讀：</span>\n<span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">[redux 的專有名詞解釋](http://rackt.org/redux/docs/Glossary.html)</span>\n[<span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Redux Issue 891：Is redux conflating actions with events?</span>](https://github.com/rackt/redux/issues/891)\n[<span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">六歲小孩也能懂的 Javascript Closure 說明</span>](http://stackoverflow.com/questions/111102/how-do-javascript-closures-work)","source":"_posts/Redux-事件驅動系統-伺服器.md","raw":"---\ntitle: Redux = 事件驅動系統 = 伺服器\ntags:\n  - event system\n  - one way data flow\n  - react\n  - redux\ndate: 2015-11-08 14:58:00\n---\n\n<span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Redux 做的事情其實很簡單 ( [主程式才99行](https://gist.github.com/gaearon/ffd88b0e4f00b22c3159)&nbsp;)，就是可客制 Event 的 Event System。這概念在別的領域已經很成熟。但因為 Redux 的目標使用者是 Flux 的使用者，套用了很多原來 Flux 裡的專有名詞，所以對非 Flux 使用者變得很難懂。這邊透過類比大家都知道的名詞，目標讓 Redux 的概念連六歲小孩都能理解。</span>\n<span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">\n</span>\n\n## <span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Flux：</span>\n<span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Actions trigger reducer to update states in the store.</span>\n<span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">\n</span><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">\n</span>\n\n## <span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Redux 的行為等於事件驅動系統 ( Event-driven System ) / 有限狀態機 ( FSM )：</span>\n<span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Events trigger event handler to update states in the machine.</span>\n<span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">\n</span><table class=\"graytable\">  <tbody><tr>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Action</span></td>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Event | Signal | Message</span></td>    </tr><tr>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Reducer</span></td>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Event Handler | Finite State Machine 中的 transducer</span></td>    </tr></tbody></table><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">\n</span><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">\n</span>\n\n## <span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Redux 的行為等於一個網頁伺服器：</span>\n<span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">When a request came, using route table mapping to get a method to process it。 </span>\n<span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">\n</span><table class=\"graytable\">  <tbody><tr>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Action</span></td>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Http Request</span></td>    </tr><tr>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Store.dispatch(Action)</span></td>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">送 Request 到 Server</span></td>    </tr><tr>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Reducer</span></td>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Router 把 Request 送到對應的 Router Method，更新 Database</span></td>    </tr><tr>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Store</span></td>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Database</span></td>    </tr><tr>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">UI / React</span></td>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Http Response</span></td>    </tr></tbody></table><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">\n</span><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">\n</span><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Redux的行為等於巷口那家... 哎 想不出來比較生活的說法。</span>\n<span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">\n</span><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">現在有沒有覺得 Redux 很 Awesome？好像沒有啊... 但我們回到瀏覽器的環境重新看一下，因為 HTML 的元件很小，開發者會組合 HTML元件成為可重複使用的「大元件」。但問題是瀏覽器中的 「事件處理系統」 是針對 HTML 小元件的，沒有給「大元件」的。於是Redux 提供了給開發者可以自行定義事件的「大元件」事件處理系統，因為你可以控制整個事件處理系統，重播和紀錄事件都變成毫不費力的事。現在又感覺到 &nbsp;Redux 很 Awesome了吧!!!</span>\n<span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">\n</span><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">故事到了這邊，一定會想這樣解說，哪個六歲小孩能了解啊，相信這是大家共同的疑惑，不過 「投資一定有風險，基金投資有賺有賠，申購前應詳閱公開說明書」，我會反省的...</span>\n<span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">\n</span><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">---</span>\n<span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">\n</span><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">延伸閱讀：</span>\n<span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">[redux 的專有名詞解釋](http://rackt.org/redux/docs/Glossary.html)</span>\n[<span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Redux Issue 891：Is redux conflating actions with events?</span>](https://github.com/rackt/redux/issues/891)\n[<span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">六歲小孩也能懂的 Javascript Closure 說明</span>](http://stackoverflow.com/questions/111102/how-do-javascript-closures-work)","slug":"Redux-事件驅動系統-伺服器","published":1,"updated":"2017-12-23T06:08:08.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjblkzckk000bxq9kdo564m4d","content":"<p><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Redux 做的事情其實很簡單 ( <a href=\"https://gist.github.com/gaearon/ffd88b0e4f00b22c3159\" target=\"_blank\" rel=\"noopener\">主程式才99行</a>&nbsp;)，就是可客制 Event 的 Event System。這概念在別的領域已經很成熟。但因為 Redux 的目標使用者是 Flux 的使用者，套用了很多原來 Flux 裡的專有名詞，所以對非 Flux 使用者變得很難懂。這邊透過類比大家都知道的名詞，目標讓 Redux 的概念連六歲小孩都能理解。</span><br><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\"><br></span></p>\n<h2 id=\"Flux：\"><a href=\"#Flux：\" class=\"headerlink\" title=\"Flux：\"></a><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Flux：</span></h2><p><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Actions trigger reducer to update states in the store.</span><br><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\"><br></span><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\"><br></span></p>\n<h2 id=\"Redux-的行為等於事件驅動系統-Event-driven-System-有限狀態機-FSM-：\"><a href=\"#Redux-的行為等於事件驅動系統-Event-driven-System-有限狀態機-FSM-：\" class=\"headerlink\" title=\"Redux 的行為等於事件驅動系統 ( Event-driven System ) / 有限狀態機 ( FSM )：\"></a><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Redux 的行為等於事件驅動系統 ( Event-driven System ) / 有限狀態機 ( FSM )：</span></h2><p><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Events trigger event handler to update states in the machine.</span><br><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\"><br></span><table class=\"graytable\">  <tbody><tr>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Action</span></td>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Event | Signal | Message</span></td>    </tr><tr>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Reducer</span></td>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Event Handler | Finite State Machine 中的 transducer</span></td>    </tr></tbody></table><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\"><br></span><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\"><br></span></p>\n<h2 id=\"Redux-的行為等於一個網頁伺服器：\"><a href=\"#Redux-的行為等於一個網頁伺服器：\" class=\"headerlink\" title=\"Redux 的行為等於一個網頁伺服器：\"></a><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Redux 的行為等於一個網頁伺服器：</span></h2><p><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">When a request came, using route table mapping to get a method to process it。 </span><br><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\"><br></span><table class=\"graytable\">  <tbody><tr>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Action</span></td>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Http Request</span></td>    </tr><tr>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Store.dispatch(Action)</span></td>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">送 Request 到 Server</span></td>    </tr><tr>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Reducer</span></td>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Router 把 Request 送到對應的 Router Method，更新 Database</span></td>    </tr><tr>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Store</span></td>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Database</span></td>    </tr><tr>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">UI / React</span></td>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Http Response</span></td>    </tr></tbody></table><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\"><br></span><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\"><br></span><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Redux的行為等於巷口那家… 哎 想不出來比較生活的說法。</span><br><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\"><br></span><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">現在有沒有覺得 Redux 很 Awesome？好像沒有啊… 但我們回到瀏覽器的環境重新看一下，因為 HTML 的元件很小，開發者會組合 HTML元件成為可重複使用的「大元件」。但問題是瀏覽器中的 「事件處理系統」 是針對 HTML 小元件的，沒有給「大元件」的。於是Redux 提供了給開發者可以自行定義事件的「大元件」事件處理系統，因為你可以控制整個事件處理系統，重播和紀錄事件都變成毫不費力的事。現在又感覺到 &nbsp;Redux 很 Awesome了吧!!!</span><br><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\"><br></span><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">故事到了這邊，一定會想這樣解說，哪個六歲小孩能了解啊，相信這是大家共同的疑惑，不過 「投資一定有風險，基金投資有賺有賠，申購前應詳閱公開說明書」，我會反省的…</span><br><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\"><br></span><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">—</span><br><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\"><br></span><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">延伸閱讀：</span><br><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\"><a href=\"http://rackt.org/redux/docs/Glossary.html\" target=\"_blank\" rel=\"noopener\">redux 的專有名詞解釋</a></span><br><a href=\"https://github.com/rackt/redux/issues/891\" target=\"_blank\" rel=\"noopener\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Redux Issue 891：Is redux conflating actions with events?</span></a><br><a href=\"http://stackoverflow.com/questions/111102/how-do-javascript-closures-work\" target=\"_blank\" rel=\"noopener\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">六歲小孩也能懂的 Javascript Closure 說明</span></a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Redux 做的事情其實很簡單 ( <a href=\"https://gist.github.com/gaearon/ffd88b0e4f00b22c3159\" target=\"_blank\" rel=\"noopener\">主程式才99行</a>&nbsp;)，就是可客制 Event 的 Event System。這概念在別的領域已經很成熟。但因為 Redux 的目標使用者是 Flux 的使用者，套用了很多原來 Flux 裡的專有名詞，所以對非 Flux 使用者變得很難懂。這邊透過類比大家都知道的名詞，目標讓 Redux 的概念連六歲小孩都能理解。</span><br><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\"><br></span></p>\n<h2 id=\"Flux：\"><a href=\"#Flux：\" class=\"headerlink\" title=\"Flux：\"></a><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Flux：</span></h2><p><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Actions trigger reducer to update states in the store.</span><br><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\"><br></span><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\"><br></span></p>\n<h2 id=\"Redux-的行為等於事件驅動系統-Event-driven-System-有限狀態機-FSM-：\"><a href=\"#Redux-的行為等於事件驅動系統-Event-driven-System-有限狀態機-FSM-：\" class=\"headerlink\" title=\"Redux 的行為等於事件驅動系統 ( Event-driven System ) / 有限狀態機 ( FSM )：\"></a><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Redux 的行為等於事件驅動系統 ( Event-driven System ) / 有限狀態機 ( FSM )：</span></h2><p><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Events trigger event handler to update states in the machine.</span><br><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\"><br></span><table class=\"graytable\">  <tbody><tr>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Action</span></td>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Event | Signal | Message</span></td>    </tr><tr>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Reducer</span></td>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Event Handler | Finite State Machine 中的 transducer</span></td>    </tr></tbody></table><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\"><br></span><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\"><br></span></p>\n<h2 id=\"Redux-的行為等於一個網頁伺服器：\"><a href=\"#Redux-的行為等於一個網頁伺服器：\" class=\"headerlink\" title=\"Redux 的行為等於一個網頁伺服器：\"></a><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Redux 的行為等於一個網頁伺服器：</span></h2><p><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">When a request came, using route table mapping to get a method to process it。 </span><br><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\"><br></span><table class=\"graytable\">  <tbody><tr>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Action</span></td>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Http Request</span></td>    </tr><tr>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Store.dispatch(Action)</span></td>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">送 Request 到 Server</span></td>    </tr><tr>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Reducer</span></td>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Router 把 Request 送到對應的 Router Method，更新 Database</span></td>    </tr><tr>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Store</span></td>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Database</span></td>    </tr><tr>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">UI / React</span></td>    <td><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Http Response</span></td>    </tr></tbody></table><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\"><br></span><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\"><br></span><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Redux的行為等於巷口那家… 哎 想不出來比較生活的說法。</span><br><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\"><br></span><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">現在有沒有覺得 Redux 很 Awesome？好像沒有啊… 但我們回到瀏覽器的環境重新看一下，因為 HTML 的元件很小，開發者會組合 HTML元件成為可重複使用的「大元件」。但問題是瀏覽器中的 「事件處理系統」 是針對 HTML 小元件的，沒有給「大元件」的。於是Redux 提供了給開發者可以自行定義事件的「大元件」事件處理系統，因為你可以控制整個事件處理系統，重播和紀錄事件都變成毫不費力的事。現在又感覺到 &nbsp;Redux 很 Awesome了吧!!!</span><br><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\"><br></span><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">故事到了這邊，一定會想這樣解說，哪個六歲小孩能了解啊，相信這是大家共同的疑惑，不過 「投資一定有風險，基金投資有賺有賠，申購前應詳閱公開說明書」，我會反省的…</span><br><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\"><br></span><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">—</span><br><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\"><br></span><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">延伸閱讀：</span><br><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\"><a href=\"http://rackt.org/redux/docs/Glossary.html\" target=\"_blank\" rel=\"noopener\">redux 的專有名詞解釋</a></span><br><a href=\"https://github.com/rackt/redux/issues/891\" target=\"_blank\" rel=\"noopener\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">Redux Issue 891：Is redux conflating actions with events?</span></a><br><a href=\"http://stackoverflow.com/questions/111102/how-do-javascript-closures-work\" target=\"_blank\" rel=\"noopener\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">六歲小孩也能懂的 Javascript Closure 說明</span></a></p>\n"},{"title":"Redux 簡介：我終於看穿它了","date":"2016-11-06T08:41:00.000Z","_content":"\nRedux 把資料放在 store 中，它是個資料庫，但 Redux 不用常見的 SQL 介面，要開發者自訂指令介面。這介面有簡單的標準，他只接受 Action = {type, payload} 物件的輸入。在傳統的資料庫中，下了 SQL 資料庫就會照指令，來更新資料庫，但在 Redux 中，開發者需要自行寫一個 Reducer 來處理輸入的 Action 指令。和傳統資料庫不同的是，這個 Redux 資料庫變了之後，Redux 會 push 變動了的資料到訂閱者 (一個 Javascript 物件)，行為就像是 Baas 服務 (parse, firebase) 常見的 push message。Redux 和傳統關聯式資料庫最大的不同點是，Redux 用 JS 物件或變數來儲存資料；傳統資料庫因為有大量相關的資料，所以用資料表 (data array, data table) 來儲存。這讓 Redux 的狀態樹一直呈現很難視覺化的情況，目前樹狀結構最好的視覺化就是，Browser 的 dev tool 了。如果能把 Redux state 架構轉成 html，也許會有很好的效果也不一定。 另一個選項是 D3.js 的 Simple Tree。\n\n# 簡單的資料庫列表比較\n![](https://4.bp.blogspot.com/-sSMTas7I6yk/WB7sjh1ylYI/AAAAAAAA45k/E5kCkDcf1F0ZYe-Xf4Yv4KGeIfnnowtUwCLcB/s1600/Screen%2BShot%2B2016-11-06%2Bat%2B4.37.19%2BPM.jpg)\n\nRedux 和 Firebase 的資料儲存方式很相近，可以很好的一起運用整合。也許進一步把 client 的資料再切為，Server Data 和 View Data 的設定會更好。Server Data will always synced with Firebase.\n\n另外一提，Redux 實際上就只是個資料庫 (Model)，只有 input & outpt，哪有什麼 middleware… in the middle of what？Redux-middleware 實際上是一部分的 controller，跟 Redux 無關啊。React 也包含 Controller。畫成圖來表示\n![](https://3.bp.blogspot.com/-iuJOF3G-YCg/WB7sNkMUYfI/AAAAAAAA45g/-T3GLN0twVwBwHN2hm9_ncod0-qlG4krQCLcB/s1600/Screen%2BShot%2B2016-11-06%2Bat%2B4.38.55%2BPM.jpg)\n\nFlux 把傳統的 MVC 切成了上行和下行，形成了一個循環資料流，它最大的優點是有 paper 支持的 Single Source of Truth。想像一下 bug 在房間亂跑好抓還是... bug 繞著固定的圈圈跑，bug 繞圈圈跑的話，在原地等 bug 跑過來就抓到了。\n\n總結一下，說穿了 Redux 就是一個啥功能都沒有的資料庫設計規範。也因此，他的文件很長、相關模組很多。\n","source":"_posts/Redux-簡介：我終於看穿它了.md","raw":"---\ntitle: Redux 簡介：我終於看穿它了\ntags:\n  - firebase\n  - MobX\n  - Model\n  - redux\ndate: 2016-11-06 16:41:00\n---\n\nRedux 把資料放在 store 中，它是個資料庫，但 Redux 不用常見的 SQL 介面，要開發者自訂指令介面。這介面有簡單的標準，他只接受 Action = {type, payload} 物件的輸入。在傳統的資料庫中，下了 SQL 資料庫就會照指令，來更新資料庫，但在 Redux 中，開發者需要自行寫一個 Reducer 來處理輸入的 Action 指令。和傳統資料庫不同的是，這個 Redux 資料庫變了之後，Redux 會 push 變動了的資料到訂閱者 (一個 Javascript 物件)，行為就像是 Baas 服務 (parse, firebase) 常見的 push message。Redux 和傳統關聯式資料庫最大的不同點是，Redux 用 JS 物件或變數來儲存資料；傳統資料庫因為有大量相關的資料，所以用資料表 (data array, data table) 來儲存。這讓 Redux 的狀態樹一直呈現很難視覺化的情況，目前樹狀結構最好的視覺化就是，Browser 的 dev tool 了。如果能把 Redux state 架構轉成 html，也許會有很好的效果也不一定。 另一個選項是 D3.js 的 Simple Tree。\n\n# 簡單的資料庫列表比較\n![](https://4.bp.blogspot.com/-sSMTas7I6yk/WB7sjh1ylYI/AAAAAAAA45k/E5kCkDcf1F0ZYe-Xf4Yv4KGeIfnnowtUwCLcB/s1600/Screen%2BShot%2B2016-11-06%2Bat%2B4.37.19%2BPM.jpg)\n\nRedux 和 Firebase 的資料儲存方式很相近，可以很好的一起運用整合。也許進一步把 client 的資料再切為，Server Data 和 View Data 的設定會更好。Server Data will always synced with Firebase.\n\n另外一提，Redux 實際上就只是個資料庫 (Model)，只有 input & outpt，哪有什麼 middleware… in the middle of what？Redux-middleware 實際上是一部分的 controller，跟 Redux 無關啊。React 也包含 Controller。畫成圖來表示\n![](https://3.bp.blogspot.com/-iuJOF3G-YCg/WB7sNkMUYfI/AAAAAAAA45g/-T3GLN0twVwBwHN2hm9_ncod0-qlG4krQCLcB/s1600/Screen%2BShot%2B2016-11-06%2Bat%2B4.38.55%2BPM.jpg)\n\nFlux 把傳統的 MVC 切成了上行和下行，形成了一個循環資料流，它最大的優點是有 paper 支持的 Single Source of Truth。想像一下 bug 在房間亂跑好抓還是... bug 繞著固定的圈圈跑，bug 繞圈圈跑的話，在原地等 bug 跑過來就抓到了。\n\n總結一下，說穿了 Redux 就是一個啥功能都沒有的資料庫設計規範。也因此，他的文件很長、相關模組很多。\n","slug":"Redux-簡介：我終於看穿它了","published":1,"updated":"2017-12-25T02:19:53.075Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjblkzckn000cxq9ki689mvp8","content":"<p>Redux 把資料放在 store 中，它是個資料庫，但 Redux 不用常見的 SQL 介面，要開發者自訂指令介面。這介面有簡單的標準，他只接受 Action = {type, payload} 物件的輸入。在傳統的資料庫中，下了 SQL 資料庫就會照指令，來更新資料庫，但在 Redux 中，開發者需要自行寫一個 Reducer 來處理輸入的 Action 指令。和傳統資料庫不同的是，這個 Redux 資料庫變了之後，Redux 會 push 變動了的資料到訂閱者 (一個 Javascript 物件)，行為就像是 Baas 服務 (parse, firebase) 常見的 push message。Redux 和傳統關聯式資料庫最大的不同點是，Redux 用 JS 物件或變數來儲存資料；傳統資料庫因為有大量相關的資料，所以用資料表 (data array, data table) 來儲存。這讓 Redux 的狀態樹一直呈現很難視覺化的情況，目前樹狀結構最好的視覺化就是，Browser 的 dev tool 了。如果能把 Redux state 架構轉成 html，也許會有很好的效果也不一定。 另一個選項是 D3.js 的 Simple Tree。</p>\n<h1 id=\"簡單的資料庫列表比較\"><a href=\"#簡單的資料庫列表比較\" class=\"headerlink\" title=\"簡單的資料庫列表比較\"></a>簡單的資料庫列表比較</h1><p><img src=\"https://4.bp.blogspot.com/-sSMTas7I6yk/WB7sjh1ylYI/AAAAAAAA45k/E5kCkDcf1F0ZYe-Xf4Yv4KGeIfnnowtUwCLcB/s1600/Screen%2BShot%2B2016-11-06%2Bat%2B4.37.19%2BPM.jpg\" alt=\"\"></p>\n<p>Redux 和 Firebase 的資料儲存方式很相近，可以很好的一起運用整合。也許進一步把 client 的資料再切為，Server Data 和 View Data 的設定會更好。Server Data will always synced with Firebase.</p>\n<p>另外一提，Redux 實際上就只是個資料庫 (Model)，只有 input &amp; outpt，哪有什麼 middleware… in the middle of what？Redux-middleware 實際上是一部分的 controller，跟 Redux 無關啊。React 也包含 Controller。畫成圖來表示<br><img src=\"https://3.bp.blogspot.com/-iuJOF3G-YCg/WB7sNkMUYfI/AAAAAAAA45g/-T3GLN0twVwBwHN2hm9_ncod0-qlG4krQCLcB/s1600/Screen%2BShot%2B2016-11-06%2Bat%2B4.38.55%2BPM.jpg\" alt=\"\"></p>\n<p>Flux 把傳統的 MVC 切成了上行和下行，形成了一個循環資料流，它最大的優點是有 paper 支持的 Single Source of Truth。想像一下 bug 在房間亂跑好抓還是… bug 繞著固定的圈圈跑，bug 繞圈圈跑的話，在原地等 bug 跑過來就抓到了。</p>\n<p>總結一下，說穿了 Redux 就是一個啥功能都沒有的資料庫設計規範。也因此，他的文件很長、相關模組很多。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Redux 把資料放在 store 中，它是個資料庫，但 Redux 不用常見的 SQL 介面，要開發者自訂指令介面。這介面有簡單的標準，他只接受 Action = {type, payload} 物件的輸入。在傳統的資料庫中，下了 SQL 資料庫就會照指令，來更新資料庫，但在 Redux 中，開發者需要自行寫一個 Reducer 來處理輸入的 Action 指令。和傳統資料庫不同的是，這個 Redux 資料庫變了之後，Redux 會 push 變動了的資料到訂閱者 (一個 Javascript 物件)，行為就像是 Baas 服務 (parse, firebase) 常見的 push message。Redux 和傳統關聯式資料庫最大的不同點是，Redux 用 JS 物件或變數來儲存資料；傳統資料庫因為有大量相關的資料，所以用資料表 (data array, data table) 來儲存。這讓 Redux 的狀態樹一直呈現很難視覺化的情況，目前樹狀結構最好的視覺化就是，Browser 的 dev tool 了。如果能把 Redux state 架構轉成 html，也許會有很好的效果也不一定。 另一個選項是 D3.js 的 Simple Tree。</p>\n<h1 id=\"簡單的資料庫列表比較\"><a href=\"#簡單的資料庫列表比較\" class=\"headerlink\" title=\"簡單的資料庫列表比較\"></a>簡單的資料庫列表比較</h1><p><img src=\"https://4.bp.blogspot.com/-sSMTas7I6yk/WB7sjh1ylYI/AAAAAAAA45k/E5kCkDcf1F0ZYe-Xf4Yv4KGeIfnnowtUwCLcB/s1600/Screen%2BShot%2B2016-11-06%2Bat%2B4.37.19%2BPM.jpg\" alt=\"\"></p>\n<p>Redux 和 Firebase 的資料儲存方式很相近，可以很好的一起運用整合。也許進一步把 client 的資料再切為，Server Data 和 View Data 的設定會更好。Server Data will always synced with Firebase.</p>\n<p>另外一提，Redux 實際上就只是個資料庫 (Model)，只有 input &amp; outpt，哪有什麼 middleware… in the middle of what？Redux-middleware 實際上是一部分的 controller，跟 Redux 無關啊。React 也包含 Controller。畫成圖來表示<br><img src=\"https://3.bp.blogspot.com/-iuJOF3G-YCg/WB7sNkMUYfI/AAAAAAAA45g/-T3GLN0twVwBwHN2hm9_ncod0-qlG4krQCLcB/s1600/Screen%2BShot%2B2016-11-06%2Bat%2B4.38.55%2BPM.jpg\" alt=\"\"></p>\n<p>Flux 把傳統的 MVC 切成了上行和下行，形成了一個循環資料流，它最大的優點是有 paper 支持的 Single Source of Truth。想像一下 bug 在房間亂跑好抓還是… bug 繞著固定的圈圈跑，bug 繞圈圈跑的話，在原地等 bug 跑過來就抓到了。</p>\n<p>總結一下，說穿了 Redux 就是一個啥功能都沒有的資料庫設計規範。也因此，他的文件很長、相關模組很多。</p>\n"},{"title":"”redux.js --- 可預測的狀態容器“ 的 API 使用說明","date":"2016-04-10T07:58:00.000Z","_content":"\n這邊只會透過理解 Redux 的 API來簡介如何使用 Redux。這邊假設讀者都知道 web 中 event / listener 的 pattern。\n\n如果想要知道 redux 背後的實作細節、原理、動機、Flux、Design Pattern、如何和 UI App 做連結，請看 Dan 的 Redux gitbook、Redux tutorial on EggHead。\n\n**redux 是一個狀態容器 (state container / state machine)**\n\n狀態容器要提供幾個功能\n```js\n1. 初始容器狀態 _by Redux.createStore(**reducer**)_\n2. 取得現在的狀態 _by store.getState()_\n3. 狀態改變時，通知相關的程式 _by store.subscribe(**listener**)_\n3. 接收事件發生的通知、改變狀態 _by store.dispatch(**action**)_\n4. 建立之後改變事件處理方式 _by store.replaceReducer(**reducer**)_\n5. 由小的狀態容器組成全域狀態容器 _by 只能透過 combineReducers 來組成 root reducer，再用它來建全域狀態容器_\n```\n\nFlux 專有名詞：store、action、reducer。\n\nstore := 一個狀態容器\naction := 一個像 Event 一樣有 type 屬性的 javascript object\nreducer := 一個輸入 state 和 action、回傳新 state 的函數, (state, action) -> new_state\n\n但 store 是 redux 中唯一一個狀態容器的名字。其實 API 等同於下方這樣子\n```js\n1. _by Redux.createStore(**reducer**)_ 等於 _by Redux(**reducer**)_\n2. _by store.getState()_ 等於 _by Redux.getState()_\n3. _by store.subscribe(**listener**)_ 等於 _by Redux.addListener(**listener**)_\n3. _by store.dispatch(**action**)_ 等於 _by Redux.dispatch(**action**)_\n4. _by store.replaceReducer(**reducer**)_ 等於 _by Redux.replaceReducer(**reducer**)_\n5. _by 無直接 API，只能透過 combineReducers 來組成root reducer，然後用 root reducer 來建全域 store_\n```\n一個狀態容器 = 狀態 + reducer，但 reducer 中可以指定初始狀態、所以一個 reducer 其實可以定義一個狀態容器、等同於一個狀態容器，所以 API 等同於下方這樣子\n```js\n1. _by Redux.initContainer(**reducer**)_ 等於 _by Redux(**container**)_\n2. _by Redux.getState()_\n3. _by Redux.addListener(**listener**)_\n3. _by Redux.dispatch(**action**)_\n4. _by Redux.replaceReducer(**reducer**)_ 等於 _by Redux.container.replaceReducer(**container.reducer**)_\n5. _by 只能透過 combineReducers 來組成 root reducer，再用它來建全域狀態容器_ 等於 _Redux.combineContainer_\n```\n\n把 combineContainer 用 addContainer 取代，API 可以改寫成這樣子\n```js\n1. 初始容器狀態 _by Redux()_\n2. 取得現在的狀態 _by Redux.getState()_\n3. 狀態改變時，通知相關的程式 _by Redux.addListener(**listener**)_\n3. 接收事件發生的通知、改變狀態 _by Redux.dispatch(**action**)_\n4. 建立之後改變事件處理方式 _by Redux.getContainer(**name**).replaceReducer(reducer)_\n5. 由小的狀態容器組成全域狀態容器 _by Redux.addContainer(**container**)_\n6. 建立小的狀態容器 _by Redux.container(name, initialState, reducers)_\n```\n\n```js\n// 所以翻譯過後 redux api 的使用流程就會變成\nlet addReducer = (state, ADD_ACTION) => state++\nlet subtractReducer = (state, SUBTRACT_ACTION) => state--\n\ncounterContainer = Redux.container(\n  'counter', \n  0, \n  [addReducer, substractReducer]\n)\n\nRedux.addContainer(counterContainer)\n\nclass CounterComponent {\n  constructor(props) {\n    this.stateChangeListener = (state) => this.setState(state)\n    Redux.addListener(this.stateChangeListener)\n  }\n  componentWillMount() {\n    this.setState(Redux.getState().counter)\n  }\n  onAddButtonClick() {\n    Redux.dispatch(ADD_ACTION)\n  }\n  onSubtractButtonClick() {\n    Redux.dispatch(SUBSTRACT_ACTION)\n  }\n  ...\n} \n\n```\n\n總結，可以看出來 redux 最大的特點就是用 reducer 來定義 container state 的處理範圍，不能用 event callback 的概念去理解它，一個 reducer 對應到“一組” state、多個 actions。\n\n所以在 Redux 中 reducer 差不多是 container state scope 等價。也因此在 Redux 中 sub-container / sub-store 的名字完全被省略了，你只能用 reducer 的名字來找到他們影子。只要知道這個規則大概就能夠理解 Redux 了。\n\nreducer := (state, action) -> new_state (你找不到 container 的名字、它被省略了)\n\n老實說，我覺得這樣子的開發者經驗很不舒服 (bad UX)\n---\n不知道 re-frame 的 UX 會不會比較好？\n","source":"_posts/”redux-js-可預測的狀態容器“-的-API-使用說明.md","raw":"---\ntitle: ”redux.js --- 可預測的狀態容器“ 的 API 使用說明\ntags: []\ndate: 2016-04-10 15:58:00\n---\n\n這邊只會透過理解 Redux 的 API來簡介如何使用 Redux。這邊假設讀者都知道 web 中 event / listener 的 pattern。\n\n如果想要知道 redux 背後的實作細節、原理、動機、Flux、Design Pattern、如何和 UI App 做連結，請看 Dan 的 Redux gitbook、Redux tutorial on EggHead。\n\n**redux 是一個狀態容器 (state container / state machine)**\n\n狀態容器要提供幾個功能\n```js\n1. 初始容器狀態 _by Redux.createStore(**reducer**)_\n2. 取得現在的狀態 _by store.getState()_\n3. 狀態改變時，通知相關的程式 _by store.subscribe(**listener**)_\n3. 接收事件發生的通知、改變狀態 _by store.dispatch(**action**)_\n4. 建立之後改變事件處理方式 _by store.replaceReducer(**reducer**)_\n5. 由小的狀態容器組成全域狀態容器 _by 只能透過 combineReducers 來組成 root reducer，再用它來建全域狀態容器_\n```\n\nFlux 專有名詞：store、action、reducer。\n\nstore := 一個狀態容器\naction := 一個像 Event 一樣有 type 屬性的 javascript object\nreducer := 一個輸入 state 和 action、回傳新 state 的函數, (state, action) -> new_state\n\n但 store 是 redux 中唯一一個狀態容器的名字。其實 API 等同於下方這樣子\n```js\n1. _by Redux.createStore(**reducer**)_ 等於 _by Redux(**reducer**)_\n2. _by store.getState()_ 等於 _by Redux.getState()_\n3. _by store.subscribe(**listener**)_ 等於 _by Redux.addListener(**listener**)_\n3. _by store.dispatch(**action**)_ 等於 _by Redux.dispatch(**action**)_\n4. _by store.replaceReducer(**reducer**)_ 等於 _by Redux.replaceReducer(**reducer**)_\n5. _by 無直接 API，只能透過 combineReducers 來組成root reducer，然後用 root reducer 來建全域 store_\n```\n一個狀態容器 = 狀態 + reducer，但 reducer 中可以指定初始狀態、所以一個 reducer 其實可以定義一個狀態容器、等同於一個狀態容器，所以 API 等同於下方這樣子\n```js\n1. _by Redux.initContainer(**reducer**)_ 等於 _by Redux(**container**)_\n2. _by Redux.getState()_\n3. _by Redux.addListener(**listener**)_\n3. _by Redux.dispatch(**action**)_\n4. _by Redux.replaceReducer(**reducer**)_ 等於 _by Redux.container.replaceReducer(**container.reducer**)_\n5. _by 只能透過 combineReducers 來組成 root reducer，再用它來建全域狀態容器_ 等於 _Redux.combineContainer_\n```\n\n把 combineContainer 用 addContainer 取代，API 可以改寫成這樣子\n```js\n1. 初始容器狀態 _by Redux()_\n2. 取得現在的狀態 _by Redux.getState()_\n3. 狀態改變時，通知相關的程式 _by Redux.addListener(**listener**)_\n3. 接收事件發生的通知、改變狀態 _by Redux.dispatch(**action**)_\n4. 建立之後改變事件處理方式 _by Redux.getContainer(**name**).replaceReducer(reducer)_\n5. 由小的狀態容器組成全域狀態容器 _by Redux.addContainer(**container**)_\n6. 建立小的狀態容器 _by Redux.container(name, initialState, reducers)_\n```\n\n```js\n// 所以翻譯過後 redux api 的使用流程就會變成\nlet addReducer = (state, ADD_ACTION) => state++\nlet subtractReducer = (state, SUBTRACT_ACTION) => state--\n\ncounterContainer = Redux.container(\n  'counter', \n  0, \n  [addReducer, substractReducer]\n)\n\nRedux.addContainer(counterContainer)\n\nclass CounterComponent {\n  constructor(props) {\n    this.stateChangeListener = (state) => this.setState(state)\n    Redux.addListener(this.stateChangeListener)\n  }\n  componentWillMount() {\n    this.setState(Redux.getState().counter)\n  }\n  onAddButtonClick() {\n    Redux.dispatch(ADD_ACTION)\n  }\n  onSubtractButtonClick() {\n    Redux.dispatch(SUBSTRACT_ACTION)\n  }\n  ...\n} \n\n```\n\n總結，可以看出來 redux 最大的特點就是用 reducer 來定義 container state 的處理範圍，不能用 event callback 的概念去理解它，一個 reducer 對應到“一組” state、多個 actions。\n\n所以在 Redux 中 reducer 差不多是 container state scope 等價。也因此在 Redux 中 sub-container / sub-store 的名字完全被省略了，你只能用 reducer 的名字來找到他們影子。只要知道這個規則大概就能夠理解 Redux 了。\n\nreducer := (state, action) -> new_state (你找不到 container 的名字、它被省略了)\n\n老實說，我覺得這樣子的開發者經驗很不舒服 (bad UX)\n---\n不知道 re-frame 的 UX 會不會比較好？\n","slug":"”redux-js-可預測的狀態容器“-的-API-使用說明","published":1,"updated":"2017-12-25T02:19:53.075Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjblkzckp000exq9karvggcxq","content":"<p>這邊只會透過理解 Redux 的 API來簡介如何使用 Redux。這邊假設讀者都知道 web 中 event / listener 的 pattern。</p>\n<p>如果想要知道 redux 背後的實作細節、原理、動機、Flux、Design Pattern、如何和 UI App 做連結，請看 Dan 的 Redux gitbook、Redux tutorial on EggHead。</p>\n<p><strong>redux 是一個狀態容器 (state container / state machine)</strong></p>\n<p>狀態容器要提供幾個功能<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> 初始容器狀態 _by Redux.createStore(**reducer**)_</span><br><span class=\"line\"><span class=\"number\">2.</span> 取得現在的狀態 _by store.getState()_</span><br><span class=\"line\"><span class=\"number\">3.</span> 狀態改變時，通知相關的程式 _by store.subscribe(**listener**)_</span><br><span class=\"line\"><span class=\"number\">3.</span> 接收事件發生的通知、改變狀態 _by store.dispatch(**action**)_</span><br><span class=\"line\"><span class=\"number\">4.</span> 建立之後改變事件處理方式 _by store.replaceReducer(**reducer**)_</span><br><span class=\"line\"><span class=\"number\">5.</span> 由小的狀態容器組成全域狀態容器 _by 只能透過 combineReducers 來組成 root reducer，再用它來建全域狀態容器_</span><br></pre></td></tr></table></figure></p>\n<p>Flux 專有名詞：store、action、reducer。</p>\n<p>store := 一個狀態容器<br>action := 一個像 Event 一樣有 type 屬性的 javascript object<br>reducer := 一個輸入 state 和 action、回傳新 state 的函數, (state, action) -&gt; new_state</p>\n<p>但 store 是 redux 中唯一一個狀態容器的名字。其實 API 等同於下方這樣子<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> _by Redux.createStore(**reducer**)_ 等於 _by Redux(**reducer**)_</span><br><span class=\"line\"><span class=\"number\">2.</span> _by store.getState()_ 等於 _by Redux.getState()_</span><br><span class=\"line\"><span class=\"number\">3.</span> _by store.subscribe(**listener**)_ 等於 _by Redux.addListener(**listener**)_</span><br><span class=\"line\"><span class=\"number\">3.</span> _by store.dispatch(**action**)_ 等於 _by Redux.dispatch(**action**)_</span><br><span class=\"line\"><span class=\"number\">4.</span> _by store.replaceReducer(**reducer**)_ 等於 _by Redux.replaceReducer(**reducer**)_</span><br><span class=\"line\"><span class=\"number\">5.</span> _by 無直接 API，只能透過 combineReducers 來組成root reducer，然後用 root reducer 來建全域 store_</span><br></pre></td></tr></table></figure></p>\n<p>一個狀態容器 = 狀態 + reducer，但 reducer 中可以指定初始狀態、所以一個 reducer 其實可以定義一個狀態容器、等同於一個狀態容器，所以 API 等同於下方這樣子<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> _by Redux.initContainer(**reducer**)_ 等於 _by Redux(**container**)_</span><br><span class=\"line\"><span class=\"number\">2.</span> _by Redux.getState()_</span><br><span class=\"line\"><span class=\"number\">3.</span> _by Redux.addListener(**listener**)_</span><br><span class=\"line\"><span class=\"number\">3.</span> _by Redux.dispatch(**action**)_</span><br><span class=\"line\"><span class=\"number\">4.</span> _by Redux.replaceReducer(**reducer**)_ 等於 _by Redux.container.replaceReducer(**container.reducer**)_</span><br><span class=\"line\"><span class=\"number\">5.</span> _by 只能透過 combineReducers 來組成 root reducer，再用它來建全域狀態容器_ 等於 _Redux.combineContainer_</span><br></pre></td></tr></table></figure></p>\n<p>把 combineContainer 用 addContainer 取代，API 可以改寫成這樣子<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> 初始容器狀態 _by Redux()_</span><br><span class=\"line\"><span class=\"number\">2.</span> 取得現在的狀態 _by Redux.getState()_</span><br><span class=\"line\"><span class=\"number\">3.</span> 狀態改變時，通知相關的程式 _by Redux.addListener(**listener**)_</span><br><span class=\"line\"><span class=\"number\">3.</span> 接收事件發生的通知、改變狀態 _by Redux.dispatch(**action**)_</span><br><span class=\"line\"><span class=\"number\">4.</span> 建立之後改變事件處理方式 _by Redux.getContainer(**name**).replaceReducer(reducer)_</span><br><span class=\"line\"><span class=\"number\">5.</span> 由小的狀態容器組成全域狀態容器 _by Redux.addContainer(**container**)_</span><br><span class=\"line\"><span class=\"number\">6.</span> 建立小的狀態容器 _by Redux.container(name, initialState, reducers)_</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 所以翻譯過後 redux api 的使用流程就會變成</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> addReducer = <span class=\"function\">(<span class=\"params\">state, ADD_ACTION</span>) =&gt;</span> state++</span><br><span class=\"line\"><span class=\"keyword\">let</span> subtractReducer = <span class=\"function\">(<span class=\"params\">state, SUBTRACT_ACTION</span>) =&gt;</span> state--</span><br><span class=\"line\"></span><br><span class=\"line\">counterContainer = Redux.container(</span><br><span class=\"line\">  <span class=\"string\">'counter'</span>, </span><br><span class=\"line\">  <span class=\"number\">0</span>, </span><br><span class=\"line\">  [addReducer, substractReducer]</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">Redux.addContainer(counterContainer)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CounterComponent</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.stateChangeListener = <span class=\"function\">(<span class=\"params\">state</span>) =&gt;</span> <span class=\"keyword\">this</span>.setState(state)</span><br><span class=\"line\">    Redux.addListener(<span class=\"keyword\">this</span>.stateChangeListener)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  componentWillMount() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(Redux.getState().counter)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  onAddButtonClick() &#123;</span><br><span class=\"line\">    Redux.dispatch(ADD_ACTION)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  onSubtractButtonClick() &#123;</span><br><span class=\"line\">    Redux.dispatch(SUBSTRACT_ACTION)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>總結，可以看出來 redux 最大的特點就是用 reducer 來定義 container state 的處理範圍，不能用 event callback 的概念去理解它，一個 reducer 對應到“一組” state、多個 actions。</p>\n<p>所以在 Redux 中 reducer 差不多是 container state scope 等價。也因此在 Redux 中 sub-container / sub-store 的名字完全被省略了，你只能用 reducer 的名字來找到他們影子。只要知道這個規則大概就能夠理解 Redux 了。</p>\n<p>reducer := (state, action) -&gt; new_state (你找不到 container 的名字、它被省略了)</p>\n<h2 id=\"老實說，我覺得這樣子的開發者經驗很不舒服-bad-UX\"><a href=\"#老實說，我覺得這樣子的開發者經驗很不舒服-bad-UX\" class=\"headerlink\" title=\"老實說，我覺得這樣子的開發者經驗很不舒服 (bad UX)\"></a>老實說，我覺得這樣子的開發者經驗很不舒服 (bad UX)</h2><p>不知道 re-frame 的 UX 會不會比較好？</p>\n","site":{"data":{}},"excerpt":"","more":"<p>這邊只會透過理解 Redux 的 API來簡介如何使用 Redux。這邊假設讀者都知道 web 中 event / listener 的 pattern。</p>\n<p>如果想要知道 redux 背後的實作細節、原理、動機、Flux、Design Pattern、如何和 UI App 做連結，請看 Dan 的 Redux gitbook、Redux tutorial on EggHead。</p>\n<p><strong>redux 是一個狀態容器 (state container / state machine)</strong></p>\n<p>狀態容器要提供幾個功能<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> 初始容器狀態 _by Redux.createStore(**reducer**)_</span><br><span class=\"line\"><span class=\"number\">2.</span> 取得現在的狀態 _by store.getState()_</span><br><span class=\"line\"><span class=\"number\">3.</span> 狀態改變時，通知相關的程式 _by store.subscribe(**listener**)_</span><br><span class=\"line\"><span class=\"number\">3.</span> 接收事件發生的通知、改變狀態 _by store.dispatch(**action**)_</span><br><span class=\"line\"><span class=\"number\">4.</span> 建立之後改變事件處理方式 _by store.replaceReducer(**reducer**)_</span><br><span class=\"line\"><span class=\"number\">5.</span> 由小的狀態容器組成全域狀態容器 _by 只能透過 combineReducers 來組成 root reducer，再用它來建全域狀態容器_</span><br></pre></td></tr></table></figure></p>\n<p>Flux 專有名詞：store、action、reducer。</p>\n<p>store := 一個狀態容器<br>action := 一個像 Event 一樣有 type 屬性的 javascript object<br>reducer := 一個輸入 state 和 action、回傳新 state 的函數, (state, action) -&gt; new_state</p>\n<p>但 store 是 redux 中唯一一個狀態容器的名字。其實 API 等同於下方這樣子<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> _by Redux.createStore(**reducer**)_ 等於 _by Redux(**reducer**)_</span><br><span class=\"line\"><span class=\"number\">2.</span> _by store.getState()_ 等於 _by Redux.getState()_</span><br><span class=\"line\"><span class=\"number\">3.</span> _by store.subscribe(**listener**)_ 等於 _by Redux.addListener(**listener**)_</span><br><span class=\"line\"><span class=\"number\">3.</span> _by store.dispatch(**action**)_ 等於 _by Redux.dispatch(**action**)_</span><br><span class=\"line\"><span class=\"number\">4.</span> _by store.replaceReducer(**reducer**)_ 等於 _by Redux.replaceReducer(**reducer**)_</span><br><span class=\"line\"><span class=\"number\">5.</span> _by 無直接 API，只能透過 combineReducers 來組成root reducer，然後用 root reducer 來建全域 store_</span><br></pre></td></tr></table></figure></p>\n<p>一個狀態容器 = 狀態 + reducer，但 reducer 中可以指定初始狀態、所以一個 reducer 其實可以定義一個狀態容器、等同於一個狀態容器，所以 API 等同於下方這樣子<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> _by Redux.initContainer(**reducer**)_ 等於 _by Redux(**container**)_</span><br><span class=\"line\"><span class=\"number\">2.</span> _by Redux.getState()_</span><br><span class=\"line\"><span class=\"number\">3.</span> _by Redux.addListener(**listener**)_</span><br><span class=\"line\"><span class=\"number\">3.</span> _by Redux.dispatch(**action**)_</span><br><span class=\"line\"><span class=\"number\">4.</span> _by Redux.replaceReducer(**reducer**)_ 等於 _by Redux.container.replaceReducer(**container.reducer**)_</span><br><span class=\"line\"><span class=\"number\">5.</span> _by 只能透過 combineReducers 來組成 root reducer，再用它來建全域狀態容器_ 等於 _Redux.combineContainer_</span><br></pre></td></tr></table></figure></p>\n<p>把 combineContainer 用 addContainer 取代，API 可以改寫成這樣子<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> 初始容器狀態 _by Redux()_</span><br><span class=\"line\"><span class=\"number\">2.</span> 取得現在的狀態 _by Redux.getState()_</span><br><span class=\"line\"><span class=\"number\">3.</span> 狀態改變時，通知相關的程式 _by Redux.addListener(**listener**)_</span><br><span class=\"line\"><span class=\"number\">3.</span> 接收事件發生的通知、改變狀態 _by Redux.dispatch(**action**)_</span><br><span class=\"line\"><span class=\"number\">4.</span> 建立之後改變事件處理方式 _by Redux.getContainer(**name**).replaceReducer(reducer)_</span><br><span class=\"line\"><span class=\"number\">5.</span> 由小的狀態容器組成全域狀態容器 _by Redux.addContainer(**container**)_</span><br><span class=\"line\"><span class=\"number\">6.</span> 建立小的狀態容器 _by Redux.container(name, initialState, reducers)_</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 所以翻譯過後 redux api 的使用流程就會變成</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> addReducer = <span class=\"function\">(<span class=\"params\">state, ADD_ACTION</span>) =&gt;</span> state++</span><br><span class=\"line\"><span class=\"keyword\">let</span> subtractReducer = <span class=\"function\">(<span class=\"params\">state, SUBTRACT_ACTION</span>) =&gt;</span> state--</span><br><span class=\"line\"></span><br><span class=\"line\">counterContainer = Redux.container(</span><br><span class=\"line\">  <span class=\"string\">'counter'</span>, </span><br><span class=\"line\">  <span class=\"number\">0</span>, </span><br><span class=\"line\">  [addReducer, substractReducer]</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">Redux.addContainer(counterContainer)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CounterComponent</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.stateChangeListener = <span class=\"function\">(<span class=\"params\">state</span>) =&gt;</span> <span class=\"keyword\">this</span>.setState(state)</span><br><span class=\"line\">    Redux.addListener(<span class=\"keyword\">this</span>.stateChangeListener)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  componentWillMount() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(Redux.getState().counter)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  onAddButtonClick() &#123;</span><br><span class=\"line\">    Redux.dispatch(ADD_ACTION)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  onSubtractButtonClick() &#123;</span><br><span class=\"line\">    Redux.dispatch(SUBSTRACT_ACTION)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>總結，可以看出來 redux 最大的特點就是用 reducer 來定義 container state 的處理範圍，不能用 event callback 的概念去理解它，一個 reducer 對應到“一組” state、多個 actions。</p>\n<p>所以在 Redux 中 reducer 差不多是 container state scope 等價。也因此在 Redux 中 sub-container / sub-store 的名字完全被省略了，你只能用 reducer 的名字來找到他們影子。只要知道這個規則大概就能夠理解 Redux 了。</p>\n<p>reducer := (state, action) -&gt; new_state (你找不到 container 的名字、它被省略了)</p>\n<h2 id=\"老實說，我覺得這樣子的開發者經驗很不舒服-bad-UX\"><a href=\"#老實說，我覺得這樣子的開發者經驗很不舒服-bad-UX\" class=\"headerlink\" title=\"老實說，我覺得這樣子的開發者經驗很不舒服 (bad UX)\"></a>老實說，我覺得這樣子的開發者經驗很不舒服 (bad UX)</h2><p>不知道 re-frame 的 UX 會不會比較好？</p>\n"},{"title":"什麼是設計？","date":"2015-12-31T16:43:00.000Z","_content":"\n<div class=\"separator\" style=\"clear: both; text-align: center;\"><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><iframe allowfullscreen=\"\" class=\"YOUTUBE-iframe-video\" data-thumbnail-src=\"https://i.ytimg.com/vi/z8qs5-BDXNU/0.jpg\" frameborder=\"0\" height=\"266\" src=\"https://www.youtube.com/embed/z8qs5-BDXNU?feature=player_embedded\" width=\"320\"></iframe></span></div><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">&nbsp;[Design Q&amp;A by Charles Eames](http://www.scielo.cl/pdf/arq/n49/art11.pdf) 中譯</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 你對設計的定義是什麼？</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 人們可以將設計描述為安排元素來達到特定目的(purpose)的計畫。</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 設計是一種藝術的表現嗎？</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 我寧願說是一種目的的表現。它可以... 如果它足夠好，之後會被判斷為藝術。</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 設計是一種為了工業目的的工藝嗎？</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 不是，但是設計也許是某些工業問題的解。</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 設計的限界是什麼？</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 問題的限界是什麼，設計的限界就是什麼。</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 設計是只關注一部份環境(environment)的學科嗎？</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 不。</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 它是一種通用表達的方法嗎？(Is it a method of general expression?)</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 不，他是行動的方法。</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 它是一個人的創造物嗎？</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: &nbsp;不，事實上每個人都會受到前人的影響。</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 設計是團體的產物嗎？</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 通常是。</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 有設計倫理嗎？</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 設計總是有限制，通常也包含倫理這項。</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 設計意味著產品是有用處 (necessarily useful) 的嗎？</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 是的，即使用處可能很微小。</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 人們可以光為了樂趣的作品合作嗎？</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 誰會說樂趣是無用的？</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 設計的過程中要承認限制嗎？</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 設計和限制有很大的關係。</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 什麼是限制？</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 設計問題的有效關鍵：設計師能辨識出越多限制越好、他的對於這些限制一起工作的意願和熱情。限制像是金錢、大小、強度、平衡、表面材料、時間。每個問題都有它自己限制的列表。</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 設計是短暫的嗎？</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 有些需求是短暫的。大部份設計是短暫的。</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 該朝向短暫還是永恆的設計前進？</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 如果是一般性、通用的需求和設計，會朝向永久。</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 設計是為了誰？</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 需求。</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 你曾經被迫接受妥協嗎？</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 我從未被迫妥協，但我樂意接受限制。</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 練習設計的首要條件是？</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 辨認需求。(Recognition of the needs.)</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">看完影片大概知道，設計和目的、需求、問題、限制是息息相關的。</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">---</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">接下來看維基百科上對 &nbsp;Design 的定義。定義來自這篇 paper - [A Proposal for a Formal Definition of the Design Concept](http://paulralph.name/files/2011/01/Ralph-and-Wand-A-Proposal-for-a-Formal-Definition-of-the-Design-Concept.pdf)&nbsp;by Paul Ralph et. al.&nbsp;</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">他提出來的定義如下</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span>          \n<div class=\"page\" title=\"Page 6\"><div class=\"layoutArea\"><div class=\"column\"><span style=\"font-weight: 700;\"><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">Design </span></span>\n<span style=\"font-style: italic;\"><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">\n</span></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\"><span style=\"font-style: italic;\">(noun) </span>a <span style=\"color: #990000;\"><span style=\"font-style: italic;\">specification </span>of an <span style=\"font-style: italic;\">object</span></span>, manifested by an <span style=\"font-style: italic;\"><span style=\"color: #b45f06;\">agent</span></span>, intended to accomplish <span style=\"font-style: italic;\"><span style=\"color: #38761d;\">goals</span></span>, in a particular <span style=\"font-style: italic;\"><span style=\"color: #0b5394;\">environment</span></span>, using a set of <span style=\"font-style: italic;\"><span style=\"color: #351c75;\">primitive components</span></span>, satisfying a set of <span style=\"font-style: italic;\"><span style=\"color: #741b47;\">requirement</span></span><span style=\"color: #741b47;\">s</span>, subject to <span style=\"font-style: italic;\"><span style=\"color: #b45f06;\">constraints</span></span>; </span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">\n</span>      <span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\"><span style=\"font-style: italic;\">(verb, transitive) </span>to create a design, in an environment (where the de- signer operates)&nbsp;</span></div></div></div><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">看了應該不知道想表達什麼，所以他畫了張圖，這樣就清楚多了。</span>\n<div class=\"separator\" style=\"clear: both; text-align: center;\">[<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">![](https://1.bp.blogspot.com/-K0vsaB6GQhA/VoVUNkNudHI/AAAAAAAA3-M/vXrBqNi2RSk/s640/Screen%2BShot%2B2016-01-01%2Bat%2B12.12.58%2BAM.jpg)</span>](http://1.bp.blogspot.com/-K0vsaB6GQhA/VoVUNkNudHI/AAAAAAAA3-M/vXrBqNi2RSk/s1600/Screen%2BShot%2B2016-01-01%2Bat%2B12.12.58%2BAM.jpg)</div><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Agent 是設計的人。</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">產出(Output)：對某個物件的規範/規格</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">然後這個 Output，要完成某些目的 (Goals)、受到某些限制、滿足一些條件、產出在某個環境、由一些元素所組成。</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">舉例來說：</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">平面設計：指的是設計的的產出位在的環境是 2D 平面。</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">服務設計、字型設計、介面設計、使用者體驗設計、服裝設計：指的是它們的產出 (Specification of Object) 是什麼。</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">物件導向程式設計：指的是 primitive components 是物件、產出是程式。</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">使用者導向設計 (UCD)：指的是設計的產出的目的 (Goal) 和使用者有關。</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">作者進一步用動詞來看設計，畫了這個圖，清楚地標明什麼是設計這個動作的輸入 (Input) 和輸出 (Output)</span>\n<div class=\"separator\" style=\"clear: both; text-align: center;\">[<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">![](https://3.bp.blogspot.com/-mTegFAuq6xU/VoVWkm1N2pI/AAAAAAAA3-c/Djps-IbKZ2g/s640/Screen%2BShot%2B2016-01-01%2Bat%2B12.22.32%2BAM.jpg)</span>](http://3.bp.blogspot.com/-mTegFAuq6xU/VoVWkm1N2pI/AAAAAAAA3-c/Djps-IbKZ2g/s1600/Screen%2BShot%2B2016-01-01%2Bat%2B12.22.32%2BAM.jpg)</div><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">最後他又把這個圖改寫成設計的新定義</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span>          \n<div class=\"page\" title=\"Page 23\"><div class=\"layoutArea\"><div class=\"column\"><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">design activity as a <span style=\"font-style: italic;\"><span style=\"color: #0b5394;\">process</span></span>,&nbsp;</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">executed by an <span style=\"font-style: italic;\"><span style=\"color: #134f5c;\">agent</span></span>,&nbsp;</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">for the purpose of generating a <span style=\"color: #990000;\"><span style=\"font-style: italic;\">specification </span>of an </span><span style=\"font-style: italic;\"><span style=\"color: #990000;\">object</span> </span>based on:&nbsp;</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">&gt; the </span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-style: italic;\"><span style=\"color: #b45f06;\">environment</span> </span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">in which the object will exist,&nbsp;</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">&gt; the </span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-style: italic;\"><span style=\"color: #7f6000;\">goals</span> </span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">ascribed to the object,&nbsp;</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">&gt; the desired structural and behavioral properties of the object (</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-style: italic;\"><span style=\"color: #38761d;\">requirements</span></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">),&nbsp;</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">&gt; a given set of component types (</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-style: italic;\"><span style=\"color: #351c75;\">primitives</span></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">),&nbsp;</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">&gt; and </span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-style: italic;\"><span style=\"color: #741b47;\">constraints</span> </span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">that limit the acceptable solutions.&nbsp;</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">有沒有很複雜？簡單說 「設計活動就是在某些限制下，生出某個東西來達成某個目的的過程。」</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">好像在說廢話有沒有~~~ XD</span></div></div></div>","source":"_posts/什麼是設計？.md","raw":"---\ntitle: 什麼是設計？\ntags:\n  - design\ndate: 2016-01-01 00:43:00\n---\n\n<div class=\"separator\" style=\"clear: both; text-align: center;\"><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><iframe allowfullscreen=\"\" class=\"YOUTUBE-iframe-video\" data-thumbnail-src=\"https://i.ytimg.com/vi/z8qs5-BDXNU/0.jpg\" frameborder=\"0\" height=\"266\" src=\"https://www.youtube.com/embed/z8qs5-BDXNU?feature=player_embedded\" width=\"320\"></iframe></span></div><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">&nbsp;[Design Q&amp;A by Charles Eames](http://www.scielo.cl/pdf/arq/n49/art11.pdf) 中譯</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 你對設計的定義是什麼？</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 人們可以將設計描述為安排元素來達到特定目的(purpose)的計畫。</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 設計是一種藝術的表現嗎？</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 我寧願說是一種目的的表現。它可以... 如果它足夠好，之後會被判斷為藝術。</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 設計是一種為了工業目的的工藝嗎？</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 不是，但是設計也許是某些工業問題的解。</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 設計的限界是什麼？</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 問題的限界是什麼，設計的限界就是什麼。</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 設計是只關注一部份環境(environment)的學科嗎？</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 不。</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 它是一種通用表達的方法嗎？(Is it a method of general expression?)</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 不，他是行動的方法。</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 它是一個人的創造物嗎？</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: &nbsp;不，事實上每個人都會受到前人的影響。</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 設計是團體的產物嗎？</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 通常是。</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 有設計倫理嗎？</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 設計總是有限制，通常也包含倫理這項。</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 設計意味著產品是有用處 (necessarily useful) 的嗎？</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 是的，即使用處可能很微小。</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 人們可以光為了樂趣的作品合作嗎？</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 誰會說樂趣是無用的？</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 設計的過程中要承認限制嗎？</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 設計和限制有很大的關係。</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 什麼是限制？</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 設計問題的有效關鍵：設計師能辨識出越多限制越好、他的對於這些限制一起工作的意願和熱情。限制像是金錢、大小、強度、平衡、表面材料、時間。每個問題都有它自己限制的列表。</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 設計是短暫的嗎？</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 有些需求是短暫的。大部份設計是短暫的。</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 該朝向短暫還是永恆的設計前進？</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 如果是一般性、通用的需求和設計，會朝向永久。</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 設計是為了誰？</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 需求。</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 你曾經被迫接受妥協嗎？</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 我從未被迫妥協，但我樂意接受限制。</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 練習設計的首要條件是？</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 辨認需求。(Recognition of the needs.)</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">看完影片大概知道，設計和目的、需求、問題、限制是息息相關的。</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">---</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">接下來看維基百科上對 &nbsp;Design 的定義。定義來自這篇 paper - [A Proposal for a Formal Definition of the Design Concept](http://paulralph.name/files/2011/01/Ralph-and-Wand-A-Proposal-for-a-Formal-Definition-of-the-Design-Concept.pdf)&nbsp;by Paul Ralph et. al.&nbsp;</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">他提出來的定義如下</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span>          \n<div class=\"page\" title=\"Page 6\"><div class=\"layoutArea\"><div class=\"column\"><span style=\"font-weight: 700;\"><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">Design </span></span>\n<span style=\"font-style: italic;\"><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">\n</span></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\"><span style=\"font-style: italic;\">(noun) </span>a <span style=\"color: #990000;\"><span style=\"font-style: italic;\">specification </span>of an <span style=\"font-style: italic;\">object</span></span>, manifested by an <span style=\"font-style: italic;\"><span style=\"color: #b45f06;\">agent</span></span>, intended to accomplish <span style=\"font-style: italic;\"><span style=\"color: #38761d;\">goals</span></span>, in a particular <span style=\"font-style: italic;\"><span style=\"color: #0b5394;\">environment</span></span>, using a set of <span style=\"font-style: italic;\"><span style=\"color: #351c75;\">primitive components</span></span>, satisfying a set of <span style=\"font-style: italic;\"><span style=\"color: #741b47;\">requirement</span></span><span style=\"color: #741b47;\">s</span>, subject to <span style=\"font-style: italic;\"><span style=\"color: #b45f06;\">constraints</span></span>; </span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">\n</span>      <span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\"><span style=\"font-style: italic;\">(verb, transitive) </span>to create a design, in an environment (where the de- signer operates)&nbsp;</span></div></div></div><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">看了應該不知道想表達什麼，所以他畫了張圖，這樣就清楚多了。</span>\n<div class=\"separator\" style=\"clear: both; text-align: center;\">[<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">![](https://1.bp.blogspot.com/-K0vsaB6GQhA/VoVUNkNudHI/AAAAAAAA3-M/vXrBqNi2RSk/s640/Screen%2BShot%2B2016-01-01%2Bat%2B12.12.58%2BAM.jpg)</span>](http://1.bp.blogspot.com/-K0vsaB6GQhA/VoVUNkNudHI/AAAAAAAA3-M/vXrBqNi2RSk/s1600/Screen%2BShot%2B2016-01-01%2Bat%2B12.12.58%2BAM.jpg)</div><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Agent 是設計的人。</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">產出(Output)：對某個物件的規範/規格</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">然後這個 Output，要完成某些目的 (Goals)、受到某些限制、滿足一些條件、產出在某個環境、由一些元素所組成。</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">舉例來說：</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">平面設計：指的是設計的的產出位在的環境是 2D 平面。</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">服務設計、字型設計、介面設計、使用者體驗設計、服裝設計：指的是它們的產出 (Specification of Object) 是什麼。</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">物件導向程式設計：指的是 primitive components 是物件、產出是程式。</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">使用者導向設計 (UCD)：指的是設計的產出的目的 (Goal) 和使用者有關。</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">作者進一步用動詞來看設計，畫了這個圖，清楚地標明什麼是設計這個動作的輸入 (Input) 和輸出 (Output)</span>\n<div class=\"separator\" style=\"clear: both; text-align: center;\">[<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">![](https://3.bp.blogspot.com/-mTegFAuq6xU/VoVWkm1N2pI/AAAAAAAA3-c/Djps-IbKZ2g/s640/Screen%2BShot%2B2016-01-01%2Bat%2B12.22.32%2BAM.jpg)</span>](http://3.bp.blogspot.com/-mTegFAuq6xU/VoVWkm1N2pI/AAAAAAAA3-c/Djps-IbKZ2g/s1600/Screen%2BShot%2B2016-01-01%2Bat%2B12.22.32%2BAM.jpg)</div><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">最後他又把這個圖改寫成設計的新定義</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">\n</span>          \n<div class=\"page\" title=\"Page 23\"><div class=\"layoutArea\"><div class=\"column\"><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">design activity as a <span style=\"font-style: italic;\"><span style=\"color: #0b5394;\">process</span></span>,&nbsp;</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">executed by an <span style=\"font-style: italic;\"><span style=\"color: #134f5c;\">agent</span></span>,&nbsp;</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">for the purpose of generating a <span style=\"color: #990000;\"><span style=\"font-style: italic;\">specification </span>of an </span><span style=\"font-style: italic;\"><span style=\"color: #990000;\">object</span> </span>based on:&nbsp;</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">&gt; the </span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-style: italic;\"><span style=\"color: #b45f06;\">environment</span> </span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">in which the object will exist,&nbsp;</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">&gt; the </span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-style: italic;\"><span style=\"color: #7f6000;\">goals</span> </span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">ascribed to the object,&nbsp;</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">&gt; the desired structural and behavioral properties of the object (</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-style: italic;\"><span style=\"color: #38761d;\">requirements</span></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">),&nbsp;</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">&gt; a given set of component types (</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-style: italic;\"><span style=\"color: #351c75;\">primitives</span></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">),&nbsp;</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">&gt; and </span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-style: italic;\"><span style=\"color: #741b47;\">constraints</span> </span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">that limit the acceptable solutions.&nbsp;</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">\n</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">有沒有很複雜？簡單說 「設計活動就是在某些限制下，生出某個東西來達成某個目的的過程。」</span>\n<span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">好像在說廢話有沒有~~~ XD</span></div></div></div>","slug":"什麼是設計？","published":1,"updated":"2017-12-23T06:08:08.298Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjblkzckr000gxq9kg6gcqov4","content":"<div class=\"separator\" style=\"clear: both; text-align: center;\"><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><iframe allowfullscreen class=\"YOUTUBE-iframe-video\" data-thumbnail-src=\"https://i.ytimg.com/vi/z8qs5-BDXNU/0.jpg\" frameborder=\"0\" height=\"266\" src=\"https://www.youtube.com/embed/z8qs5-BDXNU?feature=player_embedded\" width=\"320\"></iframe></span></div><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">&nbsp;<a href=\"http://www.scielo.cl/pdf/arq/n49/art11.pdf\" target=\"_blank\" rel=\"noopener\">Design Q&amp;A by Charles Eames</a> 中譯</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 你對設計的定義是什麼？</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 人們可以將設計描述為安排元素來達到特定目的(purpose)的計畫。</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 設計是一種藝術的表現嗎？</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 我寧願說是一種目的的表現。它可以… 如果它足夠好，之後會被判斷為藝術。</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 設計是一種為了工業目的的工藝嗎？</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 不是，但是設計也許是某些工業問題的解。</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 設計的限界是什麼？</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 問題的限界是什麼，設計的限界就是什麼。</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 設計是只關注一部份環境(environment)的學科嗎？</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 不。</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 它是一種通用表達的方法嗎？(Is it a method of general expression?)</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 不，他是行動的方法。</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 它是一個人的創造物嗎？</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: &nbsp;不，事實上每個人都會受到前人的影響。</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 設計是團體的產物嗎？</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 通常是。</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 有設計倫理嗎？</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 設計總是有限制，通常也包含倫理這項。</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 設計意味著產品是有用處 (necessarily useful) 的嗎？</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 是的，即使用處可能很微小。</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 人們可以光為了樂趣的作品合作嗎？</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 誰會說樂趣是無用的？</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 設計的過程中要承認限制嗎？</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 設計和限制有很大的關係。</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 什麼是限制？</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 設計問題的有效關鍵：設計師能辨識出越多限制越好、他的對於這些限制一起工作的意願和熱情。限制像是金錢、大小、強度、平衡、表面材料、時間。每個問題都有它自己限制的列表。</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 設計是短暫的嗎？</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 有些需求是短暫的。大部份設計是短暫的。</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 該朝向短暫還是永恆的設計前進？</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 如果是一般性、通用的需求和設計，會朝向永久。</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 設計是為了誰？</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 需求。</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 你曾經被迫接受妥協嗎？</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 我從未被迫妥協，但我樂意接受限制。</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 練習設計的首要條件是？</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 辨認需求。(Recognition of the needs.)</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">看完影片大概知道，設計和目的、需求、問題、限制是息息相關的。</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">—</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">接下來看維基百科上對 &nbsp;Design 的定義。定義來自這篇 paper - <a href=\"http://paulralph.name/files/2011/01/Ralph-and-Wand-A-Proposal-for-a-Formal-Definition-of-the-Design-Concept.pdf\" target=\"_blank\" rel=\"noopener\">A Proposal for a Formal Definition of the Design Concept</a>&nbsp;by Paul Ralph et. al.&nbsp;</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">他提出來的定義如下</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><br><div class=\"page\" title=\"Page 6\"><div class=\"layoutArea\"><div class=\"column\"><span style=\"font-weight: 700;\"><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">Design </span></span><br><span style=\"font-style: italic;\"><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\"><br></span></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\"><span style=\"font-style: italic;\">(noun) </span>a <span style=\"color: #990000;\"><span style=\"font-style: italic;\">specification </span>of an <span style=\"font-style: italic;\">object</span></span>, manifested by an <span style=\"font-style: italic;\"><span style=\"color: #b45f06;\">agent</span></span>, intended to accomplish <span style=\"font-style: italic;\"><span style=\"color: #38761d;\">goals</span></span>, in a particular <span style=\"font-style: italic;\"><span style=\"color: #0b5394;\">environment</span></span>, using a set of <span style=\"font-style: italic;\"><span style=\"color: #351c75;\">primitive components</span></span>, satisfying a set of <span style=\"font-style: italic;\"><span style=\"color: #741b47;\">requirement</span></span><span style=\"color: #741b47;\">s</span>, subject to <span style=\"font-style: italic;\"><span style=\"color: #b45f06;\">constraints</span></span>; </span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\"><br></span>      <span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\"><span style=\"font-style: italic;\">(verb, transitive) </span>to create a design, in an environment (where the de- signer operates)&nbsp;</span></div></div></div><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">看了應該不知道想表達什麼，所以他畫了張圖，這樣就清楚多了。</span><br><div class=\"separator\" style=\"clear: both; text-align: center;\"><a href=\"http://1.bp.blogspot.com/-K0vsaB6GQhA/VoVUNkNudHI/AAAAAAAA3-M/vXrBqNi2RSk/s1600/Screen%2BShot%2B2016-01-01%2Bat%2B12.12.58%2BAM.jpg\" target=\"_blank\" rel=\"noopener\"><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><img src=\"https://1.bp.blogspot.com/-K0vsaB6GQhA/VoVUNkNudHI/AAAAAAAA3-M/vXrBqNi2RSk/s640/Screen%2BShot%2B2016-01-01%2Bat%2B12.12.58%2BAM.jpg\" alt=\"\"></span></a></div><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Agent 是設計的人。</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">產出(Output)：對某個物件的規範/規格</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">然後這個 Output，要完成某些目的 (Goals)、受到某些限制、滿足一些條件、產出在某個環境、由一些元素所組成。</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">舉例來說：</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">平面設計：指的是設計的的產出位在的環境是 2D 平面。</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">服務設計、字型設計、介面設計、使用者體驗設計、服裝設計：指的是它們的產出 (Specification of Object) 是什麼。</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">物件導向程式設計：指的是 primitive components 是物件、產出是程式。</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">使用者導向設計 (UCD)：指的是設計的產出的目的 (Goal) 和使用者有關。</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">作者進一步用動詞來看設計，畫了這個圖，清楚地標明什麼是設計這個動作的輸入 (Input) 和輸出 (Output)</span><br><div class=\"separator\" style=\"clear: both; text-align: center;\"><a href=\"http://3.bp.blogspot.com/-mTegFAuq6xU/VoVWkm1N2pI/AAAAAAAA3-c/Djps-IbKZ2g/s1600/Screen%2BShot%2B2016-01-01%2Bat%2B12.22.32%2BAM.jpg\" target=\"_blank\" rel=\"noopener\"><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><img src=\"https://3.bp.blogspot.com/-mTegFAuq6xU/VoVWkm1N2pI/AAAAAAAA3-c/Djps-IbKZ2g/s640/Screen%2BShot%2B2016-01-01%2Bat%2B12.22.32%2BAM.jpg\" alt=\"\"></span></a></div><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">最後他又把這個圖改寫成設計的新定義</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><br><div class=\"page\" title=\"Page 23\"><div class=\"layoutArea\"><div class=\"column\"><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">design activity as a <span style=\"font-style: italic;\"><span style=\"color: #0b5394;\">process</span></span>,&nbsp;</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">executed by an <span style=\"font-style: italic;\"><span style=\"color: #134f5c;\">agent</span></span>,&nbsp;</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">for the purpose of generating a <span style=\"color: #990000;\"><span style=\"font-style: italic;\">specification </span>of an </span><span style=\"font-style: italic;\"><span style=\"color: #990000;\">object</span> </span>based on:&nbsp;</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">&gt; the </span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-style: italic;\"><span style=\"color: #b45f06;\">environment</span> </span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">in which the object will exist,&nbsp;</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">&gt; the </span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-style: italic;\"><span style=\"color: #7f6000;\">goals</span> </span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">ascribed to the object,&nbsp;</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">&gt; the desired structural and behavioral properties of the object (</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-style: italic;\"><span style=\"color: #38761d;\">requirements</span></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">),&nbsp;</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">&gt; a given set of component types (</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-style: italic;\"><span style=\"color: #351c75;\">primitives</span></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">),&nbsp;</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">&gt; and </span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-style: italic;\"><span style=\"color: #741b47;\">constraints</span> </span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">that limit the acceptable solutions.&nbsp;</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">有沒有很複雜？簡單說 「設計活動就是在某些限制下，生出某個東西來達成某個目的的過程。」</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">好像在說廢話有沒有~~~ XD</span></div></div></div>","site":{"data":{}},"excerpt":"","more":"<div class=\"separator\" style=\"clear: both; text-align: center;\"><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><iframe allowfullscreen class=\"YOUTUBE-iframe-video\" data-thumbnail-src=\"https://i.ytimg.com/vi/z8qs5-BDXNU/0.jpg\" frameborder=\"0\" height=\"266\" src=\"https://www.youtube.com/embed/z8qs5-BDXNU?feature=player_embedded\" width=\"320\"></iframe></span></div><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">&nbsp;<a href=\"http://www.scielo.cl/pdf/arq/n49/art11.pdf\" target=\"_blank\" rel=\"noopener\">Design Q&amp;A by Charles Eames</a> 中譯</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 你對設計的定義是什麼？</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 人們可以將設計描述為安排元素來達到特定目的(purpose)的計畫。</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 設計是一種藝術的表現嗎？</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 我寧願說是一種目的的表現。它可以… 如果它足夠好，之後會被判斷為藝術。</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 設計是一種為了工業目的的工藝嗎？</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 不是，但是設計也許是某些工業問題的解。</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 設計的限界是什麼？</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 問題的限界是什麼，設計的限界就是什麼。</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 設計是只關注一部份環境(environment)的學科嗎？</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 不。</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 它是一種通用表達的方法嗎？(Is it a method of general expression?)</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 不，他是行動的方法。</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 它是一個人的創造物嗎？</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: &nbsp;不，事實上每個人都會受到前人的影響。</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 設計是團體的產物嗎？</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 通常是。</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 有設計倫理嗎？</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 設計總是有限制，通常也包含倫理這項。</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 設計意味著產品是有用處 (necessarily useful) 的嗎？</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 是的，即使用處可能很微小。</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 人們可以光為了樂趣的作品合作嗎？</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 誰會說樂趣是無用的？</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 設計的過程中要承認限制嗎？</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 設計和限制有很大的關係。</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 什麼是限制？</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 設計問題的有效關鍵：設計師能辨識出越多限制越好、他的對於這些限制一起工作的意願和熱情。限制像是金錢、大小、強度、平衡、表面材料、時間。每個問題都有它自己限制的列表。</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 設計是短暫的嗎？</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 有些需求是短暫的。大部份設計是短暫的。</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 該朝向短暫還是永恆的設計前進？</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 如果是一般性、通用的需求和設計，會朝向永久。</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 設計是為了誰？</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 需求。</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 你曾經被迫接受妥協嗎？</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 我從未被迫妥協，但我樂意接受限制。</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Q: 練習設計的首要條件是？</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">A: 辨認需求。(Recognition of the needs.)</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">看完影片大概知道，設計和目的、需求、問題、限制是息息相關的。</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">—</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">接下來看維基百科上對 &nbsp;Design 的定義。定義來自這篇 paper - <a href=\"http://paulralph.name/files/2011/01/Ralph-and-Wand-A-Proposal-for-a-Formal-Definition-of-the-Design-Concept.pdf\" target=\"_blank\" rel=\"noopener\">A Proposal for a Formal Definition of the Design Concept</a>&nbsp;by Paul Ralph et. al.&nbsp;</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">他提出來的定義如下</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><br><div class=\"page\" title=\"Page 6\"><div class=\"layoutArea\"><div class=\"column\"><span style=\"font-weight: 700;\"><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">Design </span></span><br><span style=\"font-style: italic;\"><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\"><br></span></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\"><span style=\"font-style: italic;\">(noun) </span>a <span style=\"color: #990000;\"><span style=\"font-style: italic;\">specification </span>of an <span style=\"font-style: italic;\">object</span></span>, manifested by an <span style=\"font-style: italic;\"><span style=\"color: #b45f06;\">agent</span></span>, intended to accomplish <span style=\"font-style: italic;\"><span style=\"color: #38761d;\">goals</span></span>, in a particular <span style=\"font-style: italic;\"><span style=\"color: #0b5394;\">environment</span></span>, using a set of <span style=\"font-style: italic;\"><span style=\"color: #351c75;\">primitive components</span></span>, satisfying a set of <span style=\"font-style: italic;\"><span style=\"color: #741b47;\">requirement</span></span><span style=\"color: #741b47;\">s</span>, subject to <span style=\"font-style: italic;\"><span style=\"color: #b45f06;\">constraints</span></span>; </span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\"><br></span>      <span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\"><span style=\"font-style: italic;\">(verb, transitive) </span>to create a design, in an environment (where the de- signer operates)&nbsp;</span></div></div></div><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">看了應該不知道想表達什麼，所以他畫了張圖，這樣就清楚多了。</span><br><div class=\"separator\" style=\"clear: both; text-align: center;\"><a href=\"http://1.bp.blogspot.com/-K0vsaB6GQhA/VoVUNkNudHI/AAAAAAAA3-M/vXrBqNi2RSk/s1600/Screen%2BShot%2B2016-01-01%2Bat%2B12.12.58%2BAM.jpg\" target=\"_blank\" rel=\"noopener\"><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><img src=\"https://1.bp.blogspot.com/-K0vsaB6GQhA/VoVUNkNudHI/AAAAAAAA3-M/vXrBqNi2RSk/s640/Screen%2BShot%2B2016-01-01%2Bat%2B12.12.58%2BAM.jpg\" alt=\"\"></span></a></div><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">Agent 是設計的人。</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">產出(Output)：對某個物件的規範/規格</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">然後這個 Output，要完成某些目的 (Goals)、受到某些限制、滿足一些條件、產出在某個環境、由一些元素所組成。</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">舉例來說：</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">平面設計：指的是設計的的產出位在的環境是 2D 平面。</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">服務設計、字型設計、介面設計、使用者體驗設計、服裝設計：指的是它們的產出 (Specification of Object) 是什麼。</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">物件導向程式設計：指的是 primitive components 是物件、產出是程式。</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">使用者導向設計 (UCD)：指的是設計的產出的目的 (Goal) 和使用者有關。</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">作者進一步用動詞來看設計，畫了這個圖，清楚地標明什麼是設計這個動作的輸入 (Input) 和輸出 (Output)</span><br><div class=\"separator\" style=\"clear: both; text-align: center;\"><a href=\"http://3.bp.blogspot.com/-mTegFAuq6xU/VoVWkm1N2pI/AAAAAAAA3-c/Djps-IbKZ2g/s1600/Screen%2BShot%2B2016-01-01%2Bat%2B12.22.32%2BAM.jpg\" target=\"_blank\" rel=\"noopener\"><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><img src=\"https://3.bp.blogspot.com/-mTegFAuq6xU/VoVWkm1N2pI/AAAAAAAA3-c/Djps-IbKZ2g/s640/Screen%2BShot%2B2016-01-01%2Bat%2B12.22.32%2BAM.jpg\" alt=\"\"></span></a></div><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">最後他又把這個圖改寫成設計的新定義</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\"><br></span><br><div class=\"page\" title=\"Page 23\"><div class=\"layoutArea\"><div class=\"column\"><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">design activity as a <span style=\"font-style: italic;\"><span style=\"color: #0b5394;\">process</span></span>,&nbsp;</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">executed by an <span style=\"font-style: italic;\"><span style=\"color: #134f5c;\">agent</span></span>,&nbsp;</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">for the purpose of generating a <span style=\"color: #990000;\"><span style=\"font-style: italic;\">specification </span>of an </span><span style=\"font-style: italic;\"><span style=\"color: #990000;\">object</span> </span>based on:&nbsp;</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">&gt; the </span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-style: italic;\"><span style=\"color: #b45f06;\">environment</span> </span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">in which the object will exist,&nbsp;</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">&gt; the </span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-style: italic;\"><span style=\"color: #7f6000;\">goals</span> </span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">ascribed to the object,&nbsp;</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">&gt; the desired structural and behavioral properties of the object (</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-style: italic;\"><span style=\"color: #38761d;\">requirements</span></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">),&nbsp;</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">&gt; a given set of component types (</span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-style: italic;\"><span style=\"color: #351c75;\">primitives</span></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">),&nbsp;</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">&gt; and </span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-style: italic;\"><span style=\"color: #741b47;\">constraints</span> </span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\">that limit the acceptable solutions.&nbsp;</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;\"><br></span><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">有沒有很複雜？簡單說 「設計活動就是在某些限制下，生出某個東西來達成某個目的的過程。」</span><br><span style=\"font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;\">好像在說廢話有沒有~~~ XD</span></div></div></div>"},{"title":"介紹 React.js (2013 by Facebook )","date":"2015-11-05T11:04:00.000Z","_content":"\n<div class=\"separator\" style=\"clear: both; text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><iframe allowfullscreen=\"\" class=\"YOUTUBE-iframe-video\" data-thumbnail-src=\"https://i.ytimg.com/vi/XxVg_s8xAms/0.jpg\" frameborder=\"0\" height=\"266\" src=\"https://www.youtube.com/embed/XxVg_s8xAms?feature=player_embedded\" width=\"320\"></iframe></span></div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Introduction to React.js by Tom Occhino and Jordan Walke</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">整個React.js的由來是很多Facebook內部對一個問題的討論。這個問題是 **<u>開發Javacript的應用時，它的結構應該是如何？&nbsp;</u>**( \" How should we structure a javascript application? \" )。特別是瀏覽器端的 Javascript 應用。前人透過各式各樣的 framework 提出一大堆的解答。這些 framework 通常試著去實踐 MVC, MVVM, MVW 各種概念。這些架構或 framework 共同點就是 M，也就是 Model... 基本就只是一種可觀察的物件 ( observable object )，然後這些可觀察的物件有一些Event API，讓你訂閱物件改變的通知 ( subscribe changes )。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">實際上發生的事 是開發者建立了這些雙向資料綁定 ( bi-directional data-binding )，讓你可以訂閱物件改變的通知。當某個東西改變了，你就可以變動 ( mutate ) / 更新你的 View。但這種觀察模式 ( observation pattern ) 實際上鼓勵 UI 的變動 ( mutation )。每次先把元件畫出來，然後當改變發生時，就試著更新之前畫出來的 UI 元件。這邊的關鍵字是變動 ( mutation )。**變動 ( mutation ) 是複雜的。**大概兩年半前，Facebook試著重寫聊天室。我們試著把事情變簡單，試著把開發者要處理的變異 ( mutation ) 減到最少。讓我來解釋一下那是什麼意思，下面是一個簡單應用的架構：</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span>\n<div class=\"separator\" style=\"clear: both; text-align: center;\">[<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">![](http://2.bp.blogspot.com/-PorkT6ZQGj0/VjsVKyXT1DI/AAAAAAAA35M/1-KLZL7tYfs/s400/Screen%2BShot%2B2015-11-05%2Bat%2B4.36.02%2BPM.jpg)</span>](http://2.bp.blogspot.com/-PorkT6ZQGj0/VjsVKyXT1DI/AAAAAAAA35M/1-KLZL7tYfs/s1600/Screen%2BShot%2B2015-11-05%2Bat%2B4.36.02%2BPM.jpg)</div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">要注意到的一件事是 在這個系統中的所有更新 ( updates ) 都會走一個單一的通道 ( go through a single channel )。它們都朝著單一方向流動，讓我們叫它 單向資料綁定 ( one directional data-binding )。所有輸入到這個系統的更新，不管是來自使用者輸入、即時的server updates或是起始的Loading。這些所有的更新都只透過單向的流動，不管怎樣最後都會流到 View 方格那裏。這一塊是所有前端工程師，我最關心的地方... 對嗎? 我關心使用者經驗、使用者真正看到和接觸的地方。**概念上來說，我們發現建造這一塊 / View 最簡單的方式就是避免變異 ( mutation )。**基本上是完全避免變異。我們發現，如果每次更新發生我們可以把整個&nbsp;**View 砍掉，整個重繪**，那會變得超簡單。因為這樣，**你只要寫怎麼把 View 畫出來就好，不用管 View 怎麼更新的程式碼。**</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">但這樣亂搞，可行嗎？</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">從瀏覽器的角度來看這一定會很慢，記憶體還會不夠之類的。但概念上來說 ( conceptually )，我們還是想要用這個Model。因為每次更新就重繪真的很方便，但前提是要速度可行和還是能給使用者好的經驗。我們提出來的解法就是React.js。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">React：一個為了建立使用者介面的Javascript程式庫。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">我們想要所有來自 **更新就重繪這理念** 好的部分，但避免其中壞的副作用 ( bad performance &amp; bad ux )。從此之後你不用管你的應用中從 state a -&gt; state b -&gt; state c，只剩下 零 -&gt; 畫出來。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">React 的核心是宣告元件 ( Declarative components )：</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">在任何時間點都只要描述你的元件長什麼樣子，這不只是一個樣板 ( template )，這不是呼叫一個函式然後回傳一段字串那種事。因為那樣的話，你要整個 DOM 砍掉，然後把新的 HTML 掛上去。元件實際上是可重複使用的 API，封裝了一大堆東西，像是 markup、這東西看起來怎樣、它的功能是什麼、它的行為、CSS、Javascript 和這些東西的結構是什麼，是這些全部的東西。對於使用者元件隱藏了實作的細節，讓我給你一個實例：</span>\n<table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"><tbody><tr><td style=\"text-align: center;\">[<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">![](http://3.bp.blogspot.com/-IILmalknzQ4/VjsfYKsVFrI/AAAAAAAA35c/7SNGkiIPlWQ/s320/Screen%2BShot%2B2015-11-05%2Bat%2B5.20.09%2BPM.jpg)</span>](http://3.bp.blogspot.com/-IILmalknzQ4/VjsfYKsVFrI/AAAAAAAA35c/7SNGkiIPlWQ/s1600/Screen%2BShot%2B2015-11-05%2Bat%2B5.20.09%2BPM.jpg)</td></tr><tr><td class=\"tr-caption\" style=\"text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">輸入元件：提供互動的 auto-complete search box，只要用跟原始 HTML &lt;input&gt; 一樣多的程式碼。然後我應該可以對她註冊事件、設定它的行為 ( behavior ) 有哪些。</span></td></tr></tbody></table><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">No explicit data binding：不像 AngularJS，React 不需要實際上 Wire 你的 View 到你的 Model，你只要說哪一個屬性 ( property ) 你的 Model 想要在你的 View 中使用，然後當 Model 改變時、你的 View 就會被更新。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">它是怎麼運作的? ( How does it work? ) 我們這邊說兩件事。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">1) 它一開始是如何畫出來的。 ( Initial Render )</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">2) 更新是如何發生的。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Initial Render：在 React 我們只找一個 render function，這個 render function 完美的地方是它一直能告訴你這元件在任何時間的樣子。你提供的這個 render function 不會回傳一個字串，它回傳的是你的 View 的表現 ( representation ) ，我們做的事是... 既然元件可以由其他元件組成 &nbsp;( composited by other components )，我們遞迴的呼叫render來建立UI架構。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Two Pass Rendering：</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">1\\. 先建立 markup</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">2\\. 在最上層用 Event Delegation 附加上事件處理器</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">因為步驟一，先把元件畫出來，我們可以做 Server-side Rendering。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">更新是如何發生的？</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">我們不稱這個動作為<strike>Update</strike>，我們叫它 一致 ( reconciliation )。它的目的是保持你的 UI 元件 新鮮、當資料變化時自動更新。每個人應該現在都感到懷疑，如果不懷疑你大概剛剛都在睡覺。但你應該記得剛剛說的 Initial Rendering function，任何時間點它要回傳一個元件的表現 ( representation )。當改變發生時，我們重新呼叫一次 Render，然後比較原來 Render 的結果和改變過後 Render的結果，計算出兩個時間點元件的差別 ( diff )。接著批次計算出最少的變動量，然後一次 把變動更新到 DOM Tree 上面。所以很快。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">---</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">12:20 開始 Show Code Sample 和 JSX 語法</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp; &nbsp;程式碼還是看影片比較清楚... XD</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">26分開始大概一小時的Q &amp; A 還蠻精彩的~~~</span>","source":"_posts/介紹-React-js-2013-by-Facebook.md","raw":"---\ntitle: 介紹 React.js (2013 by Facebook )\ntags:\n  - facebook\n  - react\ndate: 2015-11-05 19:04:00\n---\n\n<div class=\"separator\" style=\"clear: both; text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><iframe allowfullscreen=\"\" class=\"YOUTUBE-iframe-video\" data-thumbnail-src=\"https://i.ytimg.com/vi/XxVg_s8xAms/0.jpg\" frameborder=\"0\" height=\"266\" src=\"https://www.youtube.com/embed/XxVg_s8xAms?feature=player_embedded\" width=\"320\"></iframe></span></div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Introduction to React.js by Tom Occhino and Jordan Walke</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">整個React.js的由來是很多Facebook內部對一個問題的討論。這個問題是 **<u>開發Javacript的應用時，它的結構應該是如何？&nbsp;</u>**( \" How should we structure a javascript application? \" )。特別是瀏覽器端的 Javascript 應用。前人透過各式各樣的 framework 提出一大堆的解答。這些 framework 通常試著去實踐 MVC, MVVM, MVW 各種概念。這些架構或 framework 共同點就是 M，也就是 Model... 基本就只是一種可觀察的物件 ( observable object )，然後這些可觀察的物件有一些Event API，讓你訂閱物件改變的通知 ( subscribe changes )。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">實際上發生的事 是開發者建立了這些雙向資料綁定 ( bi-directional data-binding )，讓你可以訂閱物件改變的通知。當某個東西改變了，你就可以變動 ( mutate ) / 更新你的 View。但這種觀察模式 ( observation pattern ) 實際上鼓勵 UI 的變動 ( mutation )。每次先把元件畫出來，然後當改變發生時，就試著更新之前畫出來的 UI 元件。這邊的關鍵字是變動 ( mutation )。**變動 ( mutation ) 是複雜的。**大概兩年半前，Facebook試著重寫聊天室。我們試著把事情變簡單，試著把開發者要處理的變異 ( mutation ) 減到最少。讓我來解釋一下那是什麼意思，下面是一個簡單應用的架構：</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span>\n<div class=\"separator\" style=\"clear: both; text-align: center;\">[<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">![](http://2.bp.blogspot.com/-PorkT6ZQGj0/VjsVKyXT1DI/AAAAAAAA35M/1-KLZL7tYfs/s400/Screen%2BShot%2B2015-11-05%2Bat%2B4.36.02%2BPM.jpg)</span>](http://2.bp.blogspot.com/-PorkT6ZQGj0/VjsVKyXT1DI/AAAAAAAA35M/1-KLZL7tYfs/s1600/Screen%2BShot%2B2015-11-05%2Bat%2B4.36.02%2BPM.jpg)</div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">要注意到的一件事是 在這個系統中的所有更新 ( updates ) 都會走一個單一的通道 ( go through a single channel )。它們都朝著單一方向流動，讓我們叫它 單向資料綁定 ( one directional data-binding )。所有輸入到這個系統的更新，不管是來自使用者輸入、即時的server updates或是起始的Loading。這些所有的更新都只透過單向的流動，不管怎樣最後都會流到 View 方格那裏。這一塊是所有前端工程師，我最關心的地方... 對嗎? 我關心使用者經驗、使用者真正看到和接觸的地方。**概念上來說，我們發現建造這一塊 / View 最簡單的方式就是避免變異 ( mutation )。**基本上是完全避免變異。我們發現，如果每次更新發生我們可以把整個&nbsp;**View 砍掉，整個重繪**，那會變得超簡單。因為這樣，**你只要寫怎麼把 View 畫出來就好，不用管 View 怎麼更新的程式碼。**</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">但這樣亂搞，可行嗎？</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">從瀏覽器的角度來看這一定會很慢，記憶體還會不夠之類的。但概念上來說 ( conceptually )，我們還是想要用這個Model。因為每次更新就重繪真的很方便，但前提是要速度可行和還是能給使用者好的經驗。我們提出來的解法就是React.js。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">React：一個為了建立使用者介面的Javascript程式庫。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">我們想要所有來自 **更新就重繪這理念** 好的部分，但避免其中壞的副作用 ( bad performance &amp; bad ux )。從此之後你不用管你的應用中從 state a -&gt; state b -&gt; state c，只剩下 零 -&gt; 畫出來。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">React 的核心是宣告元件 ( Declarative components )：</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">在任何時間點都只要描述你的元件長什麼樣子，這不只是一個樣板 ( template )，這不是呼叫一個函式然後回傳一段字串那種事。因為那樣的話，你要整個 DOM 砍掉，然後把新的 HTML 掛上去。元件實際上是可重複使用的 API，封裝了一大堆東西，像是 markup、這東西看起來怎樣、它的功能是什麼、它的行為、CSS、Javascript 和這些東西的結構是什麼，是這些全部的東西。對於使用者元件隱藏了實作的細節，讓我給你一個實例：</span>\n<table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"><tbody><tr><td style=\"text-align: center;\">[<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">![](http://3.bp.blogspot.com/-IILmalknzQ4/VjsfYKsVFrI/AAAAAAAA35c/7SNGkiIPlWQ/s320/Screen%2BShot%2B2015-11-05%2Bat%2B5.20.09%2BPM.jpg)</span>](http://3.bp.blogspot.com/-IILmalknzQ4/VjsfYKsVFrI/AAAAAAAA35c/7SNGkiIPlWQ/s1600/Screen%2BShot%2B2015-11-05%2Bat%2B5.20.09%2BPM.jpg)</td></tr><tr><td class=\"tr-caption\" style=\"text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">輸入元件：提供互動的 auto-complete search box，只要用跟原始 HTML &lt;input&gt; 一樣多的程式碼。然後我應該可以對她註冊事件、設定它的行為 ( behavior ) 有哪些。</span></td></tr></tbody></table><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">No explicit data binding：不像 AngularJS，React 不需要實際上 Wire 你的 View 到你的 Model，你只要說哪一個屬性 ( property ) 你的 Model 想要在你的 View 中使用，然後當 Model 改變時、你的 View 就會被更新。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">它是怎麼運作的? ( How does it work? ) 我們這邊說兩件事。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">1) 它一開始是如何畫出來的。 ( Initial Render )</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">2) 更新是如何發生的。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Initial Render：在 React 我們只找一個 render function，這個 render function 完美的地方是它一直能告訴你這元件在任何時間的樣子。你提供的這個 render function 不會回傳一個字串，它回傳的是你的 View 的表現 ( representation ) ，我們做的事是... 既然元件可以由其他元件組成 &nbsp;( composited by other components )，我們遞迴的呼叫render來建立UI架構。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Two Pass Rendering：</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">1\\. 先建立 markup</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">2\\. 在最上層用 Event Delegation 附加上事件處理器</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">因為步驟一，先把元件畫出來，我們可以做 Server-side Rendering。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">更新是如何發生的？</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">我們不稱這個動作為<strike>Update</strike>，我們叫它 一致 ( reconciliation )。它的目的是保持你的 UI 元件 新鮮、當資料變化時自動更新。每個人應該現在都感到懷疑，如果不懷疑你大概剛剛都在睡覺。但你應該記得剛剛說的 Initial Rendering function，任何時間點它要回傳一個元件的表現 ( representation )。當改變發生時，我們重新呼叫一次 Render，然後比較原來 Render 的結果和改變過後 Render的結果，計算出兩個時間點元件的差別 ( diff )。接著批次計算出最少的變動量，然後一次 把變動更新到 DOM Tree 上面。所以很快。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">---</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">12:20 開始 Show Code Sample 和 JSX 語法</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp; &nbsp;程式碼還是看影片比較清楚... XD</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">26分開始大概一小時的Q &amp; A 還蠻精彩的~~~</span>","slug":"介紹-React-js-2013-by-Facebook","published":1,"updated":"2017-12-23T06:08:08.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjblkzcku000jxq9kiolg816r","content":"<p><div class=\"separator\" style=\"clear: both; text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><iframe allowfullscreen class=\"YOUTUBE-iframe-video\" data-thumbnail-src=\"https://i.ytimg.com/vi/XxVg_s8xAms/0.jpg\" frameborder=\"0\" height=\"266\" src=\"https://www.youtube.com/embed/XxVg_s8xAms?feature=player_embedded\" width=\"320\"></iframe></span></div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Introduction to React.js by Tom Occhino and Jordan Walke</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">整個React.js的由來是很多Facebook內部對一個問題的討論。這個問題是 <strong><u>開發Javacript的應用時，它的結構應該是如何？&nbsp;</u></strong>( “ How should we structure a javascript application? “ )。特別是瀏覽器端的 Javascript 應用。前人透過各式各樣的 framework 提出一大堆的解答。這些 framework 通常試著去實踐 MVC, MVVM, MVW 各種概念。這些架構或 framework 共同點就是 M，也就是 Model… 基本就只是一種可觀察的物件 ( observable object )，然後這些可觀察的物件有一些Event API，讓你訂閱物件改變的通知 ( subscribe changes )。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">實際上發生的事 是開發者建立了這些雙向資料綁定 ( bi-directional data-binding )，讓你可以訂閱物件改變的通知。當某個東西改變了，你就可以變動 ( mutate ) / 更新你的 View。但這種觀察模式 ( observation pattern ) 實際上鼓勵 UI 的變動 ( mutation )。每次先把元件畫出來，然後當改變發生時，就試著更新之前畫出來的 UI 元件。這邊的關鍵字是變動 ( mutation )。<strong>變動 ( mutation ) 是複雜的。</strong>大概兩年半前，Facebook試著重寫聊天室。我們試著把事情變簡單，試著把開發者要處理的變異 ( mutation ) 減到最少。讓我來解釋一下那是什麼意思，下面是一個簡單應用的架構：</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></p>\n<p><div class=\"separator\" style=\"clear: both; text-align: center;\"><a href=\"http://2.bp.blogspot.com/-PorkT6ZQGj0/VjsVKyXT1DI/AAAAAAAA35M/1-KLZL7tYfs/s1600/Screen%2BShot%2B2015-11-05%2Bat%2B4.36.02%2BPM.jpg\" target=\"_blank\" rel=\"noopener\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><img src=\"http://2.bp.blogspot.com/-PorkT6ZQGj0/VjsVKyXT1DI/AAAAAAAA35M/1-KLZL7tYfs/s400/Screen%2BShot%2B2015-11-05%2Bat%2B4.36.02%2BPM.jpg\" alt=\"\"></span></a></div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">要注意到的一件事是 在這個系統中的所有更新 ( updates ) 都會走一個單一的通道 ( go through a single channel )。它們都朝著單一方向流動，讓我們叫它 單向資料綁定 ( one directional data-binding )。所有輸入到這個系統的更新，不管是來自使用者輸入、即時的server updates或是起始的Loading。這些所有的更新都只透過單向的流動，不管怎樣最後都會流到 View 方格那裏。這一塊是所有前端工程師，我最關心的地方… 對嗎? 我關心使用者經驗、使用者真正看到和接觸的地方。<strong>概念上來說，我們發現建造這一塊 / View 最簡單的方式就是避免變異 ( mutation )。</strong>基本上是完全避免變異。我們發現，如果每次更新發生我們可以把整個&nbsp;<strong>View 砍掉，整個重繪</strong>，那會變得超簡單。因為這樣，<strong>你只要寫怎麼把 View 畫出來就好，不用管 View 怎麼更新的程式碼。</strong></span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">但這樣亂搞，可行嗎？</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">從瀏覽器的角度來看這一定會很慢，記憶體還會不夠之類的。但概念上來說 ( conceptually )，我們還是想要用這個Model。因為每次更新就重繪真的很方便，但前提是要速度可行和還是能給使用者好的經驗。我們提出來的解法就是React.js。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">React：一個為了建立使用者介面的Javascript程式庫。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">我們想要所有來自 <strong>更新就重繪這理念</strong> 好的部分，但避免其中壞的副作用 ( bad performance &amp; bad ux )。從此之後你不用管你的應用中從 state a -&gt; state b -&gt; state c，只剩下 零 -&gt; 畫出來。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">React 的核心是宣告元件 ( Declarative components )：</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">在任何時間點都只要描述你的元件長什麼樣子，這不只是一個樣板 ( template )，這不是呼叫一個函式然後回傳一段字串那種事。因為那樣的話，你要整個 DOM 砍掉，然後把新的 HTML 掛上去。元件實際上是可重複使用的 API，封裝了一大堆東西，像是 markup、這東西看起來怎樣、它的功能是什麼、它的行為、CSS、Javascript 和這些東西的結構是什麼，是這些全部的東西。對於使用者元件隱藏了實作的細節，讓我給你一個實例：</span></p>\n<p><table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"><tbody><tr><td style=\"text-align: center;\"><a href=\"http://3.bp.blogspot.com/-IILmalknzQ4/VjsfYKsVFrI/AAAAAAAA35c/7SNGkiIPlWQ/s1600/Screen%2BShot%2B2015-11-05%2Bat%2B5.20.09%2BPM.jpg\" target=\"_blank\" rel=\"noopener\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><img src=\"http://3.bp.blogspot.com/-IILmalknzQ4/VjsfYKsVFrI/AAAAAAAA35c/7SNGkiIPlWQ/s320/Screen%2BShot%2B2015-11-05%2Bat%2B5.20.09%2BPM.jpg\" alt=\"\"></span></a></td></tr><tr><td class=\"tr-caption\" style=\"text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">輸入元件：提供互動的 auto-complete search box，只要用跟原始 HTML &lt;input&gt; 一樣多的程式碼。然後我應該可以對她註冊事件、設定它的行為 ( behavior ) 有哪些。</span></td></tr></tbody></table><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">No explicit data binding：不像 AngularJS，React 不需要實際上 Wire 你的 View 到你的 Model，你只要說哪一個屬性 ( property ) 你的 Model 想要在你的 View 中使用，然後當 Model 改變時、你的 View 就會被更新。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">它是怎麼運作的? ( How does it work? ) 我們這邊說兩件事。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">1) 它一開始是如何畫出來的。 ( Initial Render )</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">2) 更新是如何發生的。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Initial Render：在 React 我們只找一個 render function，這個 render function 完美的地方是它一直能告訴你這元件在任何時間的樣子。你提供的這個 render function 不會回傳一個字串，它回傳的是你的 View 的表現 ( representation ) ，我們做的事是… 既然元件可以由其他元件組成 &nbsp;( composited by other components )，我們遞迴的呼叫render來建立UI架構。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Two Pass Rendering：</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">1. 先建立 markup</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">2. 在最上層用 Event Delegation 附加上事件處理器</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">因為步驟一，先把元件畫出來，我們可以做 Server-side Rendering。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">更新是如何發生的？</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">我們不稱這個動作為<strike>Update</strike>，我們叫它 一致 ( reconciliation )。它的目的是保持你的 UI 元件 新鮮、當資料變化時自動更新。每個人應該現在都感到懷疑，如果不懷疑你大概剛剛都在睡覺。但你應該記得剛剛說的 Initial Rendering function，任何時間點它要回傳一個元件的表現 ( representation )。當改變發生時，我們重新呼叫一次 Render，然後比較原來 Render 的結果和改變過後 Render的結果，計算出兩個時間點元件的差別 ( diff )。接著批次計算出最少的變動量，然後一次 把變動更新到 DOM Tree 上面。所以很快。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">—</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">12:20 開始 Show Code Sample 和 JSX 語法</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp; &nbsp;程式碼還是看影片比較清楚… XD</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">26分開始大概一小時的Q &amp; A 還蠻精彩的~~~</span></p>\n","site":{"data":{}},"excerpt":"","more":"<p><div class=\"separator\" style=\"clear: both; text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><iframe allowfullscreen class=\"YOUTUBE-iframe-video\" data-thumbnail-src=\"https://i.ytimg.com/vi/XxVg_s8xAms/0.jpg\" frameborder=\"0\" height=\"266\" src=\"https://www.youtube.com/embed/XxVg_s8xAms?feature=player_embedded\" width=\"320\"></iframe></span></div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Introduction to React.js by Tom Occhino and Jordan Walke</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">整個React.js的由來是很多Facebook內部對一個問題的討論。這個問題是 <strong><u>開發Javacript的應用時，它的結構應該是如何？&nbsp;</u></strong>( “ How should we structure a javascript application? “ )。特別是瀏覽器端的 Javascript 應用。前人透過各式各樣的 framework 提出一大堆的解答。這些 framework 通常試著去實踐 MVC, MVVM, MVW 各種概念。這些架構或 framework 共同點就是 M，也就是 Model… 基本就只是一種可觀察的物件 ( observable object )，然後這些可觀察的物件有一些Event API，讓你訂閱物件改變的通知 ( subscribe changes )。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">實際上發生的事 是開發者建立了這些雙向資料綁定 ( bi-directional data-binding )，讓你可以訂閱物件改變的通知。當某個東西改變了，你就可以變動 ( mutate ) / 更新你的 View。但這種觀察模式 ( observation pattern ) 實際上鼓勵 UI 的變動 ( mutation )。每次先把元件畫出來，然後當改變發生時，就試著更新之前畫出來的 UI 元件。這邊的關鍵字是變動 ( mutation )。<strong>變動 ( mutation ) 是複雜的。</strong>大概兩年半前，Facebook試著重寫聊天室。我們試著把事情變簡單，試著把開發者要處理的變異 ( mutation ) 減到最少。讓我來解釋一下那是什麼意思，下面是一個簡單應用的架構：</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></p>\n<p><div class=\"separator\" style=\"clear: both; text-align: center;\"><a href=\"http://2.bp.blogspot.com/-PorkT6ZQGj0/VjsVKyXT1DI/AAAAAAAA35M/1-KLZL7tYfs/s1600/Screen%2BShot%2B2015-11-05%2Bat%2B4.36.02%2BPM.jpg\" target=\"_blank\" rel=\"noopener\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><img src=\"http://2.bp.blogspot.com/-PorkT6ZQGj0/VjsVKyXT1DI/AAAAAAAA35M/1-KLZL7tYfs/s400/Screen%2BShot%2B2015-11-05%2Bat%2B4.36.02%2BPM.jpg\" alt=\"\"></span></a></div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">要注意到的一件事是 在這個系統中的所有更新 ( updates ) 都會走一個單一的通道 ( go through a single channel )。它們都朝著單一方向流動，讓我們叫它 單向資料綁定 ( one directional data-binding )。所有輸入到這個系統的更新，不管是來自使用者輸入、即時的server updates或是起始的Loading。這些所有的更新都只透過單向的流動，不管怎樣最後都會流到 View 方格那裏。這一塊是所有前端工程師，我最關心的地方… 對嗎? 我關心使用者經驗、使用者真正看到和接觸的地方。<strong>概念上來說，我們發現建造這一塊 / View 最簡單的方式就是避免變異 ( mutation )。</strong>基本上是完全避免變異。我們發現，如果每次更新發生我們可以把整個&nbsp;<strong>View 砍掉，整個重繪</strong>，那會變得超簡單。因為這樣，<strong>你只要寫怎麼把 View 畫出來就好，不用管 View 怎麼更新的程式碼。</strong></span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">但這樣亂搞，可行嗎？</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">從瀏覽器的角度來看這一定會很慢，記憶體還會不夠之類的。但概念上來說 ( conceptually )，我們還是想要用這個Model。因為每次更新就重繪真的很方便，但前提是要速度可行和還是能給使用者好的經驗。我們提出來的解法就是React.js。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">React：一個為了建立使用者介面的Javascript程式庫。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">我們想要所有來自 <strong>更新就重繪這理念</strong> 好的部分，但避免其中壞的副作用 ( bad performance &amp; bad ux )。從此之後你不用管你的應用中從 state a -&gt; state b -&gt; state c，只剩下 零 -&gt; 畫出來。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">React 的核心是宣告元件 ( Declarative components )：</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">在任何時間點都只要描述你的元件長什麼樣子，這不只是一個樣板 ( template )，這不是呼叫一個函式然後回傳一段字串那種事。因為那樣的話，你要整個 DOM 砍掉，然後把新的 HTML 掛上去。元件實際上是可重複使用的 API，封裝了一大堆東西，像是 markup、這東西看起來怎樣、它的功能是什麼、它的行為、CSS、Javascript 和這些東西的結構是什麼，是這些全部的東西。對於使用者元件隱藏了實作的細節，讓我給你一個實例：</span></p>\n<p><table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"><tbody><tr><td style=\"text-align: center;\"><a href=\"http://3.bp.blogspot.com/-IILmalknzQ4/VjsfYKsVFrI/AAAAAAAA35c/7SNGkiIPlWQ/s1600/Screen%2BShot%2B2015-11-05%2Bat%2B5.20.09%2BPM.jpg\" target=\"_blank\" rel=\"noopener\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><img src=\"http://3.bp.blogspot.com/-IILmalknzQ4/VjsfYKsVFrI/AAAAAAAA35c/7SNGkiIPlWQ/s320/Screen%2BShot%2B2015-11-05%2Bat%2B5.20.09%2BPM.jpg\" alt=\"\"></span></a></td></tr><tr><td class=\"tr-caption\" style=\"text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">輸入元件：提供互動的 auto-complete search box，只要用跟原始 HTML &lt;input&gt; 一樣多的程式碼。然後我應該可以對她註冊事件、設定它的行為 ( behavior ) 有哪些。</span></td></tr></tbody></table><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">No explicit data binding：不像 AngularJS，React 不需要實際上 Wire 你的 View 到你的 Model，你只要說哪一個屬性 ( property ) 你的 Model 想要在你的 View 中使用，然後當 Model 改變時、你的 View 就會被更新。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">它是怎麼運作的? ( How does it work? ) 我們這邊說兩件事。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">1) 它一開始是如何畫出來的。 ( Initial Render )</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">2) 更新是如何發生的。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Initial Render：在 React 我們只找一個 render function，這個 render function 完美的地方是它一直能告訴你這元件在任何時間的樣子。你提供的這個 render function 不會回傳一個字串，它回傳的是你的 View 的表現 ( representation ) ，我們做的事是… 既然元件可以由其他元件組成 &nbsp;( composited by other components )，我們遞迴的呼叫render來建立UI架構。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Two Pass Rendering：</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">1. 先建立 markup</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">2. 在最上層用 Event Delegation 附加上事件處理器</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">因為步驟一，先把元件畫出來，我們可以做 Server-side Rendering。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">更新是如何發生的？</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">我們不稱這個動作為<strike>Update</strike>，我們叫它 一致 ( reconciliation )。它的目的是保持你的 UI 元件 新鮮、當資料變化時自動更新。每個人應該現在都感到懷疑，如果不懷疑你大概剛剛都在睡覺。但你應該記得剛剛說的 Initial Rendering function，任何時間點它要回傳一個元件的表現 ( representation )。當改變發生時，我們重新呼叫一次 Render，然後比較原來 Render 的結果和改變過後 Render的結果，計算出兩個時間點元件的差別 ( diff )。接著批次計算出最少的變動量，然後一次 把變動更新到 DOM Tree 上面。所以很快。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">—</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">12:20 開始 Show Code Sample 和 JSX 語法</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp; &nbsp;程式碼還是看影片比較清楚… XD</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">26分開始大概一小時的Q &amp; A 還蠻精彩的~~~</span></p>\n"},{"title":"使用者故事對照/地圖演講摘要 (User Story Mapping)","date":"2016-05-28T14:07:00.000Z","_content":"\n<div class=\"separator\" style=\"clear: both; text-align: center;\">\n  <iframe allowfullscreen=\"\" class=\"YOUTUBE-iframe-video\" data-thumbnail-src=\"https://i.ytimg.com/vi/AorAgSrHjKM/0.jpg\" frameborder=\"0\" height=\"320\" src=\"https://www.youtube.com/embed/AorAgSrHjKM?feature=player_embedded\" width=\"480\">\n  </iframe>\n</div>\n\n### 摘要：\n「使用者故事地圖」是一種資訊架構。其目的是讓人們在設計的過程中更容易「透過溝通來建立共識、對系統有全盤理解」。結構的設計讓人可以持續修改、組織、引用、溝通設計的想法，重視呈現每個想法間的相互關係。是「便利貼技巧」+「使用者中心設計」+「敏捷開發」的整合運用。\n—\n講者：Jeff Patton, 來自敏捷的社群、當過軟體工程師、專案經理。\n\n在當專案經理的時候，接觸到使用者故事 (user story)，當時覺得這個名字很蠢，為什麼要用這個字。過了十年之後才了解故事(story)的意義。故事地圖(story map)是一個說大故事的簡單方法、它把大故事分解成更小的部分。然後對每個部分，實作的人會加上更多的細節把產品做出來。\n\n我從2000年就開始用故事 (story) 這個字。故事這個字從一開始就被誤解，我接下來會說明故事代表的意思。故事會解決軟體開發中兩個問題，但這兩個問題都不是寫更好的需求 (requirements)。\n\n**第一個問題：寫文件沒啥用 (Documents - just don’t work)**\n**第二的問題：太多東西要做 (Too much to build)**\n\n想像一個簡單的電話對話。blah blah 講了光靠電話描述，麵包店做出了許多奇怪的蛋糕。類似事在軟體公司也經常發生。文件寫完之後，做出來的產品就是不對。這邊的問題是，當我們分享、同意和簽署的文件，**我們只能相信每個人是理解的(意指每個人其實理解的都不同)**。之後 Kent 就想出了解決文件問題的方法，那就是不要寫、不要交換文件。用「告訴我你的故事」取代：如果我們能直接討論這個，我們可以一起想辦法 (figure it out together)。\n\n如果你想說什麼，寫在一張卡上。然後你會找到負責實作的人，一起討論、知道到底做出來會怎樣。用故事這個名字的原因來自「我們怎麼使用它」(how we use them) 而不是「我們怎麼寫它」。有多少人用 Scrum？backlog? 問題在現在的 Scrum 會議中，許多人來參加、許多人都在做自己的事，「故事」本來想要帶入的有效溝通早就被忽略了。常常的情況是幾個人會說話，大部分人就只是在聽、在發呆，**沒有相互溝通每個人理解到的是什麼。因為每個人心中的思考是無法被觀察的，只有當我們說出自己的思考、畫些圖片，我們才能察覺到每個人思考的差異，這時候我們才能真的達成共識 (really get it)。**如此在這個會議之後，當我們說到同樣的東西，才會代表同樣的意思、代表同樣的事情。不然會議中的共識，其實完全沒有達到共識。\n\n光分享文件、並沒有分享理解 (Shared documents aren’t shared understanding)\n\n透過文字、圖片的討論會讓每個人建立共同的理解。在 Atlassian，他們在牆上貼的不是工作列表，他們把那些放到 JIRA 軟體。他們貼在牆上的是一堆便利貼 / 草圖 / 線圖稿，每個都代表一個故事。他們討論故事。每個團隊，都有各自的故事們，然後做站立會議中，他們指著牆上的便利貼說，我今天做這個 JIRA Ticket。指的同時也指出了這個 JIRA Ticket 在整個大故事的位置，回憶起細節、為什麼現在要做它。那張便利貼就像一張在夏威夷的照片，**你可以說出照片外的細節，因為便利貼是你們一起討論出來的。**\n\n**第一個問題的解法：我們靠說故事 (story telling) 來建造共同理解 (shared understanding)**\n\n---\n我們的工作不是建造軟體，我們的工作是改變這個世界。這聽起來也許有些誇張。但這邊我們講的不是世界和平、非洲的飢荒之類的事。這邊說的**世界指的是我們身邊、我們有能力去改變的事。****這個世界的邊界是我們的產品**，透過看著會使用產品的人，我們有了新的想法，產生新的需求。需求 (requirements) 的目的就是我們背後有了好想法能夠幫助用產品的人。把現在的世界畫一個圈，有產品後的新世界的畫一個圈，我們要觀察現在世界的產出(output)、新世界有這個產出後的結果 (outcome)，像是產品的使用心得、影響 (Impact)。**先前說的想法 (idea) 的問題是「每個人都有想法」。**所以每個人的想法就會轉成越來越多的事情要做。我們的目標不是加快產生出垃圾(our job is not to build more crap faster)，我們的目標是做更少的產出 (our goal is to build less)。當你做更少的產出，你試圖最小化產出 (output) ，同時最大化結果 (outcome) 和影響 (Impact)。\n\n之前工作的時候，知道了下一次產品發行的需求列表後，去問他們「使用者是誰？解決了使用者什麼問題？」。得到的答案是：「這些是需求 (requirements)」，當時我就知道需求還有另外一個意思 — 那就是閉上嘴 (shut up)。他們真的以為需求列表，就真的如同字典上的意思代表了必須要做的事。實際上它們並不是... 因為不可能實作所有的需求，光只有需求沒法最小化產出、最大化結果。故事是需求 (requirements) 的解毒劑。\n\n引用 Kent：「軟體開發已經被需求 (requirement) 這個字導入的錯誤的方向，這個字在字典裡被定義為需要做的事 (something mandatory or obligatory)。這個字帶有絕對和永久的一役、抑制了擁抱變化。需求 (requirements)這個字完全是個錯誤」 \n\n我們要說誰做什麼、怎麼做、為什麼做 (talk about who doing what and why)。討論和協作要專注在誰會用這個產品和他們拿到這個產品之後會怎麼使用它。基本上，你必須要**想通整件事**。舉了一個漂亮的嬰兒形狀蛋糕的例子，蛋糕看起來很漂亮，但要吃的時候就必須把嬰兒切開，這應該是沒有把事情想通的做法。\n\n**第二個問題的答案是：透過理解產品是為了誰、做什麼、為什麼這樣做，來最小化產出。**\n\n如果正確的使用故事，就可以解決這兩個問題。\n\n但我們會碰到一個問題，很多很棒的想法，怎麼轉變成 scrum 中開發的故事裡 (1~3天可完成、可被估計、可測試、可被展示...)。這邊講一個故事，Rachel 是90年代的一個專案經理，當他去跟工程師問說每個的工作項目是為了誰、為什麼要這樣做的同時？發現工程師瞬間就開始說這個東西好像不是一定要做、也許在別的地方做會更好。很多人根本就沒把事情想通。於是，Rachel 就寫了一個聰明的溝通小卡：\n\n標題：寫一個好的故事\nAs (who) to (do what) so that (why) 的例子，當作一個容易開始討論的起點 (conversation starter)\n\n就這樣定義出了常見使用者故事的格式(story template)，但如果用這個格式當作 scrum 中的 backlog 項目，應該會覺得有些卡卡的，因為這個格式本來不是拿來這樣子用的。它本來是在探索階段，拿來引導討論那些大的好想法的，那些要被分成更多 backlog 的項目。\n\n這邊舉了一個 Gray 用敏捷開發流程開發音樂服務網站的例子，Gray 把所有要做的代辦事項排序之後，就從最優先的事情開始做，進度一直都有進展，但一段時間過去，開始覺得事情做不完，而且無法估計什麼時候整個系統可以上線完成。Gray 這時候就問了，有沒有其他不用敏捷開發流程的方法。這是我碰到他當時的情況。我們一見面談的不是開發方法，而是討論定義想法(Frame the idea)、為什麼要做這個產品、對使用者的了解、使用者的目標是什麼。開始討論想法，寫下想法在便利貼上、移動想法、組織想法。討論使用者一整天會怎麼使用這個產品。Gray 說、然後我用便利貼紀錄下來，這是 Gray 第一次看到整個產品看起來會是怎樣子。之後才開始探索細節，分成更多步驟、替代方法、UI的設計、技術細節。之後就可大概估時間，挑出核心的部分來做，發現這些核心都是之前用待辦事項開發幾個月沒做的部分！！！之後這個產品就順利上線了～\n\n以上是影片前55分鐘的摘要，後來開始用影片舉例子，還是直接看影片吧~\n你會看到許多使用者故事地圖開發的過程和樣子。後來還有說 MVP 的概念，提早驗證、提早學會。把 MVP 分成數個階段，讓每個階段都能透過驗證來學習、改變產品方向。和一些其他秘訣... 像是油畫草稿和 protyotyping和迭代的重要性。\n\n作者的總結：\n1\\. 改變你工作的方式：跟別人說故事，而不只是寫故事\n2\\. 用簡單的視覺化去代表你說的故事\n3\\. 要把整個故事都放到地圖上，來找出最重要的部分\n4\\. 把事情想通：減少產出、增加結果和影響\n5\\. 建立最小可行產品測試，來學到什麼是市場中最小的和可行的\n6\\. 用疊代和漸進的(原型 / 草稿式)的方式來建造產品\n\n有效率的故事們能幫助每個人朝向產品成功而工作\n\nQ &amp; A 從一小時二十分開始\n—\n就結構來說是把敏捷開發流程中的待辦事項列表用一個某種可變網狀系統資訊結構取代。\n","source":"_posts/使用者故事對照-地圖演講摘要-User-Story-Mapping.md","raw":"---\ntitle: 使用者故事對照/地圖演講摘要 (User Story Mapping)\ntags:\n  - agile\n  - design\n  - IA\n  - System Thinking\n  - UCD\n  - user story mapping\ndate: 2016-05-28 22:07:00\n---\n\n<div class=\"separator\" style=\"clear: both; text-align: center;\">\n  <iframe allowfullscreen=\"\" class=\"YOUTUBE-iframe-video\" data-thumbnail-src=\"https://i.ytimg.com/vi/AorAgSrHjKM/0.jpg\" frameborder=\"0\" height=\"320\" src=\"https://www.youtube.com/embed/AorAgSrHjKM?feature=player_embedded\" width=\"480\">\n  </iframe>\n</div>\n\n### 摘要：\n「使用者故事地圖」是一種資訊架構。其目的是讓人們在設計的過程中更容易「透過溝通來建立共識、對系統有全盤理解」。結構的設計讓人可以持續修改、組織、引用、溝通設計的想法，重視呈現每個想法間的相互關係。是「便利貼技巧」+「使用者中心設計」+「敏捷開發」的整合運用。\n—\n講者：Jeff Patton, 來自敏捷的社群、當過軟體工程師、專案經理。\n\n在當專案經理的時候，接觸到使用者故事 (user story)，當時覺得這個名字很蠢，為什麼要用這個字。過了十年之後才了解故事(story)的意義。故事地圖(story map)是一個說大故事的簡單方法、它把大故事分解成更小的部分。然後對每個部分，實作的人會加上更多的細節把產品做出來。\n\n我從2000年就開始用故事 (story) 這個字。故事這個字從一開始就被誤解，我接下來會說明故事代表的意思。故事會解決軟體開發中兩個問題，但這兩個問題都不是寫更好的需求 (requirements)。\n\n**第一個問題：寫文件沒啥用 (Documents - just don’t work)**\n**第二的問題：太多東西要做 (Too much to build)**\n\n想像一個簡單的電話對話。blah blah 講了光靠電話描述，麵包店做出了許多奇怪的蛋糕。類似事在軟體公司也經常發生。文件寫完之後，做出來的產品就是不對。這邊的問題是，當我們分享、同意和簽署的文件，**我們只能相信每個人是理解的(意指每個人其實理解的都不同)**。之後 Kent 就想出了解決文件問題的方法，那就是不要寫、不要交換文件。用「告訴我你的故事」取代：如果我們能直接討論這個，我們可以一起想辦法 (figure it out together)。\n\n如果你想說什麼，寫在一張卡上。然後你會找到負責實作的人，一起討論、知道到底做出來會怎樣。用故事這個名字的原因來自「我們怎麼使用它」(how we use them) 而不是「我們怎麼寫它」。有多少人用 Scrum？backlog? 問題在現在的 Scrum 會議中，許多人來參加、許多人都在做自己的事，「故事」本來想要帶入的有效溝通早就被忽略了。常常的情況是幾個人會說話，大部分人就只是在聽、在發呆，**沒有相互溝通每個人理解到的是什麼。因為每個人心中的思考是無法被觀察的，只有當我們說出自己的思考、畫些圖片，我們才能察覺到每個人思考的差異，這時候我們才能真的達成共識 (really get it)。**如此在這個會議之後，當我們說到同樣的東西，才會代表同樣的意思、代表同樣的事情。不然會議中的共識，其實完全沒有達到共識。\n\n光分享文件、並沒有分享理解 (Shared documents aren’t shared understanding)\n\n透過文字、圖片的討論會讓每個人建立共同的理解。在 Atlassian，他們在牆上貼的不是工作列表，他們把那些放到 JIRA 軟體。他們貼在牆上的是一堆便利貼 / 草圖 / 線圖稿，每個都代表一個故事。他們討論故事。每個團隊，都有各自的故事們，然後做站立會議中，他們指著牆上的便利貼說，我今天做這個 JIRA Ticket。指的同時也指出了這個 JIRA Ticket 在整個大故事的位置，回憶起細節、為什麼現在要做它。那張便利貼就像一張在夏威夷的照片，**你可以說出照片外的細節，因為便利貼是你們一起討論出來的。**\n\n**第一個問題的解法：我們靠說故事 (story telling) 來建造共同理解 (shared understanding)**\n\n---\n我們的工作不是建造軟體，我們的工作是改變這個世界。這聽起來也許有些誇張。但這邊我們講的不是世界和平、非洲的飢荒之類的事。這邊說的**世界指的是我們身邊、我們有能力去改變的事。****這個世界的邊界是我們的產品**，透過看著會使用產品的人，我們有了新的想法，產生新的需求。需求 (requirements) 的目的就是我們背後有了好想法能夠幫助用產品的人。把現在的世界畫一個圈，有產品後的新世界的畫一個圈，我們要觀察現在世界的產出(output)、新世界有這個產出後的結果 (outcome)，像是產品的使用心得、影響 (Impact)。**先前說的想法 (idea) 的問題是「每個人都有想法」。**所以每個人的想法就會轉成越來越多的事情要做。我們的目標不是加快產生出垃圾(our job is not to build more crap faster)，我們的目標是做更少的產出 (our goal is to build less)。當你做更少的產出，你試圖最小化產出 (output) ，同時最大化結果 (outcome) 和影響 (Impact)。\n\n之前工作的時候，知道了下一次產品發行的需求列表後，去問他們「使用者是誰？解決了使用者什麼問題？」。得到的答案是：「這些是需求 (requirements)」，當時我就知道需求還有另外一個意思 — 那就是閉上嘴 (shut up)。他們真的以為需求列表，就真的如同字典上的意思代表了必須要做的事。實際上它們並不是... 因為不可能實作所有的需求，光只有需求沒法最小化產出、最大化結果。故事是需求 (requirements) 的解毒劑。\n\n引用 Kent：「軟體開發已經被需求 (requirement) 這個字導入的錯誤的方向，這個字在字典裡被定義為需要做的事 (something mandatory or obligatory)。這個字帶有絕對和永久的一役、抑制了擁抱變化。需求 (requirements)這個字完全是個錯誤」 \n\n我們要說誰做什麼、怎麼做、為什麼做 (talk about who doing what and why)。討論和協作要專注在誰會用這個產品和他們拿到這個產品之後會怎麼使用它。基本上，你必須要**想通整件事**。舉了一個漂亮的嬰兒形狀蛋糕的例子，蛋糕看起來很漂亮，但要吃的時候就必須把嬰兒切開，這應該是沒有把事情想通的做法。\n\n**第二個問題的答案是：透過理解產品是為了誰、做什麼、為什麼這樣做，來最小化產出。**\n\n如果正確的使用故事，就可以解決這兩個問題。\n\n但我們會碰到一個問題，很多很棒的想法，怎麼轉變成 scrum 中開發的故事裡 (1~3天可完成、可被估計、可測試、可被展示...)。這邊講一個故事，Rachel 是90年代的一個專案經理，當他去跟工程師問說每個的工作項目是為了誰、為什麼要這樣做的同時？發現工程師瞬間就開始說這個東西好像不是一定要做、也許在別的地方做會更好。很多人根本就沒把事情想通。於是，Rachel 就寫了一個聰明的溝通小卡：\n\n標題：寫一個好的故事\nAs (who) to (do what) so that (why) 的例子，當作一個容易開始討論的起點 (conversation starter)\n\n就這樣定義出了常見使用者故事的格式(story template)，但如果用這個格式當作 scrum 中的 backlog 項目，應該會覺得有些卡卡的，因為這個格式本來不是拿來這樣子用的。它本來是在探索階段，拿來引導討論那些大的好想法的，那些要被分成更多 backlog 的項目。\n\n這邊舉了一個 Gray 用敏捷開發流程開發音樂服務網站的例子，Gray 把所有要做的代辦事項排序之後，就從最優先的事情開始做，進度一直都有進展，但一段時間過去，開始覺得事情做不完，而且無法估計什麼時候整個系統可以上線完成。Gray 這時候就問了，有沒有其他不用敏捷開發流程的方法。這是我碰到他當時的情況。我們一見面談的不是開發方法，而是討論定義想法(Frame the idea)、為什麼要做這個產品、對使用者的了解、使用者的目標是什麼。開始討論想法，寫下想法在便利貼上、移動想法、組織想法。討論使用者一整天會怎麼使用這個產品。Gray 說、然後我用便利貼紀錄下來，這是 Gray 第一次看到整個產品看起來會是怎樣子。之後才開始探索細節，分成更多步驟、替代方法、UI的設計、技術細節。之後就可大概估時間，挑出核心的部分來做，發現這些核心都是之前用待辦事項開發幾個月沒做的部分！！！之後這個產品就順利上線了～\n\n以上是影片前55分鐘的摘要，後來開始用影片舉例子，還是直接看影片吧~\n你會看到許多使用者故事地圖開發的過程和樣子。後來還有說 MVP 的概念，提早驗證、提早學會。把 MVP 分成數個階段，讓每個階段都能透過驗證來學習、改變產品方向。和一些其他秘訣... 像是油畫草稿和 protyotyping和迭代的重要性。\n\n作者的總結：\n1\\. 改變你工作的方式：跟別人說故事，而不只是寫故事\n2\\. 用簡單的視覺化去代表你說的故事\n3\\. 要把整個故事都放到地圖上，來找出最重要的部分\n4\\. 把事情想通：減少產出、增加結果和影響\n5\\. 建立最小可行產品測試，來學到什麼是市場中最小的和可行的\n6\\. 用疊代和漸進的(原型 / 草稿式)的方式來建造產品\n\n有效率的故事們能幫助每個人朝向產品成功而工作\n\nQ &amp; A 從一小時二十分開始\n—\n就結構來說是把敏捷開發流程中的待辦事項列表用一個某種可變網狀系統資訊結構取代。\n","slug":"使用者故事對照-地圖演講摘要-User-Story-Mapping","published":1,"updated":"2017-12-25T02:19:53.076Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjblkzckz000lxq9kr5xw1sih","content":"<div class=\"separator\" style=\"clear: both; text-align: center;\"><br>  <iframe allowfullscreen class=\"YOUTUBE-iframe-video\" data-thumbnail-src=\"https://i.ytimg.com/vi/AorAgSrHjKM/0.jpg\" frameborder=\"0\" height=\"320\" src=\"https://www.youtube.com/embed/AorAgSrHjKM?feature=player_embedded\" width=\"480\"><br>  </iframe><br></div>\n\n<h3 id=\"摘要：\"><a href=\"#摘要：\" class=\"headerlink\" title=\"摘要：\"></a>摘要：</h3><p>「使用者故事地圖」是一種資訊架構。其目的是讓人們在設計的過程中更容易「透過溝通來建立共識、對系統有全盤理解」。結構的設計讓人可以持續修改、組織、引用、溝通設計的想法，重視呈現每個想法間的相互關係。是「便利貼技巧」+「使用者中心設計」+「敏捷開發」的整合運用。<br>—<br>講者：Jeff Patton, 來自敏捷的社群、當過軟體工程師、專案經理。</p>\n<p>在當專案經理的時候，接觸到使用者故事 (user story)，當時覺得這個名字很蠢，為什麼要用這個字。過了十年之後才了解故事(story)的意義。故事地圖(story map)是一個說大故事的簡單方法、它把大故事分解成更小的部分。然後對每個部分，實作的人會加上更多的細節把產品做出來。</p>\n<p>我從2000年就開始用故事 (story) 這個字。故事這個字從一開始就被誤解，我接下來會說明故事代表的意思。故事會解決軟體開發中兩個問題，但這兩個問題都不是寫更好的需求 (requirements)。</p>\n<p><strong>第一個問題：寫文件沒啥用 (Documents - just don’t work)</strong><br><strong>第二的問題：太多東西要做 (Too much to build)</strong></p>\n<p>想像一個簡單的電話對話。blah blah 講了光靠電話描述，麵包店做出了許多奇怪的蛋糕。類似事在軟體公司也經常發生。文件寫完之後，做出來的產品就是不對。這邊的問題是，當我們分享、同意和簽署的文件，<strong>我們只能相信每個人是理解的(意指每個人其實理解的都不同)</strong>。之後 Kent 就想出了解決文件問題的方法，那就是不要寫、不要交換文件。用「告訴我你的故事」取代：如果我們能直接討論這個，我們可以一起想辦法 (figure it out together)。</p>\n<p>如果你想說什麼，寫在一張卡上。然後你會找到負責實作的人，一起討論、知道到底做出來會怎樣。用故事這個名字的原因來自「我們怎麼使用它」(how we use them) 而不是「我們怎麼寫它」。有多少人用 Scrum？backlog? 問題在現在的 Scrum 會議中，許多人來參加、許多人都在做自己的事，「故事」本來想要帶入的有效溝通早就被忽略了。常常的情況是幾個人會說話，大部分人就只是在聽、在發呆，<strong>沒有相互溝通每個人理解到的是什麼。因為每個人心中的思考是無法被觀察的，只有當我們說出自己的思考、畫些圖片，我們才能察覺到每個人思考的差異，這時候我們才能真的達成共識 (really get it)。</strong>如此在這個會議之後，當我們說到同樣的東西，才會代表同樣的意思、代表同樣的事情。不然會議中的共識，其實完全沒有達到共識。</p>\n<p>光分享文件、並沒有分享理解 (Shared documents aren’t shared understanding)</p>\n<p>透過文字、圖片的討論會讓每個人建立共同的理解。在 Atlassian，他們在牆上貼的不是工作列表，他們把那些放到 JIRA 軟體。他們貼在牆上的是一堆便利貼 / 草圖 / 線圖稿，每個都代表一個故事。他們討論故事。每個團隊，都有各自的故事們，然後做站立會議中，他們指著牆上的便利貼說，我今天做這個 JIRA Ticket。指的同時也指出了這個 JIRA Ticket 在整個大故事的位置，回憶起細節、為什麼現在要做它。那張便利貼就像一張在夏威夷的照片，<strong>你可以說出照片外的細節，因為便利貼是你們一起討論出來的。</strong></p>\n<p><strong>第一個問題的解法：我們靠說故事 (story telling) 來建造共同理解 (shared understanding)</strong></p>\n<hr>\n<p>我們的工作不是建造軟體，我們的工作是改變這個世界。這聽起來也許有些誇張。但這邊我們講的不是世界和平、非洲的飢荒之類的事。這邊說的<strong>世界指的是我們身邊、我們有能力去改變的事。**</strong>這個世界的邊界是我們的產品<strong>，透過看著會使用產品的人，我們有了新的想法，產生新的需求。需求 (requirements) 的目的就是我們背後有了好想法能夠幫助用產品的人。把現在的世界畫一個圈，有產品後的新世界的畫一個圈，我們要觀察現在世界的產出(output)、新世界有這個產出後的結果 (outcome)，像是產品的使用心得、影響 (Impact)。</strong>先前說的想法 (idea) 的問題是「每個人都有想法」。**所以每個人的想法就會轉成越來越多的事情要做。我們的目標不是加快產生出垃圾(our job is not to build more crap faster)，我們的目標是做更少的產出 (our goal is to build less)。當你做更少的產出，你試圖最小化產出 (output) ，同時最大化結果 (outcome) 和影響 (Impact)。</p>\n<p>之前工作的時候，知道了下一次產品發行的需求列表後，去問他們「使用者是誰？解決了使用者什麼問題？」。得到的答案是：「這些是需求 (requirements)」，當時我就知道需求還有另外一個意思 — 那就是閉上嘴 (shut up)。他們真的以為需求列表，就真的如同字典上的意思代表了必須要做的事。實際上它們並不是… 因為不可能實作所有的需求，光只有需求沒法最小化產出、最大化結果。故事是需求 (requirements) 的解毒劑。</p>\n<p>引用 Kent：「軟體開發已經被需求 (requirement) 這個字導入的錯誤的方向，這個字在字典裡被定義為需要做的事 (something mandatory or obligatory)。這個字帶有絕對和永久的一役、抑制了擁抱變化。需求 (requirements)這個字完全是個錯誤」 </p>\n<p>我們要說誰做什麼、怎麼做、為什麼做 (talk about who doing what and why)。討論和協作要專注在誰會用這個產品和他們拿到這個產品之後會怎麼使用它。基本上，你必須要<strong>想通整件事</strong>。舉了一個漂亮的嬰兒形狀蛋糕的例子，蛋糕看起來很漂亮，但要吃的時候就必須把嬰兒切開，這應該是沒有把事情想通的做法。</p>\n<p><strong>第二個問題的答案是：透過理解產品是為了誰、做什麼、為什麼這樣做，來最小化產出。</strong></p>\n<p>如果正確的使用故事，就可以解決這兩個問題。</p>\n<p>但我們會碰到一個問題，很多很棒的想法，怎麼轉變成 scrum 中開發的故事裡 (1~3天可完成、可被估計、可測試、可被展示…)。這邊講一個故事，Rachel 是90年代的一個專案經理，當他去跟工程師問說每個的工作項目是為了誰、為什麼要這樣做的同時？發現工程師瞬間就開始說這個東西好像不是一定要做、也許在別的地方做會更好。很多人根本就沒把事情想通。於是，Rachel 就寫了一個聰明的溝通小卡：</p>\n<p>標題：寫一個好的故事<br>As (who) to (do what) so that (why) 的例子，當作一個容易開始討論的起點 (conversation starter)</p>\n<p>就這樣定義出了常見使用者故事的格式(story template)，但如果用這個格式當作 scrum 中的 backlog 項目，應該會覺得有些卡卡的，因為這個格式本來不是拿來這樣子用的。它本來是在探索階段，拿來引導討論那些大的好想法的，那些要被分成更多 backlog 的項目。</p>\n<p>這邊舉了一個 Gray 用敏捷開發流程開發音樂服務網站的例子，Gray 把所有要做的代辦事項排序之後，就從最優先的事情開始做，進度一直都有進展，但一段時間過去，開始覺得事情做不完，而且無法估計什麼時候整個系統可以上線完成。Gray 這時候就問了，有沒有其他不用敏捷開發流程的方法。這是我碰到他當時的情況。我們一見面談的不是開發方法，而是討論定義想法(Frame the idea)、為什麼要做這個產品、對使用者的了解、使用者的目標是什麼。開始討論想法，寫下想法在便利貼上、移動想法、組織想法。討論使用者一整天會怎麼使用這個產品。Gray 說、然後我用便利貼紀錄下來，這是 Gray 第一次看到整個產品看起來會是怎樣子。之後才開始探索細節，分成更多步驟、替代方法、UI的設計、技術細節。之後就可大概估時間，挑出核心的部分來做，發現這些核心都是之前用待辦事項開發幾個月沒做的部分！！！之後這個產品就順利上線了～</p>\n<p>以上是影片前55分鐘的摘要，後來開始用影片舉例子，還是直接看影片吧~<br>你會看到許多使用者故事地圖開發的過程和樣子。後來還有說 MVP 的概念，提早驗證、提早學會。把 MVP 分成數個階段，讓每個階段都能透過驗證來學習、改變產品方向。和一些其他秘訣… 像是油畫草稿和 protyotyping和迭代的重要性。</p>\n<p>作者的總結：<br>1. 改變你工作的方式：跟別人說故事，而不只是寫故事<br>2. 用簡單的視覺化去代表你說的故事<br>3. 要把整個故事都放到地圖上，來找出最重要的部分<br>4. 把事情想通：減少產出、增加結果和影響<br>5. 建立最小可行產品測試，來學到什麼是市場中最小的和可行的<br>6. 用疊代和漸進的(原型 / 草稿式)的方式來建造產品</p>\n<p>有效率的故事們能幫助每個人朝向產品成功而工作</p>\n<p>Q &amp; A 從一小時二十分開始<br>—<br>就結構來說是把敏捷開發流程中的待辦事項列表用一個某種可變網狀系統資訊結構取代。</p>\n","site":{"data":{}},"excerpt":"","more":"<div class=\"separator\" style=\"clear: both; text-align: center;\"><br>  <iframe allowfullscreen class=\"YOUTUBE-iframe-video\" data-thumbnail-src=\"https://i.ytimg.com/vi/AorAgSrHjKM/0.jpg\" frameborder=\"0\" height=\"320\" src=\"https://www.youtube.com/embed/AorAgSrHjKM?feature=player_embedded\" width=\"480\"><br>  </iframe><br></div>\n\n<h3 id=\"摘要：\"><a href=\"#摘要：\" class=\"headerlink\" title=\"摘要：\"></a>摘要：</h3><p>「使用者故事地圖」是一種資訊架構。其目的是讓人們在設計的過程中更容易「透過溝通來建立共識、對系統有全盤理解」。結構的設計讓人可以持續修改、組織、引用、溝通設計的想法，重視呈現每個想法間的相互關係。是「便利貼技巧」+「使用者中心設計」+「敏捷開發」的整合運用。<br>—<br>講者：Jeff Patton, 來自敏捷的社群、當過軟體工程師、專案經理。</p>\n<p>在當專案經理的時候，接觸到使用者故事 (user story)，當時覺得這個名字很蠢，為什麼要用這個字。過了十年之後才了解故事(story)的意義。故事地圖(story map)是一個說大故事的簡單方法、它把大故事分解成更小的部分。然後對每個部分，實作的人會加上更多的細節把產品做出來。</p>\n<p>我從2000年就開始用故事 (story) 這個字。故事這個字從一開始就被誤解，我接下來會說明故事代表的意思。故事會解決軟體開發中兩個問題，但這兩個問題都不是寫更好的需求 (requirements)。</p>\n<p><strong>第一個問題：寫文件沒啥用 (Documents - just don’t work)</strong><br><strong>第二的問題：太多東西要做 (Too much to build)</strong></p>\n<p>想像一個簡單的電話對話。blah blah 講了光靠電話描述，麵包店做出了許多奇怪的蛋糕。類似事在軟體公司也經常發生。文件寫完之後，做出來的產品就是不對。這邊的問題是，當我們分享、同意和簽署的文件，<strong>我們只能相信每個人是理解的(意指每個人其實理解的都不同)</strong>。之後 Kent 就想出了解決文件問題的方法，那就是不要寫、不要交換文件。用「告訴我你的故事」取代：如果我們能直接討論這個，我們可以一起想辦法 (figure it out together)。</p>\n<p>如果你想說什麼，寫在一張卡上。然後你會找到負責實作的人，一起討論、知道到底做出來會怎樣。用故事這個名字的原因來自「我們怎麼使用它」(how we use them) 而不是「我們怎麼寫它」。有多少人用 Scrum？backlog? 問題在現在的 Scrum 會議中，許多人來參加、許多人都在做自己的事，「故事」本來想要帶入的有效溝通早就被忽略了。常常的情況是幾個人會說話，大部分人就只是在聽、在發呆，<strong>沒有相互溝通每個人理解到的是什麼。因為每個人心中的思考是無法被觀察的，只有當我們說出自己的思考、畫些圖片，我們才能察覺到每個人思考的差異，這時候我們才能真的達成共識 (really get it)。</strong>如此在這個會議之後，當我們說到同樣的東西，才會代表同樣的意思、代表同樣的事情。不然會議中的共識，其實完全沒有達到共識。</p>\n<p>光分享文件、並沒有分享理解 (Shared documents aren’t shared understanding)</p>\n<p>透過文字、圖片的討論會讓每個人建立共同的理解。在 Atlassian，他們在牆上貼的不是工作列表，他們把那些放到 JIRA 軟體。他們貼在牆上的是一堆便利貼 / 草圖 / 線圖稿，每個都代表一個故事。他們討論故事。每個團隊，都有各自的故事們，然後做站立會議中，他們指著牆上的便利貼說，我今天做這個 JIRA Ticket。指的同時也指出了這個 JIRA Ticket 在整個大故事的位置，回憶起細節、為什麼現在要做它。那張便利貼就像一張在夏威夷的照片，<strong>你可以說出照片外的細節，因為便利貼是你們一起討論出來的。</strong></p>\n<p><strong>第一個問題的解法：我們靠說故事 (story telling) 來建造共同理解 (shared understanding)</strong></p>\n<hr>\n<p>我們的工作不是建造軟體，我們的工作是改變這個世界。這聽起來也許有些誇張。但這邊我們講的不是世界和平、非洲的飢荒之類的事。這邊說的<strong>世界指的是我們身邊、我們有能力去改變的事。**</strong>這個世界的邊界是我們的產品<strong>，透過看著會使用產品的人，我們有了新的想法，產生新的需求。需求 (requirements) 的目的就是我們背後有了好想法能夠幫助用產品的人。把現在的世界畫一個圈，有產品後的新世界的畫一個圈，我們要觀察現在世界的產出(output)、新世界有這個產出後的結果 (outcome)，像是產品的使用心得、影響 (Impact)。</strong>先前說的想法 (idea) 的問題是「每個人都有想法」。**所以每個人的想法就會轉成越來越多的事情要做。我們的目標不是加快產生出垃圾(our job is not to build more crap faster)，我們的目標是做更少的產出 (our goal is to build less)。當你做更少的產出，你試圖最小化產出 (output) ，同時最大化結果 (outcome) 和影響 (Impact)。</p>\n<p>之前工作的時候，知道了下一次產品發行的需求列表後，去問他們「使用者是誰？解決了使用者什麼問題？」。得到的答案是：「這些是需求 (requirements)」，當時我就知道需求還有另外一個意思 — 那就是閉上嘴 (shut up)。他們真的以為需求列表，就真的如同字典上的意思代表了必須要做的事。實際上它們並不是… 因為不可能實作所有的需求，光只有需求沒法最小化產出、最大化結果。故事是需求 (requirements) 的解毒劑。</p>\n<p>引用 Kent：「軟體開發已經被需求 (requirement) 這個字導入的錯誤的方向，這個字在字典裡被定義為需要做的事 (something mandatory or obligatory)。這個字帶有絕對和永久的一役、抑制了擁抱變化。需求 (requirements)這個字完全是個錯誤」 </p>\n<p>我們要說誰做什麼、怎麼做、為什麼做 (talk about who doing what and why)。討論和協作要專注在誰會用這個產品和他們拿到這個產品之後會怎麼使用它。基本上，你必須要<strong>想通整件事</strong>。舉了一個漂亮的嬰兒形狀蛋糕的例子，蛋糕看起來很漂亮，但要吃的時候就必須把嬰兒切開，這應該是沒有把事情想通的做法。</p>\n<p><strong>第二個問題的答案是：透過理解產品是為了誰、做什麼、為什麼這樣做，來最小化產出。</strong></p>\n<p>如果正確的使用故事，就可以解決這兩個問題。</p>\n<p>但我們會碰到一個問題，很多很棒的想法，怎麼轉變成 scrum 中開發的故事裡 (1~3天可完成、可被估計、可測試、可被展示…)。這邊講一個故事，Rachel 是90年代的一個專案經理，當他去跟工程師問說每個的工作項目是為了誰、為什麼要這樣做的同時？發現工程師瞬間就開始說這個東西好像不是一定要做、也許在別的地方做會更好。很多人根本就沒把事情想通。於是，Rachel 就寫了一個聰明的溝通小卡：</p>\n<p>標題：寫一個好的故事<br>As (who) to (do what) so that (why) 的例子，當作一個容易開始討論的起點 (conversation starter)</p>\n<p>就這樣定義出了常見使用者故事的格式(story template)，但如果用這個格式當作 scrum 中的 backlog 項目，應該會覺得有些卡卡的，因為這個格式本來不是拿來這樣子用的。它本來是在探索階段，拿來引導討論那些大的好想法的，那些要被分成更多 backlog 的項目。</p>\n<p>這邊舉了一個 Gray 用敏捷開發流程開發音樂服務網站的例子，Gray 把所有要做的代辦事項排序之後，就從最優先的事情開始做，進度一直都有進展，但一段時間過去，開始覺得事情做不完，而且無法估計什麼時候整個系統可以上線完成。Gray 這時候就問了，有沒有其他不用敏捷開發流程的方法。這是我碰到他當時的情況。我們一見面談的不是開發方法，而是討論定義想法(Frame the idea)、為什麼要做這個產品、對使用者的了解、使用者的目標是什麼。開始討論想法，寫下想法在便利貼上、移動想法、組織想法。討論使用者一整天會怎麼使用這個產品。Gray 說、然後我用便利貼紀錄下來，這是 Gray 第一次看到整個產品看起來會是怎樣子。之後才開始探索細節，分成更多步驟、替代方法、UI的設計、技術細節。之後就可大概估時間，挑出核心的部分來做，發現這些核心都是之前用待辦事項開發幾個月沒做的部分！！！之後這個產品就順利上線了～</p>\n<p>以上是影片前55分鐘的摘要，後來開始用影片舉例子，還是直接看影片吧~<br>你會看到許多使用者故事地圖開發的過程和樣子。後來還有說 MVP 的概念，提早驗證、提早學會。把 MVP 分成數個階段，讓每個階段都能透過驗證來學習、改變產品方向。和一些其他秘訣… 像是油畫草稿和 protyotyping和迭代的重要性。</p>\n<p>作者的總結：<br>1. 改變你工作的方式：跟別人說故事，而不只是寫故事<br>2. 用簡單的視覺化去代表你說的故事<br>3. 要把整個故事都放到地圖上，來找出最重要的部分<br>4. 把事情想通：減少產出、增加結果和影響<br>5. 建立最小可行產品測試，來學到什麼是市場中最小的和可行的<br>6. 用疊代和漸進的(原型 / 草稿式)的方式來建造產品</p>\n<p>有效率的故事們能幫助每個人朝向產品成功而工作</p>\n<p>Q &amp; A 從一小時二十分開始<br>—<br>就結構來說是把敏捷開發流程中的待辦事項列表用一個某種可變網狀系統資訊結構取代。</p>\n"},{"title":"做 Prototype 的工具 framer js","date":"2015-11-10T17:11:00.000Z","_content":"\n<div class=\"separator\" style=\"clear: both; text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span></div><div class=\"separator\" style=\"clear: both; text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><iframe allowfullscreen=\"\" class=\"YOUTUBE-iframe-video\" data-thumbnail-src=\"https://i.ytimg.com/vi/mqk9Fw8FKLY/0.jpg\" frameborder=\"0\" height=\"266\" src=\"https://www.youtube.com/embed/mqk9Fw8FKLY?feature=player_embedded\" width=\"320\"></iframe></span></div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">今天逛到一個設計聚會的臉書頁面，他們投票最想學的 Prototype Framework 是 [framerjs](http://framerjs.com/examples/)。一點進去他們網站看，就發現了學 React 一直很缺乏的 Animation 和設計感。後來也發現 React 也有人做 Animation，今年的 ReactEurope 有兩個很好的 Talk，不過先來看這個影片，進修一下、看這個影片教設計師的 prototype 的方法吧。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">framers 是一個創意設計的工具，讓你能建立互動和動畫的 prototype。為什麼要做 prototype？探索和發明新的互動、定義要設計出的感覺是什麼、做有效的概念溝通。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">對我來說最有趣的部分是當你從你的設計中建出互動的 prototype，你會發現很多全新的互動。如果你只是做靜態的 mockup，然後叫其他人做一些 Animation，你會失去跟它玩的機會... 試著反過來做、亂玩參數、試著發明東西。對我來說，這是 prototyping 中最有趣的地方，總之就是東搞西搞一些。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">另一件事是當你談到設計，除了視覺設計外還有很多東西，當你開發 App 或是網頁，更要在意的是它感覺起來怎樣，怎麼互動、怎麼流動，很多視覺設計以外的東西。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">另一件很實際的是當你在團隊中工作，prototype 能讓你很有效的其他人溝通你的新想法。今天我可在這邊給個好例子：「想像你有一個可排序的列表，被選擇的項目會放大和加陰影浮在上面。所有的項目都會對此改變它們的位置。」</span>\n<div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span></div><table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"><tbody><tr><td style=\"text-align: center;\">[<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">![](http://2.bp.blogspot.com/-wrY9GHZtHaw/VkIdrOQKwNI/AAAAAAAA37I/XbVdY5o9Ycc/s320/Screen%2BShot%2B2015-11-11%2Bat%2B12.38.42%2BAM.jpg)</span>](http://2.bp.blogspot.com/-wrY9GHZtHaw/VkIdrOQKwNI/AAAAAAAA37I/XbVdY5o9Ycc/s1600/Screen%2BShot%2B2015-11-11%2Bat%2B12.38.42%2BAM.jpg)</td></tr><tr><td class=\"tr-caption\" style=\"text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif; font-size: small; text-align: start;\">下一步你會做一堆速寫</span></td></tr></tbody></table><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"></span>\n<table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"><tbody><tr><td style=\"text-align: center;\">[<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">![](http://3.bp.blogspot.com/-6rWUYBKS7k0/VkIeBoErK3I/AAAAAAAA37M/1L03PKDkH24/s320/Screen%2BShot%2B2015-11-11%2Bat%2B12.40.18%2BAM.jpg)</span>](http://3.bp.blogspot.com/-6rWUYBKS7k0/VkIeBoErK3I/AAAAAAAA37M/1L03PKDkH24/s1600/Screen%2BShot%2B2015-11-11%2Bat%2B12.40.18%2BAM.jpg)</td></tr><tr><td class=\"tr-caption\" style=\"text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span style=\"font-size: small; text-align: start;\">然後是精美、有陰影的 Mockup</span><span style=\"font-size: small; text-align: start;\">&nbsp;</span></span></td></tr></tbody></table><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"></span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"></span> \n<table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"><tbody><tr><td style=\"text-align: center;\">[<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">![](http://3.bp.blogspot.com/-23vmRgux73A/VkIeZZUKBeI/AAAAAAAA37U/nPxbHQSGxa4/s320/Screen%2BShot%2B2015-11-11%2Bat%2B12.41.49%2BAM.jpg)</span>](http://3.bp.blogspot.com/-23vmRgux73A/VkIeZZUKBeI/AAAAAAAA37U/nPxbHQSGxa4/s1600/Screen%2BShot%2B2015-11-11%2Bat%2B12.41.49%2BAM.jpg)</td></tr><tr><td class=\"tr-caption\" style=\"text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span style=\"font-size: small;\">但我們真正接下來想看到是有動畫能互動的 Prototype</span>\n<span style=\"font-size: small;\">試著做一些操作，移動項目</span></span></td></tr></tbody></table><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span>\n<table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"><tbody><tr><td>[<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">![](http://4.bp.blogspot.com/-A4eiqsrbceU/VkIfT_3IkMI/AAAAAAAA37g/Y5ANpqhC234/s400/Screen%2BShot%2B2015-11-11%2Bat%2B12.45.44%2BAM.jpg)</span>](http://4.bp.blogspot.com/-A4eiqsrbceU/VkIfT_3IkMI/AAAAAAAA37g/Y5ANpqhC234/s1600/Screen%2BShot%2B2015-11-11%2Bat%2B12.45.44%2BAM.jpg)</td></tr><tr><td class=\"tr-caption\" style=\"font-size: 13px;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">animation：after effect / keynote</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">prototyping: ... 一堆，最後一個是framer</span></td></tr></tbody></table><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp;我們今天想著要 prototype 什麼，它實際上就是在設計明天。從概念到執行中間大概可以分成四個階段：Paper -&gt; Sketch / Photoshop -&gt; Framer -&gt; Code。以流程來說，Prototype 大概是在正中間的位置。Prototype 可以往前或往後一點。現在的產品設計流程，通常會做很多靜態的 mockup 但只做一個到兩個 Prototype，我們希望有了更好的 Prototype 工具之後，可以變成三五個 mockup 但做很多的 Prototype。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Framer js 是一個開源的程式庫，提供 Framer Studio Mac App：它提供程式碼編輯器、即時視覺回饋、可以從別的軟體 Import、展示模式。</span>\n<div class=\"separator\" style=\"clear: both; text-align: center;\">\n</div><table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"><tbody><tr><td style=\"text-align: center;\">[<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">![](http://3.bp.blogspot.com/-IshXhNK4H8I/VkImhHSiq4I/AAAAAAAA38E/0fon9gF2umI/s640/Screen%2BShot%2B2015-11-11%2Bat%2B1.14.36%2BAM.jpg)</span>](http://3.bp.blogspot.com/-IshXhNK4H8I/VkImhHSiq4I/AAAAAAAA38E/0fon9gF2umI/s1600/Screen%2BShot%2B2015-11-11%2Bat%2B1.14.36%2BAM.jpg)</td></tr><tr><td class=\"tr-caption\" style=\"text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Framer Studio 可以直接從 Sketch 導入 layer、階層。</span></td></tr></tbody></table><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span>\n<table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"><tbody><tr><td style=\"text-align: center;\">[<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">![](http://1.bp.blogspot.com/-XJVfK-0_q_w/VkIizhFLntI/AAAAAAAA37s/tffawiEgiGI/s640/Screen%2BShot%2B2015-11-11%2Bat%2B1.00.35%2BAM.jpg)</span>](http://1.bp.blogspot.com/-XJVfK-0_q_w/VkIizhFLntI/AAAAAAAA37s/tffawiEgiGI/s1600/Screen%2BShot%2B2015-11-11%2Bat%2B1.00.35%2BAM.jpg)</td></tr><tr><td class=\"tr-caption\" style=\"text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Framer 提供這些功能。</span></td></tr></tbody></table><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Layer 就是一個 Container 可以設定大小、位置、透明度、縮放、圖片、模糊... 一堆屬性。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Animation 讓你從一組 states 過渡到另一組 states。可以設定 curve、延遲、時間長度。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">States 讓你命名一組 states，之後你就可以指定從 XXX 變成 YYY。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Events 讓你可以處理 drag、drop、click、scrolling、touchstart ...</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">開始 Demo Prototype examples &amp; QA 從影片13分15秒。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">---</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">framer 教學影片：</span>https://www.youtube.com/watch?v=3zaxrXK7Nac\n\n從影片中可以看到，設計師是直接把一整張圖當成 Layer 來操作。然後視覺上的元件就當成自訂元件，不用管甚麼 HTML / JSX，然後就對視覺上的這個元件 ( 一張 button 的圖 )，安上click 事件，然後用動畫把另外一張圖換上來...\n\n設計師設計時用不同大小的圖片當成自訂元件，以這樣的元件視角去設計整個 Prototype，看是這張圖要不要模糊、要浮在前面還是後面、要不要讓他可以 Scroll、動畫時要如何從一個 State 變成另外一個 State。\n\n這樣子好直覺啊，一個元件就一張圖，用 sketch 畫畫就好，不像程式設計師要用 HTML / CSS / UIKit 兜好久。\n\nframer 教學影片&nbsp;https://www.youtube.com/watch?v=kJYI4oYrHik\n他們的 script 語法好簡單，超簡潔、超適合簡單的 UI，像 Python 用 indent 代替大括號真的很棒，然後設定 Event 也太簡單。都在操作 Image 超簡單。\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">發現那個 script 叫 coffee script 喔喔喔 看了完全不想寫 Javascript了 XD</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span>","source":"_posts/做-Prototype-的工具-framer-js.md","raw":"---\ntitle: 做 Prototype 的工具 framer js\ntags:\n  - design\n  - framer\n  - prototyping\n  - ui\ndate: 2015-11-11 01:11:00\n---\n\n<div class=\"separator\" style=\"clear: both; text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span></div><div class=\"separator\" style=\"clear: both; text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><iframe allowfullscreen=\"\" class=\"YOUTUBE-iframe-video\" data-thumbnail-src=\"https://i.ytimg.com/vi/mqk9Fw8FKLY/0.jpg\" frameborder=\"0\" height=\"266\" src=\"https://www.youtube.com/embed/mqk9Fw8FKLY?feature=player_embedded\" width=\"320\"></iframe></span></div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">今天逛到一個設計聚會的臉書頁面，他們投票最想學的 Prototype Framework 是 [framerjs](http://framerjs.com/examples/)。一點進去他們網站看，就發現了學 React 一直很缺乏的 Animation 和設計感。後來也發現 React 也有人做 Animation，今年的 ReactEurope 有兩個很好的 Talk，不過先來看這個影片，進修一下、看這個影片教設計師的 prototype 的方法吧。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">framers 是一個創意設計的工具，讓你能建立互動和動畫的 prototype。為什麼要做 prototype？探索和發明新的互動、定義要設計出的感覺是什麼、做有效的概念溝通。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">對我來說最有趣的部分是當你從你的設計中建出互動的 prototype，你會發現很多全新的互動。如果你只是做靜態的 mockup，然後叫其他人做一些 Animation，你會失去跟它玩的機會... 試著反過來做、亂玩參數、試著發明東西。對我來說，這是 prototyping 中最有趣的地方，總之就是東搞西搞一些。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">另一件事是當你談到設計，除了視覺設計外還有很多東西，當你開發 App 或是網頁，更要在意的是它感覺起來怎樣，怎麼互動、怎麼流動，很多視覺設計以外的東西。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">另一件很實際的是當你在團隊中工作，prototype 能讓你很有效的其他人溝通你的新想法。今天我可在這邊給個好例子：「想像你有一個可排序的列表，被選擇的項目會放大和加陰影浮在上面。所有的項目都會對此改變它們的位置。」</span>\n<div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span></div><table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"><tbody><tr><td style=\"text-align: center;\">[<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">![](http://2.bp.blogspot.com/-wrY9GHZtHaw/VkIdrOQKwNI/AAAAAAAA37I/XbVdY5o9Ycc/s320/Screen%2BShot%2B2015-11-11%2Bat%2B12.38.42%2BAM.jpg)</span>](http://2.bp.blogspot.com/-wrY9GHZtHaw/VkIdrOQKwNI/AAAAAAAA37I/XbVdY5o9Ycc/s1600/Screen%2BShot%2B2015-11-11%2Bat%2B12.38.42%2BAM.jpg)</td></tr><tr><td class=\"tr-caption\" style=\"text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif; font-size: small; text-align: start;\">下一步你會做一堆速寫</span></td></tr></tbody></table><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"></span>\n<table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"><tbody><tr><td style=\"text-align: center;\">[<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">![](http://3.bp.blogspot.com/-6rWUYBKS7k0/VkIeBoErK3I/AAAAAAAA37M/1L03PKDkH24/s320/Screen%2BShot%2B2015-11-11%2Bat%2B12.40.18%2BAM.jpg)</span>](http://3.bp.blogspot.com/-6rWUYBKS7k0/VkIeBoErK3I/AAAAAAAA37M/1L03PKDkH24/s1600/Screen%2BShot%2B2015-11-11%2Bat%2B12.40.18%2BAM.jpg)</td></tr><tr><td class=\"tr-caption\" style=\"text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span style=\"font-size: small; text-align: start;\">然後是精美、有陰影的 Mockup</span><span style=\"font-size: small; text-align: start;\">&nbsp;</span></span></td></tr></tbody></table><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"></span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"></span> \n<table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"><tbody><tr><td style=\"text-align: center;\">[<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">![](http://3.bp.blogspot.com/-23vmRgux73A/VkIeZZUKBeI/AAAAAAAA37U/nPxbHQSGxa4/s320/Screen%2BShot%2B2015-11-11%2Bat%2B12.41.49%2BAM.jpg)</span>](http://3.bp.blogspot.com/-23vmRgux73A/VkIeZZUKBeI/AAAAAAAA37U/nPxbHQSGxa4/s1600/Screen%2BShot%2B2015-11-11%2Bat%2B12.41.49%2BAM.jpg)</td></tr><tr><td class=\"tr-caption\" style=\"text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span style=\"font-size: small;\">但我們真正接下來想看到是有動畫能互動的 Prototype</span>\n<span style=\"font-size: small;\">試著做一些操作，移動項目</span></span></td></tr></tbody></table><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span>\n<table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"><tbody><tr><td>[<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">![](http://4.bp.blogspot.com/-A4eiqsrbceU/VkIfT_3IkMI/AAAAAAAA37g/Y5ANpqhC234/s400/Screen%2BShot%2B2015-11-11%2Bat%2B12.45.44%2BAM.jpg)</span>](http://4.bp.blogspot.com/-A4eiqsrbceU/VkIfT_3IkMI/AAAAAAAA37g/Y5ANpqhC234/s1600/Screen%2BShot%2B2015-11-11%2Bat%2B12.45.44%2BAM.jpg)</td></tr><tr><td class=\"tr-caption\" style=\"font-size: 13px;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">animation：after effect / keynote</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">prototyping: ... 一堆，最後一個是framer</span></td></tr></tbody></table><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp;我們今天想著要 prototype 什麼，它實際上就是在設計明天。從概念到執行中間大概可以分成四個階段：Paper -&gt; Sketch / Photoshop -&gt; Framer -&gt; Code。以流程來說，Prototype 大概是在正中間的位置。Prototype 可以往前或往後一點。現在的產品設計流程，通常會做很多靜態的 mockup 但只做一個到兩個 Prototype，我們希望有了更好的 Prototype 工具之後，可以變成三五個 mockup 但做很多的 Prototype。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Framer js 是一個開源的程式庫，提供 Framer Studio Mac App：它提供程式碼編輯器、即時視覺回饋、可以從別的軟體 Import、展示模式。</span>\n<div class=\"separator\" style=\"clear: both; text-align: center;\">\n</div><table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"><tbody><tr><td style=\"text-align: center;\">[<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">![](http://3.bp.blogspot.com/-IshXhNK4H8I/VkImhHSiq4I/AAAAAAAA38E/0fon9gF2umI/s640/Screen%2BShot%2B2015-11-11%2Bat%2B1.14.36%2BAM.jpg)</span>](http://3.bp.blogspot.com/-IshXhNK4H8I/VkImhHSiq4I/AAAAAAAA38E/0fon9gF2umI/s1600/Screen%2BShot%2B2015-11-11%2Bat%2B1.14.36%2BAM.jpg)</td></tr><tr><td class=\"tr-caption\" style=\"text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Framer Studio 可以直接從 Sketch 導入 layer、階層。</span></td></tr></tbody></table><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span>\n<table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"><tbody><tr><td style=\"text-align: center;\">[<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">![](http://1.bp.blogspot.com/-XJVfK-0_q_w/VkIizhFLntI/AAAAAAAA37s/tffawiEgiGI/s640/Screen%2BShot%2B2015-11-11%2Bat%2B1.00.35%2BAM.jpg)</span>](http://1.bp.blogspot.com/-XJVfK-0_q_w/VkIizhFLntI/AAAAAAAA37s/tffawiEgiGI/s1600/Screen%2BShot%2B2015-11-11%2Bat%2B1.00.35%2BAM.jpg)</td></tr><tr><td class=\"tr-caption\" style=\"text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Framer 提供這些功能。</span></td></tr></tbody></table><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Layer 就是一個 Container 可以設定大小、位置、透明度、縮放、圖片、模糊... 一堆屬性。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Animation 讓你從一組 states 過渡到另一組 states。可以設定 curve、延遲、時間長度。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">States 讓你命名一組 states，之後你就可以指定從 XXX 變成 YYY。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Events 讓你可以處理 drag、drop、click、scrolling、touchstart ...</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">開始 Demo Prototype examples &amp; QA 從影片13分15秒。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">---</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">framer 教學影片：</span>https://www.youtube.com/watch?v=3zaxrXK7Nac\n\n從影片中可以看到，設計師是直接把一整張圖當成 Layer 來操作。然後視覺上的元件就當成自訂元件，不用管甚麼 HTML / JSX，然後就對視覺上的這個元件 ( 一張 button 的圖 )，安上click 事件，然後用動畫把另外一張圖換上來...\n\n設計師設計時用不同大小的圖片當成自訂元件，以這樣的元件視角去設計整個 Prototype，看是這張圖要不要模糊、要浮在前面還是後面、要不要讓他可以 Scroll、動畫時要如何從一個 State 變成另外一個 State。\n\n這樣子好直覺啊，一個元件就一張圖，用 sketch 畫畫就好，不像程式設計師要用 HTML / CSS / UIKit 兜好久。\n\nframer 教學影片&nbsp;https://www.youtube.com/watch?v=kJYI4oYrHik\n他們的 script 語法好簡單，超簡潔、超適合簡單的 UI，像 Python 用 indent 代替大括號真的很棒，然後設定 Event 也太簡單。都在操作 Image 超簡單。\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">發現那個 script 叫 coffee script 喔喔喔 看了完全不想寫 Javascript了 XD</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span>","slug":"做-Prototype-的工具-framer-js","published":1,"updated":"2017-12-23T06:08:08.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjblkzcl3000mxq9kybvrim3u","content":"<p><div class=\"separator\" style=\"clear: both; text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></div><div class=\"separator\" style=\"clear: both; text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><iframe allowfullscreen class=\"YOUTUBE-iframe-video\" data-thumbnail-src=\"https://i.ytimg.com/vi/mqk9Fw8FKLY/0.jpg\" frameborder=\"0\" height=\"266\" src=\"https://www.youtube.com/embed/mqk9Fw8FKLY?feature=player_embedded\" width=\"320\"></iframe></span></div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">今天逛到一個設計聚會的臉書頁面，他們投票最想學的 Prototype Framework 是 <a href=\"http://framerjs.com/examples/\" target=\"_blank\" rel=\"noopener\">framerjs</a>。一點進去他們網站看，就發現了學 React 一直很缺乏的 Animation 和設計感。後來也發現 React 也有人做 Animation，今年的 ReactEurope 有兩個很好的 Talk，不過先來看這個影片，進修一下、看這個影片教設計師的 prototype 的方法吧。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">framers 是一個創意設計的工具，讓你能建立互動和動畫的 prototype。為什麼要做 prototype？探索和發明新的互動、定義要設計出的感覺是什麼、做有效的概念溝通。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">對我來說最有趣的部分是當你從你的設計中建出互動的 prototype，你會發現很多全新的互動。如果你只是做靜態的 mockup，然後叫其他人做一些 Animation，你會失去跟它玩的機會… 試著反過來做、亂玩參數、試著發明東西。對我來說，這是 prototyping 中最有趣的地方，總之就是東搞西搞一些。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">另一件事是當你談到設計，除了視覺設計外還有很多東西，當你開發 App 或是網頁，更要在意的是它感覺起來怎樣，怎麼互動、怎麼流動，很多視覺設計以外的東西。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">另一件很實際的是當你在團隊中工作，prototype 能讓你很有效的其他人溝通你的新想法。今天我可在這邊給個好例子：「想像你有一個可排序的列表，被選擇的項目會放大和加陰影浮在上面。所有的項目都會對此改變它們的位置。」</span></p>\n<p><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></div><table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"><tbody><tr><td style=\"text-align: center;\"><a href=\"http://2.bp.blogspot.com/-wrY9GHZtHaw/VkIdrOQKwNI/AAAAAAAA37I/XbVdY5o9Ycc/s1600/Screen%2BShot%2B2015-11-11%2Bat%2B12.38.42%2BAM.jpg\" target=\"_blank\" rel=\"noopener\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><img src=\"http://2.bp.blogspot.com/-wrY9GHZtHaw/VkIdrOQKwNI/AAAAAAAA37I/XbVdY5o9Ycc/s320/Screen%2BShot%2B2015-11-11%2Bat%2B12.38.42%2BAM.jpg\" alt=\"\"></span></a></td></tr><tr><td class=\"tr-caption\" style=\"text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif; font-size: small; text-align: start;\">下一步你會做一堆速寫</span></td></tr></tbody></table><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"></span></p>\n<p><table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"><tbody><tr><td style=\"text-align: center;\"><a href=\"http://3.bp.blogspot.com/-6rWUYBKS7k0/VkIeBoErK3I/AAAAAAAA37M/1L03PKDkH24/s1600/Screen%2BShot%2B2015-11-11%2Bat%2B12.40.18%2BAM.jpg\" target=\"_blank\" rel=\"noopener\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><img src=\"http://3.bp.blogspot.com/-6rWUYBKS7k0/VkIeBoErK3I/AAAAAAAA37M/1L03PKDkH24/s320/Screen%2BShot%2B2015-11-11%2Bat%2B12.40.18%2BAM.jpg\" alt=\"\"></span></a></td></tr><tr><td class=\"tr-caption\" style=\"text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span style=\"font-size: small; text-align: start;\">然後是精美、有陰影的 Mockup</span><span style=\"font-size: small; text-align: start;\">&nbsp;</span></span></td></tr></tbody></table><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"></span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"></span> </p>\n<p><table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"><tbody><tr><td style=\"text-align: center;\"><a href=\"http://3.bp.blogspot.com/-23vmRgux73A/VkIeZZUKBeI/AAAAAAAA37U/nPxbHQSGxa4/s1600/Screen%2BShot%2B2015-11-11%2Bat%2B12.41.49%2BAM.jpg\" target=\"_blank\" rel=\"noopener\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><img src=\"http://3.bp.blogspot.com/-23vmRgux73A/VkIeZZUKBeI/AAAAAAAA37U/nPxbHQSGxa4/s320/Screen%2BShot%2B2015-11-11%2Bat%2B12.41.49%2BAM.jpg\" alt=\"\"></span></a></td></tr><tr><td class=\"tr-caption\" style=\"text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span style=\"font-size: small;\">但我們真正接下來想看到是有動畫能互動的 Prototype</span><br><span style=\"font-size: small;\">試著做一些操作，移動項目</span></span></td></tr></tbody></table><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></p>\n<p><table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"><tbody><tr><td><a href=\"http://4.bp.blogspot.com/-A4eiqsrbceU/VkIfT_3IkMI/AAAAAAAA37g/Y5ANpqhC234/s1600/Screen%2BShot%2B2015-11-11%2Bat%2B12.45.44%2BAM.jpg\" target=\"_blank\" rel=\"noopener\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><img src=\"http://4.bp.blogspot.com/-A4eiqsrbceU/VkIfT_3IkMI/AAAAAAAA37g/Y5ANpqhC234/s400/Screen%2BShot%2B2015-11-11%2Bat%2B12.45.44%2BAM.jpg\" alt=\"\"></span></a></td></tr><tr><td class=\"tr-caption\" style=\"font-size: 13px;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">animation：after effect / keynote</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">prototyping: … 一堆，最後一個是framer</span></td></tr></tbody></table><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp;我們今天想著要 prototype 什麼，它實際上就是在設計明天。從概念到執行中間大概可以分成四個階段：Paper -&gt; Sketch / Photoshop -&gt; Framer -&gt; Code。以流程來說，Prototype 大概是在正中間的位置。Prototype 可以往前或往後一點。現在的產品設計流程，通常會做很多靜態的 mockup 但只做一個到兩個 Prototype，我們希望有了更好的 Prototype 工具之後，可以變成三五個 mockup 但做很多的 Prototype。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Framer js 是一個開源的程式庫，提供 Framer Studio Mac App：它提供程式碼編輯器、即時視覺回饋、可以從別的軟體 Import、展示模式。</span></p>\n<p><div class=\"separator\" style=\"clear: both; text-align: center;\"><br></div><table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"><tbody><tr><td style=\"text-align: center;\"><a href=\"http://3.bp.blogspot.com/-IshXhNK4H8I/VkImhHSiq4I/AAAAAAAA38E/0fon9gF2umI/s1600/Screen%2BShot%2B2015-11-11%2Bat%2B1.14.36%2BAM.jpg\" target=\"_blank\" rel=\"noopener\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><img src=\"http://3.bp.blogspot.com/-IshXhNK4H8I/VkImhHSiq4I/AAAAAAAA38E/0fon9gF2umI/s640/Screen%2BShot%2B2015-11-11%2Bat%2B1.14.36%2BAM.jpg\" alt=\"\"></span></a></td></tr><tr><td class=\"tr-caption\" style=\"text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Framer Studio 可以直接從 Sketch 導入 layer、階層。</span></td></tr></tbody></table><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></p>\n<p><table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"><tbody><tr><td style=\"text-align: center;\"><a href=\"http://1.bp.blogspot.com/-XJVfK-0_q_w/VkIizhFLntI/AAAAAAAA37s/tffawiEgiGI/s1600/Screen%2BShot%2B2015-11-11%2Bat%2B1.00.35%2BAM.jpg\" target=\"_blank\" rel=\"noopener\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><img src=\"http://1.bp.blogspot.com/-XJVfK-0_q_w/VkIizhFLntI/AAAAAAAA37s/tffawiEgiGI/s640/Screen%2BShot%2B2015-11-11%2Bat%2B1.00.35%2BAM.jpg\" alt=\"\"></span></a></td></tr><tr><td class=\"tr-caption\" style=\"text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Framer 提供這些功能。</span></td></tr></tbody></table><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Layer 就是一個 Container 可以設定大小、位置、透明度、縮放、圖片、模糊… 一堆屬性。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Animation 讓你從一組 states 過渡到另一組 states。可以設定 curve、延遲、時間長度。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">States 讓你命名一組 states，之後你就可以指定從 XXX 變成 YYY。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Events 讓你可以處理 drag、drop、click、scrolling、touchstart …</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">開始 Demo Prototype examples &amp; QA 從影片13分15秒。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">—</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">framer 教學影片：</span><a href=\"https://www.youtube.com/watch?v=3zaxrXK7Nac\" target=\"_blank\" rel=\"noopener\">https://www.youtube.com/watch?v=3zaxrXK7Nac</a></p>\n<p>從影片中可以看到，設計師是直接把一整張圖當成 Layer 來操作。然後視覺上的元件就當成自訂元件，不用管甚麼 HTML / JSX，然後就對視覺上的這個元件 ( 一張 button 的圖 )，安上click 事件，然後用動畫把另外一張圖換上來…</p>\n<p>設計師設計時用不同大小的圖片當成自訂元件，以這樣的元件視角去設計整個 Prototype，看是這張圖要不要模糊、要浮在前面還是後面、要不要讓他可以 Scroll、動畫時要如何從一個 State 變成另外一個 State。</p>\n<p>這樣子好直覺啊，一個元件就一張圖，用 sketch 畫畫就好，不像程式設計師要用 HTML / CSS / UIKit 兜好久。</p>\n<p>framer 教學影片&nbsp;<a href=\"https://www.youtube.com/watch?v=kJYI4oYrHik\" target=\"_blank\" rel=\"noopener\">https://www.youtube.com/watch?v=kJYI4oYrHik</a><br>他們的 script 語法好簡單，超簡潔、超適合簡單的 UI，像 Python 用 indent 代替大括號真的很棒，然後設定 Event 也太簡單。都在操作 Image 超簡單。<br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">發現那個 script 叫 coffee script 喔喔喔 看了完全不想寫 Javascript了 XD</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></p>\n","site":{"data":{}},"excerpt":"","more":"<p><div class=\"separator\" style=\"clear: both; text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></div><div class=\"separator\" style=\"clear: both; text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><iframe allowfullscreen class=\"YOUTUBE-iframe-video\" data-thumbnail-src=\"https://i.ytimg.com/vi/mqk9Fw8FKLY/0.jpg\" frameborder=\"0\" height=\"266\" src=\"https://www.youtube.com/embed/mqk9Fw8FKLY?feature=player_embedded\" width=\"320\"></iframe></span></div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">今天逛到一個設計聚會的臉書頁面，他們投票最想學的 Prototype Framework 是 <a href=\"http://framerjs.com/examples/\" target=\"_blank\" rel=\"noopener\">framerjs</a>。一點進去他們網站看，就發現了學 React 一直很缺乏的 Animation 和設計感。後來也發現 React 也有人做 Animation，今年的 ReactEurope 有兩個很好的 Talk，不過先來看這個影片，進修一下、看這個影片教設計師的 prototype 的方法吧。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">framers 是一個創意設計的工具，讓你能建立互動和動畫的 prototype。為什麼要做 prototype？探索和發明新的互動、定義要設計出的感覺是什麼、做有效的概念溝通。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">對我來說最有趣的部分是當你從你的設計中建出互動的 prototype，你會發現很多全新的互動。如果你只是做靜態的 mockup，然後叫其他人做一些 Animation，你會失去跟它玩的機會… 試著反過來做、亂玩參數、試著發明東西。對我來說，這是 prototyping 中最有趣的地方，總之就是東搞西搞一些。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">另一件事是當你談到設計，除了視覺設計外還有很多東西，當你開發 App 或是網頁，更要在意的是它感覺起來怎樣，怎麼互動、怎麼流動，很多視覺設計以外的東西。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">另一件很實際的是當你在團隊中工作，prototype 能讓你很有效的其他人溝通你的新想法。今天我可在這邊給個好例子：「想像你有一個可排序的列表，被選擇的項目會放大和加陰影浮在上面。所有的項目都會對此改變它們的位置。」</span></p>\n<p><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></div><table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"><tbody><tr><td style=\"text-align: center;\"><a href=\"http://2.bp.blogspot.com/-wrY9GHZtHaw/VkIdrOQKwNI/AAAAAAAA37I/XbVdY5o9Ycc/s1600/Screen%2BShot%2B2015-11-11%2Bat%2B12.38.42%2BAM.jpg\" target=\"_blank\" rel=\"noopener\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><img src=\"http://2.bp.blogspot.com/-wrY9GHZtHaw/VkIdrOQKwNI/AAAAAAAA37I/XbVdY5o9Ycc/s320/Screen%2BShot%2B2015-11-11%2Bat%2B12.38.42%2BAM.jpg\" alt=\"\"></span></a></td></tr><tr><td class=\"tr-caption\" style=\"text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif; font-size: small; text-align: start;\">下一步你會做一堆速寫</span></td></tr></tbody></table><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"></span></p>\n<p><table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"><tbody><tr><td style=\"text-align: center;\"><a href=\"http://3.bp.blogspot.com/-6rWUYBKS7k0/VkIeBoErK3I/AAAAAAAA37M/1L03PKDkH24/s1600/Screen%2BShot%2B2015-11-11%2Bat%2B12.40.18%2BAM.jpg\" target=\"_blank\" rel=\"noopener\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><img src=\"http://3.bp.blogspot.com/-6rWUYBKS7k0/VkIeBoErK3I/AAAAAAAA37M/1L03PKDkH24/s320/Screen%2BShot%2B2015-11-11%2Bat%2B12.40.18%2BAM.jpg\" alt=\"\"></span></a></td></tr><tr><td class=\"tr-caption\" style=\"text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span style=\"font-size: small; text-align: start;\">然後是精美、有陰影的 Mockup</span><span style=\"font-size: small; text-align: start;\">&nbsp;</span></span></td></tr></tbody></table><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"></span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"></span> </p>\n<p><table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"><tbody><tr><td style=\"text-align: center;\"><a href=\"http://3.bp.blogspot.com/-23vmRgux73A/VkIeZZUKBeI/AAAAAAAA37U/nPxbHQSGxa4/s1600/Screen%2BShot%2B2015-11-11%2Bat%2B12.41.49%2BAM.jpg\" target=\"_blank\" rel=\"noopener\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><img src=\"http://3.bp.blogspot.com/-23vmRgux73A/VkIeZZUKBeI/AAAAAAAA37U/nPxbHQSGxa4/s320/Screen%2BShot%2B2015-11-11%2Bat%2B12.41.49%2BAM.jpg\" alt=\"\"></span></a></td></tr><tr><td class=\"tr-caption\" style=\"text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span style=\"font-size: small;\">但我們真正接下來想看到是有動畫能互動的 Prototype</span><br><span style=\"font-size: small;\">試著做一些操作，移動項目</span></span></td></tr></tbody></table><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></p>\n<p><table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"><tbody><tr><td><a href=\"http://4.bp.blogspot.com/-A4eiqsrbceU/VkIfT_3IkMI/AAAAAAAA37g/Y5ANpqhC234/s1600/Screen%2BShot%2B2015-11-11%2Bat%2B12.45.44%2BAM.jpg\" target=\"_blank\" rel=\"noopener\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><img src=\"http://4.bp.blogspot.com/-A4eiqsrbceU/VkIfT_3IkMI/AAAAAAAA37g/Y5ANpqhC234/s400/Screen%2BShot%2B2015-11-11%2Bat%2B12.45.44%2BAM.jpg\" alt=\"\"></span></a></td></tr><tr><td class=\"tr-caption\" style=\"font-size: 13px;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">animation：after effect / keynote</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">prototyping: … 一堆，最後一個是framer</span></td></tr></tbody></table><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp;我們今天想著要 prototype 什麼，它實際上就是在設計明天。從概念到執行中間大概可以分成四個階段：Paper -&gt; Sketch / Photoshop -&gt; Framer -&gt; Code。以流程來說，Prototype 大概是在正中間的位置。Prototype 可以往前或往後一點。現在的產品設計流程，通常會做很多靜態的 mockup 但只做一個到兩個 Prototype，我們希望有了更好的 Prototype 工具之後，可以變成三五個 mockup 但做很多的 Prototype。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Framer js 是一個開源的程式庫，提供 Framer Studio Mac App：它提供程式碼編輯器、即時視覺回饋、可以從別的軟體 Import、展示模式。</span></p>\n<p><div class=\"separator\" style=\"clear: both; text-align: center;\"><br></div><table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"><tbody><tr><td style=\"text-align: center;\"><a href=\"http://3.bp.blogspot.com/-IshXhNK4H8I/VkImhHSiq4I/AAAAAAAA38E/0fon9gF2umI/s1600/Screen%2BShot%2B2015-11-11%2Bat%2B1.14.36%2BAM.jpg\" target=\"_blank\" rel=\"noopener\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><img src=\"http://3.bp.blogspot.com/-IshXhNK4H8I/VkImhHSiq4I/AAAAAAAA38E/0fon9gF2umI/s640/Screen%2BShot%2B2015-11-11%2Bat%2B1.14.36%2BAM.jpg\" alt=\"\"></span></a></td></tr><tr><td class=\"tr-caption\" style=\"text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Framer Studio 可以直接從 Sketch 導入 layer、階層。</span></td></tr></tbody></table><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></p>\n<p><table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"><tbody><tr><td style=\"text-align: center;\"><a href=\"http://1.bp.blogspot.com/-XJVfK-0_q_w/VkIizhFLntI/AAAAAAAA37s/tffawiEgiGI/s1600/Screen%2BShot%2B2015-11-11%2Bat%2B1.00.35%2BAM.jpg\" target=\"_blank\" rel=\"noopener\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><img src=\"http://1.bp.blogspot.com/-XJVfK-0_q_w/VkIizhFLntI/AAAAAAAA37s/tffawiEgiGI/s640/Screen%2BShot%2B2015-11-11%2Bat%2B1.00.35%2BAM.jpg\" alt=\"\"></span></a></td></tr><tr><td class=\"tr-caption\" style=\"text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Framer 提供這些功能。</span></td></tr></tbody></table><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Layer 就是一個 Container 可以設定大小、位置、透明度、縮放、圖片、模糊… 一堆屬性。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Animation 讓你從一組 states 過渡到另一組 states。可以設定 curve、延遲、時間長度。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">States 讓你命名一組 states，之後你就可以指定從 XXX 變成 YYY。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Events 讓你可以處理 drag、drop、click、scrolling、touchstart …</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">開始 Demo Prototype examples &amp; QA 從影片13分15秒。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">—</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">framer 教學影片：</span><a href=\"https://www.youtube.com/watch?v=3zaxrXK7Nac\" target=\"_blank\" rel=\"noopener\">https://www.youtube.com/watch?v=3zaxrXK7Nac</a></p>\n<p>從影片中可以看到，設計師是直接把一整張圖當成 Layer 來操作。然後視覺上的元件就當成自訂元件，不用管甚麼 HTML / JSX，然後就對視覺上的這個元件 ( 一張 button 的圖 )，安上click 事件，然後用動畫把另外一張圖換上來…</p>\n<p>設計師設計時用不同大小的圖片當成自訂元件，以這樣的元件視角去設計整個 Prototype，看是這張圖要不要模糊、要浮在前面還是後面、要不要讓他可以 Scroll、動畫時要如何從一個 State 變成另外一個 State。</p>\n<p>這樣子好直覺啊，一個元件就一張圖，用 sketch 畫畫就好，不像程式設計師要用 HTML / CSS / UIKit 兜好久。</p>\n<p>framer 教學影片&nbsp;<a href=\"https://www.youtube.com/watch?v=kJYI4oYrHik\" target=\"_blank\" rel=\"noopener\">https://www.youtube.com/watch?v=kJYI4oYrHik</a><br>他們的 script 語法好簡單，超簡潔、超適合簡單的 UI，像 Python 用 indent 代替大括號真的很棒，然後設定 Event 也太簡單。都在操作 Image 超簡單。<br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">發現那個 script 叫 coffee script 喔喔喔 看了完全不想寫 Javascript了 XD</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></p>\n"},{"title":"函數式編程介紹 ( 1 / 2 )","date":"2015-11-09T10:05:00.000Z","_content":"\n### **<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">函數式編程的專有名詞篇</span>**\n<div>**<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span>**</div>\n\n### <span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><div style=\"font-family: -webkit-standard; font-weight: normal;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">[純函數 ( Pure Function )](https://en.wikipedia.org/wiki/Pure_function)<span style=\"font-weight: normal;\">：</span></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif; font-weight: normal;\">給同樣輸入參數，就會回傳同樣結果的函數，而且沒有任何可觀察到的副作用。Pure Function 的例子：sin(x)。非 Pure Function 的例子：getChar()、random()、還有許多類別中的 member function。從數學上來理解，純函數就是一個數學函數，一個輸入會對到一個輸出。</span></div><div style=\"font-family: -webkit-standard; font-weight: normal;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">純函數的特點：</span></div>\n\n1.  <span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Portable / Self-Documenting ：完全是自給自足的 ( self contained )，沒有外在的依賴 (Dependency)。</span>\n2.  <span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">可暫存 ( Cacheable )：把計算值暫存的技巧被稱作&nbsp;memorization，可以用來避免重複計算，加速程式。</span>\n3.  <span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">好測試 ( Testable )：不需要管上下文和呼叫順序就可以測試。</span>\n4.  <span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">適合平行處理、純函數是線程安全的&nbsp;( thread safe )。</span>\n5.  <span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">[引用透明 ( Referential Transparent )](http://stackoverflow.com/questions/210835/what-is-referential-transparency)：一個引用透明的運算式指的是 如果這個運算式可以被他的值 (回傳值) 替換而不影響整個程式的行為。簡單講就是有可交換性啦。</span>\n6.  <span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">可以熱抽換 ( Hot-Loading )：因為不依賴外部的狀態。</span><div style=\"font-family: -webkit-standard; font-weight: normal;\">\n</div><div style=\"font-family: -webkit-standard; font-weight: normal;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">[副作用 ( Side Effect )](https://en.wikipedia.org/wiki/Side_effect_(computer_science))：<span style=\"font-weight: normal;\">如果一個函數或運算式 ( expression ) 被說有副作用，這指的是它改變了一些狀態 ( states ) 或是 跟呼叫他的函數或外在世界，有可觀察到的互動。舉例來說，一個函數可能會改變全域變數或函數的靜態變數、改變傳進來的參數、引發例外 ( exception )、列印資料到螢幕或是呼叫了其他有副作用的函數。如果有了副作用，函數的行為會受到歷史、執行順序的影響。這樣子一來，想要理解或除錯有副作用的函式會較難，因為就必須要了解他的上下文 ( Context ) 和執行歷史。</span></span></div><div style=\"font-family: -webkit-standard; font-weight: normal;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">顯式 ( Explicit )：形容函數与外界交換資料只有一個唯一管道——参數和回傳值。和顯式的相反是隱式 ( Implicit )。</span></div><div style=\"font-family: -webkit-standard; font-weight: normal;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">[一級函數( First-Class Function](https://en.wikipedia.org/wiki/First-class_function)&nbsp;)：<span style=\"font-weight: normal;\">指的是語言支援把 Function 當成第一類公民，可以支援一般變數的操作，像是把 Function 當成變數傳給另外一個 Function。</span></span></div><div style=\"font-family: -webkit-standard; font-weight: normal;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">[Lambda Function](https://msdn.microsoft.com/zh-tw/library/bb397687.aspx)<span style=\"font-weight: normal;\">：Lambda 運算式是匿名函式，可用來建立委派或運算式樹狀架構類型。</span></span></div><div style=\"font-family: -webkit-standard; font-weight: normal;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">[形式系統 ( Formal System )](https://en.wikipedia.org/wiki/Formal_system)<span style=\"font-weight: normal;\">：形式系統可以的廣泛地被定義為任何基於數學模型的、良好的抽象思考的系統 ( system of abstract thought )。</span></span></div><div style=\"font-family: -webkit-standard; font-weight: normal;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">[Currying](https://en.wikipedia.org/wiki/Currying)<span style=\"font-weight: normal;\">：這個技巧能把接受多參數的函數轉換為多個連續呼叫的單一參數函數。</span></span></div><div style=\"font-family: -webkit-standard; font-weight: normal;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">[閉鎖 ( Closure )](http://stackoverflow.com/questions/111102/how-do-javascript-closures-work)<span style=\"font-weight: normal;\">&nbsp;/&nbsp;</span>[MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures)<span style=\"font-weight: normal;\">：Closure 是可以使用獨立 / 自由變數的函數。換句話說，Closure 記得它</span>實體化<span style=\"font-weight: normal;\">時的環境變數。</span></span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span style=\"font-weight: normal;\">\n</span></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span style=\"font-weight: normal;\">PS：專有名詞那邊引用了很多別人的解釋，可以點前面的連結進去看完整版。</span></span></div></span>\n\n### <span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">-----------------------------------------------------------------------------------------</span>\n<div>[Professor Frisby's Mostly Adequate Guide to Functional Programming](https://drboolean.gitbooks.io/mostly-adequate-guide/)<span style=\"color: #333333; font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp;( 下文是這本書的筆記 )</span></div>\n\n### <span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">**\n**</span>\n\n### <span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">**函數式編程簡介篇**</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">函數式編程的的哲學就是假設副作用 ( side effect ) 是不正確行為的主要原因。所以努力想要控制和管理副作用，經常的解法就是把純函數、單子和不純的函數 ( impure function ) 分開來管理。另外鼓勵大家多寫純函數。我們對待資料要像玩戲法般，一直傳來傳去、禁止使用狀態 ( state ) 和副作用。剛剛這段文字有提到很多專有名詞，但這樣子怎麼寫程式？這邊我開始介紹一個新工具叫 柯里化 ( currying )。</span>\n\n**<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Currying：</span>**\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Currying 把任何的函數轉換成 一連串只做單一事情的函數，各個擊破。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Curring的概念是簡單的。它讓你呼叫<span style=\"color: red;\">函數 A</span> 時可以傳比預期還少的參數。然後這個<span style=\"color: red;\">函數 A</span> 會回傳</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span style=\"color: blue;\">函數 B</span></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">。<span style=\"color: blue;\">函數 B</span>&nbsp;需要的參數是先前沒傳進<span style=\"color: red;\">函數 A</span> 的參數。所以整個流程是：</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">函數A (x, y) 可以等價於下面這段</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">-------------------------------------</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">函數B = 函數A (x)</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">函數B (y)</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">先前傳進去</span><span style=\"color: red; font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">函數 A</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp;的參數會利用閉鎖 ( Closure ) 的方式變成</span><span style=\"color: blue; font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">函數 B</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp;的環境變數。</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">看完上面這段解說，一定會想這什麼鬼東西？來看看&nbsp;[這邊的例子](https://drboolean.gitbooks.io/mostly-adequate-guide/content/ch4.html)&nbsp;會容易理解的多。</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">利用這個技巧，就可以選擇一次傳所有參數或是把參數分幾次傳給數個函數。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">[lodash提供了把函數 curry化的工具](https://lodash.com/docs#curry)，用法：</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">var divide = &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span style=\"color: #38761d;\">function (x,y) { return x / y } </span>可以被改寫成</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">-----------------------------------------------------</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">var divide = curry(&nbsp;</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span style=\"color: #38761d;\">function (x,y) { return x / y }</span> );</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">之後就可以被這樣呼叫</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">divide <span style=\"color: red;\">( x )</span> <span style=\"color: blue;\">( y )</span>;</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">或是</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">var xDividedBy = divide ( x );</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">tenDividedBy ( y );</span>\n\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">PS：這工具的名字是為了紀念一個美國數學家 ---&nbsp;[Haskell Curry](https://en.wikipedia.org/wiki/Haskell_Curry)，跟咖哩沒有關係。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">接下來我們看另外一個工具 代碼組成( compose )。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">**組合 / 組成 / 合成 ( compose )**：</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Composition 把許多函數用管子 ( pipe ) 連接起來，變成一個新個函數。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span>\n<table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"><tbody><tr><td style=\"text-align: center;\">[![](http://2.bp.blogspot.com/-eFzwVuCTVaU/VkBsgOAPFuI/AAAAAAAA36k/2G6L_UmPZjI/s320/Screen%2BShot%2B2015-11-09%2Bat%2B5.50.05%2BPM.jpg)](http://2.bp.blogspot.com/-eFzwVuCTVaU/VkBsgOAPFuI/AAAAAAAA36k/2G6L_UmPZjI/s1600/Screen%2BShot%2B2015-11-09%2Bat%2B5.50.05%2BPM.jpg)</td></tr><tr><td class=\"tr-caption\" style=\"text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">f, g 都是函數，x 在它們之間被傳遞。\n注意g函數的參數是 x、f函數的參數是 g函數的回傳值。\n較常用在 f &amp; g 都吃同一類參數的時候 (ex: 字串)。</span></td></tr></tbody></table><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">例子：變大寫和去空白函數 = compose (變大寫函數, 去空白函數)</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">因為有了一級函數、Currying、組合，Pointfree 風格變得流行了起來，指的是函數呼叫時不用提到它要處理的資料。例如：</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span style=\"color: #674ea7;\">var</span> snakeCase = <span style=\"color: #674ea7;\">function</span> ( <span style=\"background-color: #ffd966;\">**word**</span> ) {</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp; &nbsp;<span style=\"color: #674ea7;\">&nbsp; &nbsp;return</span><span style=\"color: magenta;\"> </span><span style=\"background-color: #ffd966;\">**word**</span>.toUpperCase( ).replace(&nbsp;<span style=\"color: #e06666;\">/\\s+/ig</span>, <span style=\"color: #6aa84f;\">'_'&nbsp;</span>);</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">}&nbsp;</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">可被改寫成</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">-----------------------------------------------</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span style=\"color: #674ea7;\">var</span> snakeCase = compose (&nbsp;</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">replace(&nbsp;</span><span style=\"color: #e06666; font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">/\\s+/ig</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">,&nbsp;</span><span style=\"color: #6aa84f; font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">'_'&nbsp;</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">), toLowerCase );</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">用組合形成新函數就不用提到資料 --- 也就是之前寫法中的 **word**</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">**\n**</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Pointfree的編程風格可以讓我們移除不需要的名字 (names)，讓我們保持簡潔 ( concise ) 和一般化 / 泛型 ( generic )。但要小心 Pointfree 是個雙面刃，有時會把原來的目的變得模糊。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">( 以上是書本前五章的內容，其他待續... 後面有點硬，不知道什麼時候會看。)</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span style=\"background-color: #f6f6f6; color: #333333;\">\n</span></span><span style=\"color: #333333; font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span style=\"background-color: #f6f6f6;\">---</span></span>\n<span style=\"color: #333333; font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span style=\"background-color: #f6f6f6;\">這篇文介紹得很好&nbsp;[函數式編程](http://coolshell.cn/articles/10822.html)</span></span>","source":"_posts/函數式編程介紹-1-2.md","raw":"---\ntitle: 函數式編程介紹 ( 1 / 2 )\ntags:\n  - composition\n  - currying\n  - functional programming\n  - pure function\ndate: 2015-11-09 18:05:00\n---\n\n### **<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">函數式編程的專有名詞篇</span>**\n<div>**<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span>**</div>\n\n### <span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><div style=\"font-family: -webkit-standard; font-weight: normal;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">[純函數 ( Pure Function )](https://en.wikipedia.org/wiki/Pure_function)<span style=\"font-weight: normal;\">：</span></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif; font-weight: normal;\">給同樣輸入參數，就會回傳同樣結果的函數，而且沒有任何可觀察到的副作用。Pure Function 的例子：sin(x)。非 Pure Function 的例子：getChar()、random()、還有許多類別中的 member function。從數學上來理解，純函數就是一個數學函數，一個輸入會對到一個輸出。</span></div><div style=\"font-family: -webkit-standard; font-weight: normal;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">純函數的特點：</span></div>\n\n1.  <span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Portable / Self-Documenting ：完全是自給自足的 ( self contained )，沒有外在的依賴 (Dependency)。</span>\n2.  <span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">可暫存 ( Cacheable )：把計算值暫存的技巧被稱作&nbsp;memorization，可以用來避免重複計算，加速程式。</span>\n3.  <span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">好測試 ( Testable )：不需要管上下文和呼叫順序就可以測試。</span>\n4.  <span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">適合平行處理、純函數是線程安全的&nbsp;( thread safe )。</span>\n5.  <span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">[引用透明 ( Referential Transparent )](http://stackoverflow.com/questions/210835/what-is-referential-transparency)：一個引用透明的運算式指的是 如果這個運算式可以被他的值 (回傳值) 替換而不影響整個程式的行為。簡單講就是有可交換性啦。</span>\n6.  <span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">可以熱抽換 ( Hot-Loading )：因為不依賴外部的狀態。</span><div style=\"font-family: -webkit-standard; font-weight: normal;\">\n</div><div style=\"font-family: -webkit-standard; font-weight: normal;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">[副作用 ( Side Effect )](https://en.wikipedia.org/wiki/Side_effect_(computer_science))：<span style=\"font-weight: normal;\">如果一個函數或運算式 ( expression ) 被說有副作用，這指的是它改變了一些狀態 ( states ) 或是 跟呼叫他的函數或外在世界，有可觀察到的互動。舉例來說，一個函數可能會改變全域變數或函數的靜態變數、改變傳進來的參數、引發例外 ( exception )、列印資料到螢幕或是呼叫了其他有副作用的函數。如果有了副作用，函數的行為會受到歷史、執行順序的影響。這樣子一來，想要理解或除錯有副作用的函式會較難，因為就必須要了解他的上下文 ( Context ) 和執行歷史。</span></span></div><div style=\"font-family: -webkit-standard; font-weight: normal;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">顯式 ( Explicit )：形容函數与外界交換資料只有一個唯一管道——参數和回傳值。和顯式的相反是隱式 ( Implicit )。</span></div><div style=\"font-family: -webkit-standard; font-weight: normal;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">[一級函數( First-Class Function](https://en.wikipedia.org/wiki/First-class_function)&nbsp;)：<span style=\"font-weight: normal;\">指的是語言支援把 Function 當成第一類公民，可以支援一般變數的操作，像是把 Function 當成變數傳給另外一個 Function。</span></span></div><div style=\"font-family: -webkit-standard; font-weight: normal;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">[Lambda Function](https://msdn.microsoft.com/zh-tw/library/bb397687.aspx)<span style=\"font-weight: normal;\">：Lambda 運算式是匿名函式，可用來建立委派或運算式樹狀架構類型。</span></span></div><div style=\"font-family: -webkit-standard; font-weight: normal;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">[形式系統 ( Formal System )](https://en.wikipedia.org/wiki/Formal_system)<span style=\"font-weight: normal;\">：形式系統可以的廣泛地被定義為任何基於數學模型的、良好的抽象思考的系統 ( system of abstract thought )。</span></span></div><div style=\"font-family: -webkit-standard; font-weight: normal;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">[Currying](https://en.wikipedia.org/wiki/Currying)<span style=\"font-weight: normal;\">：這個技巧能把接受多參數的函數轉換為多個連續呼叫的單一參數函數。</span></span></div><div style=\"font-family: -webkit-standard; font-weight: normal;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">[閉鎖 ( Closure )](http://stackoverflow.com/questions/111102/how-do-javascript-closures-work)<span style=\"font-weight: normal;\">&nbsp;/&nbsp;</span>[MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures)<span style=\"font-weight: normal;\">：Closure 是可以使用獨立 / 自由變數的函數。換句話說，Closure 記得它</span>實體化<span style=\"font-weight: normal;\">時的環境變數。</span></span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span style=\"font-weight: normal;\">\n</span></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span style=\"font-weight: normal;\">PS：專有名詞那邊引用了很多別人的解釋，可以點前面的連結進去看完整版。</span></span></div></span>\n\n### <span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">-----------------------------------------------------------------------------------------</span>\n<div>[Professor Frisby's Mostly Adequate Guide to Functional Programming](https://drboolean.gitbooks.io/mostly-adequate-guide/)<span style=\"color: #333333; font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp;( 下文是這本書的筆記 )</span></div>\n\n### <span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">**\n**</span>\n\n### <span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">**函數式編程簡介篇**</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">函數式編程的的哲學就是假設副作用 ( side effect ) 是不正確行為的主要原因。所以努力想要控制和管理副作用，經常的解法就是把純函數、單子和不純的函數 ( impure function ) 分開來管理。另外鼓勵大家多寫純函數。我們對待資料要像玩戲法般，一直傳來傳去、禁止使用狀態 ( state ) 和副作用。剛剛這段文字有提到很多專有名詞，但這樣子怎麼寫程式？這邊我開始介紹一個新工具叫 柯里化 ( currying )。</span>\n\n**<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Currying：</span>**\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Currying 把任何的函數轉換成 一連串只做單一事情的函數，各個擊破。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Curring的概念是簡單的。它讓你呼叫<span style=\"color: red;\">函數 A</span> 時可以傳比預期還少的參數。然後這個<span style=\"color: red;\">函數 A</span> 會回傳</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span style=\"color: blue;\">函數 B</span></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">。<span style=\"color: blue;\">函數 B</span>&nbsp;需要的參數是先前沒傳進<span style=\"color: red;\">函數 A</span> 的參數。所以整個流程是：</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">函數A (x, y) 可以等價於下面這段</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">-------------------------------------</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">函數B = 函數A (x)</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">函數B (y)</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">先前傳進去</span><span style=\"color: red; font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">函數 A</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp;的參數會利用閉鎖 ( Closure ) 的方式變成</span><span style=\"color: blue; font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">函數 B</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp;的環境變數。</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">看完上面這段解說，一定會想這什麼鬼東西？來看看&nbsp;[這邊的例子](https://drboolean.gitbooks.io/mostly-adequate-guide/content/ch4.html)&nbsp;會容易理解的多。</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">利用這個技巧，就可以選擇一次傳所有參數或是把參數分幾次傳給數個函數。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">[lodash提供了把函數 curry化的工具](https://lodash.com/docs#curry)，用法：</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">var divide = &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span style=\"color: #38761d;\">function (x,y) { return x / y } </span>可以被改寫成</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">-----------------------------------------------------</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">var divide = curry(&nbsp;</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span style=\"color: #38761d;\">function (x,y) { return x / y }</span> );</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">之後就可以被這樣呼叫</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">divide <span style=\"color: red;\">( x )</span> <span style=\"color: blue;\">( y )</span>;</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">或是</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">var xDividedBy = divide ( x );</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">tenDividedBy ( y );</span>\n\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">PS：這工具的名字是為了紀念一個美國數學家 ---&nbsp;[Haskell Curry](https://en.wikipedia.org/wiki/Haskell_Curry)，跟咖哩沒有關係。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">接下來我們看另外一個工具 代碼組成( compose )。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">**組合 / 組成 / 合成 ( compose )**：</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Composition 把許多函數用管子 ( pipe ) 連接起來，變成一個新個函數。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span>\n<table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"><tbody><tr><td style=\"text-align: center;\">[![](http://2.bp.blogspot.com/-eFzwVuCTVaU/VkBsgOAPFuI/AAAAAAAA36k/2G6L_UmPZjI/s320/Screen%2BShot%2B2015-11-09%2Bat%2B5.50.05%2BPM.jpg)](http://2.bp.blogspot.com/-eFzwVuCTVaU/VkBsgOAPFuI/AAAAAAAA36k/2G6L_UmPZjI/s1600/Screen%2BShot%2B2015-11-09%2Bat%2B5.50.05%2BPM.jpg)</td></tr><tr><td class=\"tr-caption\" style=\"text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">f, g 都是函數，x 在它們之間被傳遞。\n注意g函數的參數是 x、f函數的參數是 g函數的回傳值。\n較常用在 f &amp; g 都吃同一類參數的時候 (ex: 字串)。</span></td></tr></tbody></table><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">例子：變大寫和去空白函數 = compose (變大寫函數, 去空白函數)</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">因為有了一級函數、Currying、組合，Pointfree 風格變得流行了起來，指的是函數呼叫時不用提到它要處理的資料。例如：</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span style=\"color: #674ea7;\">var</span> snakeCase = <span style=\"color: #674ea7;\">function</span> ( <span style=\"background-color: #ffd966;\">**word**</span> ) {</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp; &nbsp;<span style=\"color: #674ea7;\">&nbsp; &nbsp;return</span><span style=\"color: magenta;\"> </span><span style=\"background-color: #ffd966;\">**word**</span>.toUpperCase( ).replace(&nbsp;<span style=\"color: #e06666;\">/\\s+/ig</span>, <span style=\"color: #6aa84f;\">'_'&nbsp;</span>);</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">}&nbsp;</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">可被改寫成</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">-----------------------------------------------</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span style=\"color: #674ea7;\">var</span> snakeCase = compose (&nbsp;</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">replace(&nbsp;</span><span style=\"color: #e06666; font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">/\\s+/ig</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">,&nbsp;</span><span style=\"color: #6aa84f; font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">'_'&nbsp;</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">), toLowerCase );</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">用組合形成新函數就不用提到資料 --- 也就是之前寫法中的 **word**</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">**\n**</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Pointfree的編程風格可以讓我們移除不需要的名字 (names)，讓我們保持簡潔 ( concise ) 和一般化 / 泛型 ( generic )。但要小心 Pointfree 是個雙面刃，有時會把原來的目的變得模糊。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">( 以上是書本前五章的內容，其他待續... 後面有點硬，不知道什麼時候會看。)</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span style=\"background-color: #f6f6f6; color: #333333;\">\n</span></span><span style=\"color: #333333; font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span style=\"background-color: #f6f6f6;\">---</span></span>\n<span style=\"color: #333333; font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span style=\"background-color: #f6f6f6;\">這篇文介紹得很好&nbsp;[函數式編程](http://coolshell.cn/articles/10822.html)</span></span>","slug":"函數式編程介紹-1-2","published":1,"updated":"2017-12-23T06:08:08.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjblkzcl9000oxq9k1qfr42jm","content":"<h3 id=\"函數式編程的專有名詞篇\"><a href=\"#函數式編程的專有名詞篇\" class=\"headerlink\" title=\"函數式編程的專有名詞篇\"></a><strong><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">函數式編程的專有名詞篇</span></strong></h3><div><strong><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></strong></div>\n\n<h3 id=\"純函數-Pure-Function-：給同樣輸入參數，就會回傳同樣結果的函數，而且沒有任何可觀察到的副作用。Pure-Function-的例子：sin-x-。非-Pure-Function-的例子：getChar-、random-、還有許多類別中的-member-function。從數學上來理解，純函數就是一個數學函數，一個輸入會對到一個輸出。\"><a href=\"#純函數-Pure-Function-：給同樣輸入參數，就會回傳同樣結果的函數，而且沒有任何可觀察到的副作用。Pure-Function-的例子：sin-x-。非-Pure-Function-的例子：getChar-、random-、還有許多類別中的-member-function。從數學上來理解，純函數就是一個數學函數，一個輸入會對到一個輸出。\" class=\"headerlink\" title=\"純函數 ( Pure Function )：給同樣輸入參數，就會回傳同樣結果的函數，而且沒有任何可觀察到的副作用。Pure Function 的例子：sin(x)。非 Pure Function 的例子：getChar()、random()、還有許多類別中的 member function。從數學上來理解，純函數就是一個數學函數，一個輸入會對到一個輸出。\"></a><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><div style=\"font-family: -webkit-standard; font-weight: normal;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><a href=\"https://en.wikipedia.org/wiki/Pure_function\" target=\"_blank\" rel=\"noopener\">純函數 ( Pure Function )</a><span style=\"font-weight: normal;\">：</span></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif; font-weight: normal;\">給同樣輸入參數，就會回傳同樣結果的函數，而且沒有任何可觀察到的副作用。Pure Function 的例子：sin(x)。非 Pure Function 的例子：getChar()、random()、還有許多類別中的 member function。從數學上來理解，純函數就是一個數學函數，一個輸入會對到一個輸出。</span></div><div style=\"font-family: -webkit-standard; font-weight: normal;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"></span></div></span></h3><p><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">純函數的特點：</span></p>\n<ol>\n<li><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Portable / Self-Documenting ：完全是自給自足的 ( self contained )，沒有外在的依賴 (Dependency)。</span></li>\n<li><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">可暫存 ( Cacheable )：把計算值暫存的技巧被稱作&nbsp;memorization，可以用來避免重複計算，加速程式。</span></li>\n<li><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">好測試 ( Testable )：不需要管上下文和呼叫順序就可以測試。</span></li>\n<li><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">適合平行處理、純函數是線程安全的&nbsp;( thread safe )。</span></li>\n<li><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><a href=\"http://stackoverflow.com/questions/210835/what-is-referential-transparency\" target=\"_blank\" rel=\"noopener\">引用透明 ( Referential Transparent )</a>：一個引用透明的運算式指的是 如果這個運算式可以被他的值 (回傳值) 替換而不影響整個程式的行為。簡單講就是有可交換性啦。</span></li>\n<li><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">可以熱抽換 ( Hot-Loading )：因為不依賴外部的狀態。</span><div style=\"font-family: -webkit-standard; font-weight: normal;\"><br></div><div style=\"font-family: -webkit-standard; font-weight: normal;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><a href=\"https://en.wikipedia.org/wiki/Side_effect_(computer_science\" target=\"_blank\" rel=\"noopener\">副作用 ( Side Effect )</a>)：<span style=\"font-weight: normal;\">如果一個函數或運算式 ( expression ) 被說有副作用，這指的是它改變了一些狀態 ( states ) 或是 跟呼叫他的函數或外在世界，有可觀察到的互動。舉例來說，一個函數可能會改變全域變數或函數的靜態變數、改變傳進來的參數、引發例外 ( exception )、列印資料到螢幕或是呼叫了其他有副作用的函數。如果有了副作用，函數的行為會受到歷史、執行順序的影響。這樣子一來，想要理解或除錯有副作用的函式會較難，因為就必須要了解他的上下文 ( Context ) 和執行歷史。</span></span></div><div style=\"font-family: -webkit-standard; font-weight: normal;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">顯式 ( Explicit )：形容函數与外界交換資料只有一個唯一管道——参數和回傳值。和顯式的相反是隱式 ( Implicit )。</span></div><div style=\"font-family: -webkit-standard; font-weight: normal;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><a href=\"https://en.wikipedia.org/wiki/First-class_function\" target=\"_blank\" rel=\"noopener\">一級函數( First-Class Function</a>&nbsp;)：<span style=\"font-weight: normal;\">指的是語言支援把 Function 當成第一類公民，可以支援一般變數的操作，像是把 Function 當成變數傳給另外一個 Function。</span></span></div><div style=\"font-family: -webkit-standard; font-weight: normal;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><a href=\"https://msdn.microsoft.com/zh-tw/library/bb397687.aspx\" target=\"_blank\" rel=\"noopener\">Lambda Function</a><span style=\"font-weight: normal;\">：Lambda 運算式是匿名函式，可用來建立委派或運算式樹狀架構類型。</span></span></div><div style=\"font-family: -webkit-standard; font-weight: normal;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><a href=\"https://en.wikipedia.org/wiki/Formal_system\" target=\"_blank\" rel=\"noopener\">形式系統 ( Formal System )</a><span style=\"font-weight: normal;\">：形式系統可以的廣泛地被定義為任何基於數學模型的、良好的抽象思考的系統 ( system of abstract thought )。</span></span></div><div style=\"font-family: -webkit-standard; font-weight: normal;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><a href=\"https://en.wikipedia.org/wiki/Currying\" target=\"_blank\" rel=\"noopener\">Currying</a><span style=\"font-weight: normal;\">：這個技巧能把接受多參數的函數轉換為多個連續呼叫的單一參數函數。</span></span></div><div style=\"font-family: -webkit-standard; font-weight: normal;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><a href=\"http://stackoverflow.com/questions/111102/how-do-javascript-closures-work\" target=\"_blank\" rel=\"noopener\">閉鎖 ( Closure )</a><span style=\"font-weight: normal;\">&nbsp;/&nbsp;</span><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures\" target=\"_blank\" rel=\"noopener\">MDN</a><span style=\"font-weight: normal;\">：Closure 是可以使用獨立 / 自由變數的函數。換句話說，Closure 記得它</span>實體化<span style=\"font-weight: normal;\">時的環境變數。</span></span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span style=\"font-weight: normal;\"><br></span></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span style=\"font-weight: normal;\">PS：專有名詞那邊引用了很多別人的解釋，可以點前面的連結進去看完整版。</span></span></div></li>\n</ol>\n<h3 id=\"—————————————————————————————–\"><a href=\"#—————————————————————————————–\" class=\"headerlink\" title=\"—————————————————————————————–\"></a><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">—————————————————————————————–</span></h3><div><a href=\"https://drboolean.gitbooks.io/mostly-adequate-guide/\" target=\"_blank\" rel=\"noopener\">Professor Frisby’s Mostly Adequate Guide to Functional Programming</a><span style=\"color: #333333; font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp;( 下文是這本書的筆記 )</span></div>\n\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"**\"></a><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">**</span></h3><p>**</p>\n<h3 id=\"函數式編程簡介篇\"><a href=\"#函數式編程簡介篇\" class=\"headerlink\" title=\"函數式編程簡介篇\"></a><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><strong>函數式編程簡介篇</strong></span></h3><p><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">函數式編程的的哲學就是假設副作用 ( side effect ) 是不正確行為的主要原因。所以努力想要控制和管理副作用，經常的解法就是把純函數、單子和不純的函數 ( impure function ) 分開來管理。另外鼓勵大家多寫純函數。我們對待資料要像玩戲法般，一直傳來傳去、禁止使用狀態 ( state ) 和副作用。剛剛這段文字有提到很多專有名詞，但這樣子怎麼寫程式？這邊我開始介紹一個新工具叫 柯里化 ( currying )。</span></p>\n<p><strong><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Currying：</span></strong><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Currying 把任何的函數轉換成 一連串只做單一事情的函數，各個擊破。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Curring的概念是簡單的。它讓你呼叫<span style=\"color: red;\">函數 A</span> 時可以傳比預期還少的參數。然後這個<span style=\"color: red;\">函數 A</span> 會回傳</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span style=\"color: blue;\">函數 B</span></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">。<span style=\"color: blue;\">函數 B</span>&nbsp;需要的參數是先前沒傳進<span style=\"color: red;\">函數 A</span> 的參數。所以整個流程是：</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">函數A (x, y) 可以等價於下面這段</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">————————————-</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">函數B = 函數A (x)</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">函數B (y)</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">先前傳進去</span><span style=\"color: red; font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">函數 A</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp;的參數會利用閉鎖 ( Closure ) 的方式變成</span><span style=\"color: blue; font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">函數 B</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp;的環境變數。</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">看完上面這段解說，一定會想這什麼鬼東西？來看看&nbsp;<a href=\"https://drboolean.gitbooks.io/mostly-adequate-guide/content/ch4.html\" target=\"_blank\" rel=\"noopener\">這邊的例子</a>&nbsp;會容易理解的多。</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">利用這個技巧，就可以選擇一次傳所有參數或是把參數分幾次傳給數個函數。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><a href=\"https://lodash.com/docs#curry\" target=\"_blank\" rel=\"noopener\">lodash提供了把函數 curry化的工具</a>，用法：</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">var divide = &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span style=\"color: #38761d;\">function (x,y) { return x / y } </span>可以被改寫成</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">—————————————————–</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">var divide = curry(&nbsp;</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span style=\"color: #38761d;\">function (x,y) { return x / y }</span> );</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">之後就可以被這樣呼叫</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">divide <span style=\"color: red;\">( x )</span> <span style=\"color: blue;\">( y )</span>;</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">或是</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">var xDividedBy = divide ( x );</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">tenDividedBy ( y );</span></p>\n<p><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">PS：這工具的名字是為了紀念一個美國數學家 —&nbsp;<a href=\"https://en.wikipedia.org/wiki/Haskell_Curry\" target=\"_blank\" rel=\"noopener\">Haskell Curry</a>，跟咖哩沒有關係。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">接下來我們看另外一個工具 代碼組成( compose )。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><strong>組合 / 組成 / 合成 ( compose )</strong>：</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Composition 把許多函數用管子 ( pipe ) 連接起來，變成一個新個函數。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></p>\n<p><table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"><tbody><tr><td style=\"text-align: center;\"><a href=\"http://2.bp.blogspot.com/-eFzwVuCTVaU/VkBsgOAPFuI/AAAAAAAA36k/2G6L_UmPZjI/s1600/Screen%2BShot%2B2015-11-09%2Bat%2B5.50.05%2BPM.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://2.bp.blogspot.com/-eFzwVuCTVaU/VkBsgOAPFuI/AAAAAAAA36k/2G6L_UmPZjI/s320/Screen%2BShot%2B2015-11-09%2Bat%2B5.50.05%2BPM.jpg\" alt=\"\"></a></td></tr><tr><td class=\"tr-caption\" style=\"text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">f, g 都是函數，x 在它們之間被傳遞。<br>注意g函數的參數是 x、f函數的參數是 g函數的回傳值。<br>較常用在 f &amp; g 都吃同一類參數的時候 (ex: 字串)。</span></td></tr></tbody></table><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">例子：變大寫和去空白函數 = compose (變大寫函數, 去空白函數)</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">因為有了一級函數、Currying、組合，Pointfree 風格變得流行了起來，指的是函數呼叫時不用提到它要處理的資料。例如：</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span style=\"color: #674ea7;\">var</span> snakeCase = <span style=\"color: #674ea7;\">function</span> ( <span style=\"background-color: #ffd966;\"><strong>word</strong></span> ) {</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp; &nbsp;<span style=\"color: #674ea7;\">&nbsp; &nbsp;return</span><span style=\"color: magenta;\"> </span><span style=\"background-color: #ffd966;\"><strong>word</strong></span>.toUpperCase( ).replace(&nbsp;<span style=\"color: #e06666;\">/\\s+/ig</span>, <span style=\"color: #6aa84f;\">‘<em>‘&nbsp;</em></span>);</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">}&nbsp;</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">可被改寫成</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">———————————————–</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span style=\"color: #674ea7;\">var</span> snakeCase = compose (&nbsp;</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">replace(&nbsp;</span><span style=\"color: #e06666; font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">/\\s+/ig</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">,&nbsp;</span><span style=\"color: #6aa84f; font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">‘‘&nbsp;</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">), toLowerCase );</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">用組合形成新函數就不用提到資料 — 也就是之前寫法中的 <strong>word</strong></span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><strong>\n</strong></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Pointfree的編程風格可以讓我們移除不需要的名字 (names)，讓我們保持簡潔 ( concise ) 和一般化 / 泛型 ( generic )。但要小心 Pointfree 是個雙面刃，有時會把原來的目的變得模糊。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">( 以上是書本前五章的內容，其他待續… 後面有點硬，不知道什麼時候會看。)</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span style=\"background-color: #f6f6f6; color: #333333;\"><br></span></span><span style=\"color: #333333; font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span style=\"background-color: #f6f6f6;\">—</span></span><br><span style=\"color: #333333; font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span style=\"background-color: #f6f6f6;\">這篇文介紹得很好&nbsp;<a href=\"http://coolshell.cn/articles/10822.html\" target=\"_blank\" rel=\"noopener\">函數式編程</a></span></span></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"函數式編程的專有名詞篇\"><a href=\"#函數式編程的專有名詞篇\" class=\"headerlink\" title=\"函數式編程的專有名詞篇\"></a><strong><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">函數式編程的專有名詞篇</span></strong></h3><div><strong><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></strong></div>\n\n<h3 id=\"純函數-Pure-Function-：給同樣輸入參數，就會回傳同樣結果的函數，而且沒有任何可觀察到的副作用。Pure-Function-的例子：sin-x-。非-Pure-Function-的例子：getChar-、random-、還有許多類別中的-member-function。從數學上來理解，純函數就是一個數學函數，一個輸入會對到一個輸出。\"><a href=\"#純函數-Pure-Function-：給同樣輸入參數，就會回傳同樣結果的函數，而且沒有任何可觀察到的副作用。Pure-Function-的例子：sin-x-。非-Pure-Function-的例子：getChar-、random-、還有許多類別中的-member-function。從數學上來理解，純函數就是一個數學函數，一個輸入會對到一個輸出。\" class=\"headerlink\" title=\"純函數 ( Pure Function )：給同樣輸入參數，就會回傳同樣結果的函數，而且沒有任何可觀察到的副作用。Pure Function 的例子：sin(x)。非 Pure Function 的例子：getChar()、random()、還有許多類別中的 member function。從數學上來理解，純函數就是一個數學函數，一個輸入會對到一個輸出。\"></a><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><div style=\"font-family: -webkit-standard; font-weight: normal;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><a href=\"https://en.wikipedia.org/wiki/Pure_function\" target=\"_blank\" rel=\"noopener\">純函數 ( Pure Function )</a><span style=\"font-weight: normal;\">：</span></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif; font-weight: normal;\">給同樣輸入參數，就會回傳同樣結果的函數，而且沒有任何可觀察到的副作用。Pure Function 的例子：sin(x)。非 Pure Function 的例子：getChar()、random()、還有許多類別中的 member function。從數學上來理解，純函數就是一個數學函數，一個輸入會對到一個輸出。</span></div><div style=\"font-family: -webkit-standard; font-weight: normal;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"></span></div></span></h3><p><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">純函數的特點：</span></p>\n<ol>\n<li><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Portable / Self-Documenting ：完全是自給自足的 ( self contained )，沒有外在的依賴 (Dependency)。</span></li>\n<li><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">可暫存 ( Cacheable )：把計算值暫存的技巧被稱作&nbsp;memorization，可以用來避免重複計算，加速程式。</span></li>\n<li><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">好測試 ( Testable )：不需要管上下文和呼叫順序就可以測試。</span></li>\n<li><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">適合平行處理、純函數是線程安全的&nbsp;( thread safe )。</span></li>\n<li><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><a href=\"http://stackoverflow.com/questions/210835/what-is-referential-transparency\" target=\"_blank\" rel=\"noopener\">引用透明 ( Referential Transparent )</a>：一個引用透明的運算式指的是 如果這個運算式可以被他的值 (回傳值) 替換而不影響整個程式的行為。簡單講就是有可交換性啦。</span></li>\n<li><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">可以熱抽換 ( Hot-Loading )：因為不依賴外部的狀態。</span><div style=\"font-family: -webkit-standard; font-weight: normal;\"><br></div><div style=\"font-family: -webkit-standard; font-weight: normal;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><a href=\"https://en.wikipedia.org/wiki/Side_effect_(computer_science\" target=\"_blank\" rel=\"noopener\">副作用 ( Side Effect )</a>)：<span style=\"font-weight: normal;\">如果一個函數或運算式 ( expression ) 被說有副作用，這指的是它改變了一些狀態 ( states ) 或是 跟呼叫他的函數或外在世界，有可觀察到的互動。舉例來說，一個函數可能會改變全域變數或函數的靜態變數、改變傳進來的參數、引發例外 ( exception )、列印資料到螢幕或是呼叫了其他有副作用的函數。如果有了副作用，函數的行為會受到歷史、執行順序的影響。這樣子一來，想要理解或除錯有副作用的函式會較難，因為就必須要了解他的上下文 ( Context ) 和執行歷史。</span></span></div><div style=\"font-family: -webkit-standard; font-weight: normal;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">顯式 ( Explicit )：形容函數与外界交換資料只有一個唯一管道——参數和回傳值。和顯式的相反是隱式 ( Implicit )。</span></div><div style=\"font-family: -webkit-standard; font-weight: normal;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><a href=\"https://en.wikipedia.org/wiki/First-class_function\" target=\"_blank\" rel=\"noopener\">一級函數( First-Class Function</a>&nbsp;)：<span style=\"font-weight: normal;\">指的是語言支援把 Function 當成第一類公民，可以支援一般變數的操作，像是把 Function 當成變數傳給另外一個 Function。</span></span></div><div style=\"font-family: -webkit-standard; font-weight: normal;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><a href=\"https://msdn.microsoft.com/zh-tw/library/bb397687.aspx\" target=\"_blank\" rel=\"noopener\">Lambda Function</a><span style=\"font-weight: normal;\">：Lambda 運算式是匿名函式，可用來建立委派或運算式樹狀架構類型。</span></span></div><div style=\"font-family: -webkit-standard; font-weight: normal;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><a href=\"https://en.wikipedia.org/wiki/Formal_system\" target=\"_blank\" rel=\"noopener\">形式系統 ( Formal System )</a><span style=\"font-weight: normal;\">：形式系統可以的廣泛地被定義為任何基於數學模型的、良好的抽象思考的系統 ( system of abstract thought )。</span></span></div><div style=\"font-family: -webkit-standard; font-weight: normal;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><a href=\"https://en.wikipedia.org/wiki/Currying\" target=\"_blank\" rel=\"noopener\">Currying</a><span style=\"font-weight: normal;\">：這個技巧能把接受多參數的函數轉換為多個連續呼叫的單一參數函數。</span></span></div><div style=\"font-family: -webkit-standard; font-weight: normal;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><a href=\"http://stackoverflow.com/questions/111102/how-do-javascript-closures-work\" target=\"_blank\" rel=\"noopener\">閉鎖 ( Closure )</a><span style=\"font-weight: normal;\">&nbsp;/&nbsp;</span><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures\" target=\"_blank\" rel=\"noopener\">MDN</a><span style=\"font-weight: normal;\">：Closure 是可以使用獨立 / 自由變數的函數。換句話說，Closure 記得它</span>實體化<span style=\"font-weight: normal;\">時的環境變數。</span></span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span style=\"font-weight: normal;\"><br></span></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span style=\"font-weight: normal;\">PS：專有名詞那邊引用了很多別人的解釋，可以點前面的連結進去看完整版。</span></span></div></li>\n</ol>\n<h3 id=\"—————————————————————————————–\"><a href=\"#—————————————————————————————–\" class=\"headerlink\" title=\"—————————————————————————————–\"></a><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">—————————————————————————————–</span></h3><div><a href=\"https://drboolean.gitbooks.io/mostly-adequate-guide/\" target=\"_blank\" rel=\"noopener\">Professor Frisby’s Mostly Adequate Guide to Functional Programming</a><span style=\"color: #333333; font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp;( 下文是這本書的筆記 )</span></div>\n\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"**\"></a><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">**</span></h3><p>**</p>\n<h3 id=\"函數式編程簡介篇\"><a href=\"#函數式編程簡介篇\" class=\"headerlink\" title=\"函數式編程簡介篇\"></a><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><strong>函數式編程簡介篇</strong></span></h3><p><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">函數式編程的的哲學就是假設副作用 ( side effect ) 是不正確行為的主要原因。所以努力想要控制和管理副作用，經常的解法就是把純函數、單子和不純的函數 ( impure function ) 分開來管理。另外鼓勵大家多寫純函數。我們對待資料要像玩戲法般，一直傳來傳去、禁止使用狀態 ( state ) 和副作用。剛剛這段文字有提到很多專有名詞，但這樣子怎麼寫程式？這邊我開始介紹一個新工具叫 柯里化 ( currying )。</span></p>\n<p><strong><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Currying：</span></strong><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Currying 把任何的函數轉換成 一連串只做單一事情的函數，各個擊破。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Curring的概念是簡單的。它讓你呼叫<span style=\"color: red;\">函數 A</span> 時可以傳比預期還少的參數。然後這個<span style=\"color: red;\">函數 A</span> 會回傳</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span style=\"color: blue;\">函數 B</span></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">。<span style=\"color: blue;\">函數 B</span>&nbsp;需要的參數是先前沒傳進<span style=\"color: red;\">函數 A</span> 的參數。所以整個流程是：</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">函數A (x, y) 可以等價於下面這段</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">————————————-</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">函數B = 函數A (x)</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">函數B (y)</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">先前傳進去</span><span style=\"color: red; font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">函數 A</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp;的參數會利用閉鎖 ( Closure ) 的方式變成</span><span style=\"color: blue; font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">函數 B</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp;的環境變數。</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">看完上面這段解說，一定會想這什麼鬼東西？來看看&nbsp;<a href=\"https://drboolean.gitbooks.io/mostly-adequate-guide/content/ch4.html\" target=\"_blank\" rel=\"noopener\">這邊的例子</a>&nbsp;會容易理解的多。</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">利用這個技巧，就可以選擇一次傳所有參數或是把參數分幾次傳給數個函數。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><a href=\"https://lodash.com/docs#curry\" target=\"_blank\" rel=\"noopener\">lodash提供了把函數 curry化的工具</a>，用法：</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">var divide = &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span style=\"color: #38761d;\">function (x,y) { return x / y } </span>可以被改寫成</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">—————————————————–</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">var divide = curry(&nbsp;</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span style=\"color: #38761d;\">function (x,y) { return x / y }</span> );</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">之後就可以被這樣呼叫</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">divide <span style=\"color: red;\">( x )</span> <span style=\"color: blue;\">( y )</span>;</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">或是</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">var xDividedBy = divide ( x );</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">tenDividedBy ( y );</span></p>\n<p><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">PS：這工具的名字是為了紀念一個美國數學家 —&nbsp;<a href=\"https://en.wikipedia.org/wiki/Haskell_Curry\" target=\"_blank\" rel=\"noopener\">Haskell Curry</a>，跟咖哩沒有關係。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">接下來我們看另外一個工具 代碼組成( compose )。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><strong>組合 / 組成 / 合成 ( compose )</strong>：</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Composition 把許多函數用管子 ( pipe ) 連接起來，變成一個新個函數。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></p>\n<p><table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"><tbody><tr><td style=\"text-align: center;\"><a href=\"http://2.bp.blogspot.com/-eFzwVuCTVaU/VkBsgOAPFuI/AAAAAAAA36k/2G6L_UmPZjI/s1600/Screen%2BShot%2B2015-11-09%2Bat%2B5.50.05%2BPM.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"http://2.bp.blogspot.com/-eFzwVuCTVaU/VkBsgOAPFuI/AAAAAAAA36k/2G6L_UmPZjI/s320/Screen%2BShot%2B2015-11-09%2Bat%2B5.50.05%2BPM.jpg\" alt=\"\"></a></td></tr><tr><td class=\"tr-caption\" style=\"text-align: center;\"><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">f, g 都是函數，x 在它們之間被傳遞。<br>注意g函數的參數是 x、f函數的參數是 g函數的回傳值。<br>較常用在 f &amp; g 都吃同一類參數的時候 (ex: 字串)。</span></td></tr></tbody></table><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">例子：變大寫和去空白函數 = compose (變大寫函數, 去空白函數)</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">因為有了一級函數、Currying、組合，Pointfree 風格變得流行了起來，指的是函數呼叫時不用提到它要處理的資料。例如：</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span style=\"color: #674ea7;\">var</span> snakeCase = <span style=\"color: #674ea7;\">function</span> ( <span style=\"background-color: #ffd966;\"><strong>word</strong></span> ) {</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp; &nbsp;<span style=\"color: #674ea7;\">&nbsp; &nbsp;return</span><span style=\"color: magenta;\"> </span><span style=\"background-color: #ffd966;\"><strong>word</strong></span>.toUpperCase( ).replace(&nbsp;<span style=\"color: #e06666;\">/\\s+/ig</span>, <span style=\"color: #6aa84f;\">‘<em>‘&nbsp;</em></span>);</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">}&nbsp;</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">可被改寫成</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">———————————————–</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span style=\"color: #674ea7;\">var</span> snakeCase = compose (&nbsp;</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">replace(&nbsp;</span><span style=\"color: #e06666; font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">/\\s+/ig</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">,&nbsp;</span><span style=\"color: #6aa84f; font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">‘‘&nbsp;</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">), toLowerCase );</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">用組合形成新函數就不用提到資料 — 也就是之前寫法中的 <strong>word</strong></span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><strong>\n</strong></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Pointfree的編程風格可以讓我們移除不需要的名字 (names)，讓我們保持簡潔 ( concise ) 和一般化 / 泛型 ( generic )。但要小心 Pointfree 是個雙面刃，有時會把原來的目的變得模糊。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">( 以上是書本前五章的內容，其他待續… 後面有點硬，不知道什麼時候會看。)</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span style=\"background-color: #f6f6f6; color: #333333;\"><br></span></span><span style=\"color: #333333; font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span style=\"background-color: #f6f6f6;\">—</span></span><br><span style=\"color: #333333; font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span style=\"background-color: #f6f6f6;\">這篇文介紹得很好&nbsp;<a href=\"http://coolshell.cn/articles/10822.html\" target=\"_blank\" rel=\"noopener\">函數式編程</a></span></span></p>\n"},{"title":"參加 FB Hackathon 2015 感想","date":"2015-11-15T15:24:00.000Z","_content":"\n#### FB Hackathon 比賽篇\n有點缺乏結束的感覺，這時候放下再前進的方法就是寫篇文，透過寫作把事情組織、整理好。\n\n這是我第一次參加 Hackathon，這次是 FB 和 Girls in Tech 合辦的，主題是女性和公益。先不論結果、這次真的很新鮮 ( 趕期末作業的 fu )，之前上網研究過的 Hackathon 攻略，但今天完全丟在一邊沒在管... 哈哈\n\n大家在交誼區自我介紹、聊自己的想做的主題，結果弄了很久大家有一點點熟，到一張桌子旁邊坐了下來就變成一隊!!! 然後我們這隊大部份都是做後端、資料處理的，結果就是 nodejs + java + python 各種語言混合大亂鬥，真的很酷~\n\n經過聊天，發現大家都是第一次參加、發現大家都是熱心公益的人。前面三個小時，花了長時間 Brain Stroming，一般會得獎的參賽者都是決定好要做什麼才來的，還有偷做的。在 Hackathon 跑快速 BASIC 設計流程真的很神奇，定義問題 (Briefing)、分析已有解法 (Analysis)、思考改進方法(Synthesis)、實作 (Implementaion)、傳達 (Communication)。大概流程都有跑，不過 S &amp; I 的部分有點亂。其他合作流程都有讓人 Hack 團隊的感覺。\n\n一直看設計研究的初學者，終於有個玩的機會 XD~ 很多不熟的地方，設定 Target Audience、設計 Magic Moment ( 這個沒做... )、列出 User Story ( 這個也沒做... T.T )、設計互動 ( 光流程不算... )、紙牌分數投票法。設計師注重這問題是不是真正的問題，工程師注重的是這問題要怎麼解，Hacker 的精神在這兩個中間。但年紀大了真的開始變得比較嘴砲了... T.T\n\n我這天在工程師的部分一直撞牆，真的是... 超弱。Node &amp; Express 才摸一週多、Facebook APP 第一次開發 ( 這個真的超多地雷限制 )、mongodb 第一次用、環境設定在 Macbook 卡一卡、在 linode linux server 卡一卡。就像馬拉松配速沒配好一樣，在經過三小時討論、五小時 Coding，我在最後的四小時完全失去戰鬥能力。壓垮我的稻草是從 Facebook 抓圖隨機一直回傳 403。\n\n真的很感謝強者隊友們，PeiPei / Gordon / Joanne / Leo / Erica，就 12 小時 sprint 的角度來看，第一次還蠻成功的，如果再 iterate 幾次、這個團隊應該會生出好產品的。今天過程真的很好玩~ 有了好同伴，就從在 Panic Zone 變成在 Learning Zone 了。\n\n會再參加嗎？喔 真的很累，想到下個月還有一場就很崩潰。\n\n#### **Hackathon 前問題研究篇**\n因為主題是女性和公益，賽前大概花了半天看了很多議題，挑出兩個覺得適合的問題。\n\n1\\. 增加同理心 (empathy) &amp; 跨出舒適圈 (Comfort Zone) 的主題：\n&nbsp; &nbsp; &gt; I don't like that man. I must get to know him better. - 林肯\n&nbsp; &nbsp; &gt; While nothing is easier then denounce the evil doer, nothing is more difficult than understand him. - 杜斯妥也夫斯基\n&nbsp; &nbsp; &gt; Step outside of your tiny little world. And step inside of the tiny little world of somebody else. - Sam Richards\n&nbsp; &nbsp; &gt; Life begins at the end of your comfort zone.\n&nbsp; &nbsp; &gt;&nbsp;[comfort zone / learning zone / panic zone](http://blog.crew.co/getting-out-of-your-comfort-zone-why-its-hard-and-why-you-should/)\n&nbsp; &nbsp; &gt; Ted影片：[一個關於同理心的激進實驗](https://www.youtube.com/watch?v=kUEGHdQO7WA)\n&nbsp; &nbsp; &gt; 厚書：&nbsp;[好人總是自以為是：政治與宗教如何將我們四分五裂](http://www.amazon.com/The-Righteous-Mind-Politics-Religion/dp/0307455777)\n\n2\\. 在東亞，特別少女生走自然組：不是因為能力不同、而是因為社會期待。 ( 昨天才突然發現我修大學資工系的課時，從來沒跟女生共事過 )\n&nbsp; &nbsp; &gt;&nbsp;[台灣女生不喜歡讀科學，「世界第一」帶來的驚愕與警訊](https://www.youtube.com/watch?v=kUEGHdQO7WA)\n&nbsp; &nbsp; &gt;&nbsp;[高中選組男女大不同？性別與高中選組之研究](http://t195-240.dialup.seed.net.tw/99annuals/flying62_2.html)\n\n好好放下、明天再前進 Javascript 和 函數編程的世界、Full Stack Developer 之路。\n---\n延伸閱讀：[10 tips for hackathon success](http://www.appsembler.com/blog/10-tips-for-hackathon-success/)","source":"_posts/參加-FB-Hackathon-2015-感想.md","raw":"---\ntitle: 參加 FB Hackathon 2015 感想\ntags:\n  - empathy\n  - hackathon\ndate: 2015-11-15 23:24:00\n---\n\n#### FB Hackathon 比賽篇\n有點缺乏結束的感覺，這時候放下再前進的方法就是寫篇文，透過寫作把事情組織、整理好。\n\n這是我第一次參加 Hackathon，這次是 FB 和 Girls in Tech 合辦的，主題是女性和公益。先不論結果、這次真的很新鮮 ( 趕期末作業的 fu )，之前上網研究過的 Hackathon 攻略，但今天完全丟在一邊沒在管... 哈哈\n\n大家在交誼區自我介紹、聊自己的想做的主題，結果弄了很久大家有一點點熟，到一張桌子旁邊坐了下來就變成一隊!!! 然後我們這隊大部份都是做後端、資料處理的，結果就是 nodejs + java + python 各種語言混合大亂鬥，真的很酷~\n\n經過聊天，發現大家都是第一次參加、發現大家都是熱心公益的人。前面三個小時，花了長時間 Brain Stroming，一般會得獎的參賽者都是決定好要做什麼才來的，還有偷做的。在 Hackathon 跑快速 BASIC 設計流程真的很神奇，定義問題 (Briefing)、分析已有解法 (Analysis)、思考改進方法(Synthesis)、實作 (Implementaion)、傳達 (Communication)。大概流程都有跑，不過 S &amp; I 的部分有點亂。其他合作流程都有讓人 Hack 團隊的感覺。\n\n一直看設計研究的初學者，終於有個玩的機會 XD~ 很多不熟的地方，設定 Target Audience、設計 Magic Moment ( 這個沒做... )、列出 User Story ( 這個也沒做... T.T )、設計互動 ( 光流程不算... )、紙牌分數投票法。設計師注重這問題是不是真正的問題，工程師注重的是這問題要怎麼解，Hacker 的精神在這兩個中間。但年紀大了真的開始變得比較嘴砲了... T.T\n\n我這天在工程師的部分一直撞牆，真的是... 超弱。Node &amp; Express 才摸一週多、Facebook APP 第一次開發 ( 這個真的超多地雷限制 )、mongodb 第一次用、環境設定在 Macbook 卡一卡、在 linode linux server 卡一卡。就像馬拉松配速沒配好一樣，在經過三小時討論、五小時 Coding，我在最後的四小時完全失去戰鬥能力。壓垮我的稻草是從 Facebook 抓圖隨機一直回傳 403。\n\n真的很感謝強者隊友們，PeiPei / Gordon / Joanne / Leo / Erica，就 12 小時 sprint 的角度來看，第一次還蠻成功的，如果再 iterate 幾次、這個團隊應該會生出好產品的。今天過程真的很好玩~ 有了好同伴，就從在 Panic Zone 變成在 Learning Zone 了。\n\n會再參加嗎？喔 真的很累，想到下個月還有一場就很崩潰。\n\n#### **Hackathon 前問題研究篇**\n因為主題是女性和公益，賽前大概花了半天看了很多議題，挑出兩個覺得適合的問題。\n\n1\\. 增加同理心 (empathy) &amp; 跨出舒適圈 (Comfort Zone) 的主題：\n&nbsp; &nbsp; &gt; I don't like that man. I must get to know him better. - 林肯\n&nbsp; &nbsp; &gt; While nothing is easier then denounce the evil doer, nothing is more difficult than understand him. - 杜斯妥也夫斯基\n&nbsp; &nbsp; &gt; Step outside of your tiny little world. And step inside of the tiny little world of somebody else. - Sam Richards\n&nbsp; &nbsp; &gt; Life begins at the end of your comfort zone.\n&nbsp; &nbsp; &gt;&nbsp;[comfort zone / learning zone / panic zone](http://blog.crew.co/getting-out-of-your-comfort-zone-why-its-hard-and-why-you-should/)\n&nbsp; &nbsp; &gt; Ted影片：[一個關於同理心的激進實驗](https://www.youtube.com/watch?v=kUEGHdQO7WA)\n&nbsp; &nbsp; &gt; 厚書：&nbsp;[好人總是自以為是：政治與宗教如何將我們四分五裂](http://www.amazon.com/The-Righteous-Mind-Politics-Religion/dp/0307455777)\n\n2\\. 在東亞，特別少女生走自然組：不是因為能力不同、而是因為社會期待。 ( 昨天才突然發現我修大學資工系的課時，從來沒跟女生共事過 )\n&nbsp; &nbsp; &gt;&nbsp;[台灣女生不喜歡讀科學，「世界第一」帶來的驚愕與警訊](https://www.youtube.com/watch?v=kUEGHdQO7WA)\n&nbsp; &nbsp; &gt;&nbsp;[高中選組男女大不同？性別與高中選組之研究](http://t195-240.dialup.seed.net.tw/99annuals/flying62_2.html)\n\n好好放下、明天再前進 Javascript 和 函數編程的世界、Full Stack Developer 之路。\n---\n延伸閱讀：[10 tips for hackathon success](http://www.appsembler.com/blog/10-tips-for-hackathon-success/)","slug":"參加-FB-Hackathon-2015-感想","published":1,"updated":"2017-12-23T06:08:08.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjblkzclb000pxq9km9oxh6c2","content":"<h4 id=\"FB-Hackathon-比賽篇\"><a href=\"#FB-Hackathon-比賽篇\" class=\"headerlink\" title=\"FB Hackathon 比賽篇\"></a>FB Hackathon 比賽篇</h4><p>有點缺乏結束的感覺，這時候放下再前進的方法就是寫篇文，透過寫作把事情組織、整理好。</p>\n<p>這是我第一次參加 Hackathon，這次是 FB 和 Girls in Tech 合辦的，主題是女性和公益。先不論結果、這次真的很新鮮 ( 趕期末作業的 fu )，之前上網研究過的 Hackathon 攻略，但今天完全丟在一邊沒在管… 哈哈</p>\n<p>大家在交誼區自我介紹、聊自己的想做的主題，結果弄了很久大家有一點點熟，到一張桌子旁邊坐了下來就變成一隊!!! 然後我們這隊大部份都是做後端、資料處理的，結果就是 nodejs + java + python 各種語言混合大亂鬥，真的很酷~</p>\n<p>經過聊天，發現大家都是第一次參加、發現大家都是熱心公益的人。前面三個小時，花了長時間 Brain Stroming，一般會得獎的參賽者都是決定好要做什麼才來的，還有偷做的。在 Hackathon 跑快速 BASIC 設計流程真的很神奇，定義問題 (Briefing)、分析已有解法 (Analysis)、思考改進方法(Synthesis)、實作 (Implementaion)、傳達 (Communication)。大概流程都有跑，不過 S &amp; I 的部分有點亂。其他合作流程都有讓人 Hack 團隊的感覺。</p>\n<p>一直看設計研究的初學者，終於有個玩的機會 XD~ 很多不熟的地方，設定 Target Audience、設計 Magic Moment ( 這個沒做… )、列出 User Story ( 這個也沒做… T.T )、設計互動 ( 光流程不算… )、紙牌分數投票法。設計師注重這問題是不是真正的問題，工程師注重的是這問題要怎麼解，Hacker 的精神在這兩個中間。但年紀大了真的開始變得比較嘴砲了… T.T</p>\n<p>我這天在工程師的部分一直撞牆，真的是… 超弱。Node &amp; Express 才摸一週多、Facebook APP 第一次開發 ( 這個真的超多地雷限制 )、mongodb 第一次用、環境設定在 Macbook 卡一卡、在 linode linux server 卡一卡。就像馬拉松配速沒配好一樣，在經過三小時討論、五小時 Coding，我在最後的四小時完全失去戰鬥能力。壓垮我的稻草是從 Facebook 抓圖隨機一直回傳 403。</p>\n<p>真的很感謝強者隊友們，PeiPei / Gordon / Joanne / Leo / Erica，就 12 小時 sprint 的角度來看，第一次還蠻成功的，如果再 iterate 幾次、這個團隊應該會生出好產品的。今天過程真的很好玩~ 有了好同伴，就從在 Panic Zone 變成在 Learning Zone 了。</p>\n<p>會再參加嗎？喔 真的很累，想到下個月還有一場就很崩潰。</p>\n<h4 id=\"Hackathon-前問題研究篇\"><a href=\"#Hackathon-前問題研究篇\" class=\"headerlink\" title=\"Hackathon 前問題研究篇\"></a><strong>Hackathon 前問題研究篇</strong></h4><p>因為主題是女性和公益，賽前大概花了半天看了很多議題，挑出兩個覺得適合的問題。</p>\n<p>1. 增加同理心 (empathy) &amp; 跨出舒適圈 (Comfort Zone) 的主題：<br>&nbsp; &nbsp; &gt; I don’t like that man. I must get to know him better. - 林肯<br>&nbsp; &nbsp; &gt; While nothing is easier then denounce the evil doer, nothing is more difficult than understand him. - 杜斯妥也夫斯基<br>&nbsp; &nbsp; &gt; Step outside of your tiny little world. And step inside of the tiny little world of somebody else. - Sam Richards<br>&nbsp; &nbsp; &gt; Life begins at the end of your comfort zone.<br>&nbsp; &nbsp; &gt;&nbsp;<a href=\"http://blog.crew.co/getting-out-of-your-comfort-zone-why-its-hard-and-why-you-should/\" target=\"_blank\" rel=\"noopener\">comfort zone / learning zone / panic zone</a><br>&nbsp; &nbsp; &gt; Ted影片：<a href=\"https://www.youtube.com/watch?v=kUEGHdQO7WA\" target=\"_blank\" rel=\"noopener\">一個關於同理心的激進實驗</a><br>&nbsp; &nbsp; &gt; 厚書：&nbsp;<a href=\"http://www.amazon.com/The-Righteous-Mind-Politics-Religion/dp/0307455777\" target=\"_blank\" rel=\"noopener\">好人總是自以為是：政治與宗教如何將我們四分五裂</a></p>\n<p>2. 在東亞，特別少女生走自然組：不是因為能力不同、而是因為社會期待。 ( 昨天才突然發現我修大學資工系的課時，從來沒跟女生共事過 )<br>&nbsp; &nbsp; &gt;&nbsp;<a href=\"https://www.youtube.com/watch?v=kUEGHdQO7WA\" target=\"_blank\" rel=\"noopener\">台灣女生不喜歡讀科學，「世界第一」帶來的驚愕與警訊</a><br>&nbsp; &nbsp; &gt;&nbsp;<a href=\"http://t195-240.dialup.seed.net.tw/99annuals/flying62_2.html\" target=\"_blank\" rel=\"noopener\">高中選組男女大不同？性別與高中選組之研究</a></p>\n<h2 id=\"好好放下、明天再前進-Javascript-和-函數編程的世界、Full-Stack-Developer-之路。\"><a href=\"#好好放下、明天再前進-Javascript-和-函數編程的世界、Full-Stack-Developer-之路。\" class=\"headerlink\" title=\"好好放下、明天再前進 Javascript 和 函數編程的世界、Full Stack Developer 之路。\"></a>好好放下、明天再前進 Javascript 和 函數編程的世界、Full Stack Developer 之路。</h2><p>延伸閱讀：<a href=\"http://www.appsembler.com/blog/10-tips-for-hackathon-success/\" target=\"_blank\" rel=\"noopener\">10 tips for hackathon success</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"FB-Hackathon-比賽篇\"><a href=\"#FB-Hackathon-比賽篇\" class=\"headerlink\" title=\"FB Hackathon 比賽篇\"></a>FB Hackathon 比賽篇</h4><p>有點缺乏結束的感覺，這時候放下再前進的方法就是寫篇文，透過寫作把事情組織、整理好。</p>\n<p>這是我第一次參加 Hackathon，這次是 FB 和 Girls in Tech 合辦的，主題是女性和公益。先不論結果、這次真的很新鮮 ( 趕期末作業的 fu )，之前上網研究過的 Hackathon 攻略，但今天完全丟在一邊沒在管… 哈哈</p>\n<p>大家在交誼區自我介紹、聊自己的想做的主題，結果弄了很久大家有一點點熟，到一張桌子旁邊坐了下來就變成一隊!!! 然後我們這隊大部份都是做後端、資料處理的，結果就是 nodejs + java + python 各種語言混合大亂鬥，真的很酷~</p>\n<p>經過聊天，發現大家都是第一次參加、發現大家都是熱心公益的人。前面三個小時，花了長時間 Brain Stroming，一般會得獎的參賽者都是決定好要做什麼才來的，還有偷做的。在 Hackathon 跑快速 BASIC 設計流程真的很神奇，定義問題 (Briefing)、分析已有解法 (Analysis)、思考改進方法(Synthesis)、實作 (Implementaion)、傳達 (Communication)。大概流程都有跑，不過 S &amp; I 的部分有點亂。其他合作流程都有讓人 Hack 團隊的感覺。</p>\n<p>一直看設計研究的初學者，終於有個玩的機會 XD~ 很多不熟的地方，設定 Target Audience、設計 Magic Moment ( 這個沒做… )、列出 User Story ( 這個也沒做… T.T )、設計互動 ( 光流程不算… )、紙牌分數投票法。設計師注重這問題是不是真正的問題，工程師注重的是這問題要怎麼解，Hacker 的精神在這兩個中間。但年紀大了真的開始變得比較嘴砲了… T.T</p>\n<p>我這天在工程師的部分一直撞牆，真的是… 超弱。Node &amp; Express 才摸一週多、Facebook APP 第一次開發 ( 這個真的超多地雷限制 )、mongodb 第一次用、環境設定在 Macbook 卡一卡、在 linode linux server 卡一卡。就像馬拉松配速沒配好一樣，在經過三小時討論、五小時 Coding，我在最後的四小時完全失去戰鬥能力。壓垮我的稻草是從 Facebook 抓圖隨機一直回傳 403。</p>\n<p>真的很感謝強者隊友們，PeiPei / Gordon / Joanne / Leo / Erica，就 12 小時 sprint 的角度來看，第一次還蠻成功的，如果再 iterate 幾次、這個團隊應該會生出好產品的。今天過程真的很好玩~ 有了好同伴，就從在 Panic Zone 變成在 Learning Zone 了。</p>\n<p>會再參加嗎？喔 真的很累，想到下個月還有一場就很崩潰。</p>\n<h4 id=\"Hackathon-前問題研究篇\"><a href=\"#Hackathon-前問題研究篇\" class=\"headerlink\" title=\"Hackathon 前問題研究篇\"></a><strong>Hackathon 前問題研究篇</strong></h4><p>因為主題是女性和公益，賽前大概花了半天看了很多議題，挑出兩個覺得適合的問題。</p>\n<p>1. 增加同理心 (empathy) &amp; 跨出舒適圈 (Comfort Zone) 的主題：<br>&nbsp; &nbsp; &gt; I don’t like that man. I must get to know him better. - 林肯<br>&nbsp; &nbsp; &gt; While nothing is easier then denounce the evil doer, nothing is more difficult than understand him. - 杜斯妥也夫斯基<br>&nbsp; &nbsp; &gt; Step outside of your tiny little world. And step inside of the tiny little world of somebody else. - Sam Richards<br>&nbsp; &nbsp; &gt; Life begins at the end of your comfort zone.<br>&nbsp; &nbsp; &gt;&nbsp;<a href=\"http://blog.crew.co/getting-out-of-your-comfort-zone-why-its-hard-and-why-you-should/\" target=\"_blank\" rel=\"noopener\">comfort zone / learning zone / panic zone</a><br>&nbsp; &nbsp; &gt; Ted影片：<a href=\"https://www.youtube.com/watch?v=kUEGHdQO7WA\" target=\"_blank\" rel=\"noopener\">一個關於同理心的激進實驗</a><br>&nbsp; &nbsp; &gt; 厚書：&nbsp;<a href=\"http://www.amazon.com/The-Righteous-Mind-Politics-Religion/dp/0307455777\" target=\"_blank\" rel=\"noopener\">好人總是自以為是：政治與宗教如何將我們四分五裂</a></p>\n<p>2. 在東亞，特別少女生走自然組：不是因為能力不同、而是因為社會期待。 ( 昨天才突然發現我修大學資工系的課時，從來沒跟女生共事過 )<br>&nbsp; &nbsp; &gt;&nbsp;<a href=\"https://www.youtube.com/watch?v=kUEGHdQO7WA\" target=\"_blank\" rel=\"noopener\">台灣女生不喜歡讀科學，「世界第一」帶來的驚愕與警訊</a><br>&nbsp; &nbsp; &gt;&nbsp;<a href=\"http://t195-240.dialup.seed.net.tw/99annuals/flying62_2.html\" target=\"_blank\" rel=\"noopener\">高中選組男女大不同？性別與高中選組之研究</a></p>\n<h2 id=\"好好放下、明天再前進-Javascript-和-函數編程的世界、Full-Stack-Developer-之路。\"><a href=\"#好好放下、明天再前進-Javascript-和-函數編程的世界、Full-Stack-Developer-之路。\" class=\"headerlink\" title=\"好好放下、明天再前進 Javascript 和 函數編程的世界、Full Stack Developer 之路。\"></a>好好放下、明天再前進 Javascript 和 函數編程的世界、Full Stack Developer 之路。</h2><p>延伸閱讀：<a href=\"http://www.appsembler.com/blog/10-tips-for-hackathon-success/\" target=\"_blank\" rel=\"noopener\">10 tips for hackathon success</a></p>\n"},{"title":"台大不一樣思考社：設計思考工作坊 Day 1","date":"2015-12-19T18:08:00.000Z","_content":"\n和藝術不同，設計是一門客觀的學問。重視觀察、基於觀察做出像偵探一樣的推論、做出像科學家一樣的假設，用同理心而不是同情心去理解這一個人的行為和需求、從使用者的角度去看這個世界。\n\n**<u>問題是和需求是不同的：</u>**\n\n從8層樓高優雅的降落到地表不受傷是一個問題。但大多數人這輩子都不會有這樣的需求。\n\n<u>\n</u><u>需求要用動詞來描述而不是名詞：</u>\n需求：「吃到好吃的早餐」 =&gt; 人自動會把行動連接成\n\n1.  怎麼 「吃到好吃的早餐?」\n2.  為什麼要 「吃到好吃的早餐，原因是什麼？」需求「好吃的早餐」 =&gt; 推理就的莫名其妙的卡住，加上 5W1H 都很不順！\n\n今天請大家解的題目是「如何提升吃早餐的經驗」。\n\n流程：\n&nbsp; &nbsp;1\\. 先用便利貼討論要訪談使用者的問題、把相近的問題Group後，針對每一類問題畫正字投票.\n\n&nbsp; &nbsp;2\\. 街訪：會有一個主訪、副訪和紀錄。大概十分鐘，主訪負責掌握進度、副訪負責見縫插針。\n\n&nbsp; &nbsp;3\\. 把數個人紀錄的資訊口述下載，每個人寫下事實 (Fact) 到便利貼上 &amp; 分類。\n\n==== 以下開始小組討論、瘋狂的 blocking I/O 超花時間，為什麼不繼續平行計算啊 ====\n&nbsp; &nbsp;4\\. 試著從事實 (Fact) 中，推出這個人的需求 (need)\n&nbsp; &nbsp;5\\. 從這個人的需求 (need)，找出洞察 &nbsp;(insight)\n\n[來到了 long long complain section]\n一人一票決定街訪問題，真是不太好，就是一種讓人膚淺思考的快速解決方式吧、然後想問題的時候，好像沒有一個比較好的想法，怎麼問會得到提升早餐經驗的資訊，不過強調 empathize 那這次就不預設立場試試吧\n\n從列需求就一直卡，用動詞描述真的很重要 ( 回家才看文章才懂 )，然後訪的幾個學生都不是很愛吃早餐，他們的簡單需求早就在這個台灣早餐文化發達、便利商店充斥的環境滿足了。還說「提升早餐體驗」是簡單題目，結果需求列完，洞察完全列不出來。需求出來就解啊，為何要落在為做「設計思考」強說洞察的陷阱裡，Inception 一定要下到第幾層嗎？不過別組有些很順利的，希望明天報告的時候能搞清楚，我們和別人不同在哪？做錯了哪一步？\n\n另外一個是「提升早餐體驗」的題目定下來了，我們不知道客戶是誰、沒有辦法詢問客戶，沒法想問題背後的問題 / 找到真正要解的問題。然後一開始也沒決定是要生產品還是服務，也沒有定好 TA。最後我們這組 TA 好像是學生，但如果要解這個問題，自身的經驗、非訪談的觀察就不能使用。\n\n然後很討厭，台上報告有事沒事後面工作人員就很 high 的附和之類的，做設計一定要這樣搞嗎？不過開始前玩小遊戲提神真的還不錯。\n\n現在的想法就只有，使用者都想跟朋友一起吃早餐，那就請宿舍早餐店提出兩人同行，第二人早餐六折的優惠，這樣所有人的體驗都會好，早餐店也會比較賺錢。\n\n---\n現在只能安慰自己，花了 1,600 元兩天就發覺 Design Thinking 沒啥用，也是不錯的收穫，反正還有一堆其他的設計流程。 UX 這條路 QQ 回家重看了設計的心理學的 Design Thinking 一章，特別強調不要用訪談耶...Orz\n\nDon't try to be original, just try to be good.\nI don't want to be interesting, I want to be good.\n( 不一樣思考又怎樣啊... 解問題為什麼不先 google / survey? )\n\n明天就是嘴砲的 brain storming~ to be continued.\n\n延伸閱讀：\n[像福爾摩沙一樣解決社會問題 (同情心、同理心、觀察力)](http://www.seinsights.asia/story/1434/795/2018)\n[Problems Are Not Equal to Needs](http://kenshinfujiwara.com/2011/11/problems-are-not-equal-to-needs/)\n[Don't try to be original, try to be good.](http://www.logodesignlove.com/paul-rand-video)","source":"_posts/台大不一樣思考社：設計思考工作坊-Day-1.md","raw":"---\ntitle: 台大不一樣思考社：設計思考工作坊 Day 1\ntags:\n  - design\n  - ux\ndate: 2015-12-20 02:08:00\n---\n\n和藝術不同，設計是一門客觀的學問。重視觀察、基於觀察做出像偵探一樣的推論、做出像科學家一樣的假設，用同理心而不是同情心去理解這一個人的行為和需求、從使用者的角度去看這個世界。\n\n**<u>問題是和需求是不同的：</u>**\n\n從8層樓高優雅的降落到地表不受傷是一個問題。但大多數人這輩子都不會有這樣的需求。\n\n<u>\n</u><u>需求要用動詞來描述而不是名詞：</u>\n需求：「吃到好吃的早餐」 =&gt; 人自動會把行動連接成\n\n1.  怎麼 「吃到好吃的早餐?」\n2.  為什麼要 「吃到好吃的早餐，原因是什麼？」需求「好吃的早餐」 =&gt; 推理就的莫名其妙的卡住，加上 5W1H 都很不順！\n\n今天請大家解的題目是「如何提升吃早餐的經驗」。\n\n流程：\n&nbsp; &nbsp;1\\. 先用便利貼討論要訪談使用者的問題、把相近的問題Group後，針對每一類問題畫正字投票.\n\n&nbsp; &nbsp;2\\. 街訪：會有一個主訪、副訪和紀錄。大概十分鐘，主訪負責掌握進度、副訪負責見縫插針。\n\n&nbsp; &nbsp;3\\. 把數個人紀錄的資訊口述下載，每個人寫下事實 (Fact) 到便利貼上 &amp; 分類。\n\n==== 以下開始小組討論、瘋狂的 blocking I/O 超花時間，為什麼不繼續平行計算啊 ====\n&nbsp; &nbsp;4\\. 試著從事實 (Fact) 中，推出這個人的需求 (need)\n&nbsp; &nbsp;5\\. 從這個人的需求 (need)，找出洞察 &nbsp;(insight)\n\n[來到了 long long complain section]\n一人一票決定街訪問題，真是不太好，就是一種讓人膚淺思考的快速解決方式吧、然後想問題的時候，好像沒有一個比較好的想法，怎麼問會得到提升早餐經驗的資訊，不過強調 empathize 那這次就不預設立場試試吧\n\n從列需求就一直卡，用動詞描述真的很重要 ( 回家才看文章才懂 )，然後訪的幾個學生都不是很愛吃早餐，他們的簡單需求早就在這個台灣早餐文化發達、便利商店充斥的環境滿足了。還說「提升早餐體驗」是簡單題目，結果需求列完，洞察完全列不出來。需求出來就解啊，為何要落在為做「設計思考」強說洞察的陷阱裡，Inception 一定要下到第幾層嗎？不過別組有些很順利的，希望明天報告的時候能搞清楚，我們和別人不同在哪？做錯了哪一步？\n\n另外一個是「提升早餐體驗」的題目定下來了，我們不知道客戶是誰、沒有辦法詢問客戶，沒法想問題背後的問題 / 找到真正要解的問題。然後一開始也沒決定是要生產品還是服務，也沒有定好 TA。最後我們這組 TA 好像是學生，但如果要解這個問題，自身的經驗、非訪談的觀察就不能使用。\n\n然後很討厭，台上報告有事沒事後面工作人員就很 high 的附和之類的，做設計一定要這樣搞嗎？不過開始前玩小遊戲提神真的還不錯。\n\n現在的想法就只有，使用者都想跟朋友一起吃早餐，那就請宿舍早餐店提出兩人同行，第二人早餐六折的優惠，這樣所有人的體驗都會好，早餐店也會比較賺錢。\n\n---\n現在只能安慰自己，花了 1,600 元兩天就發覺 Design Thinking 沒啥用，也是不錯的收穫，反正還有一堆其他的設計流程。 UX 這條路 QQ 回家重看了設計的心理學的 Design Thinking 一章，特別強調不要用訪談耶...Orz\n\nDon't try to be original, just try to be good.\nI don't want to be interesting, I want to be good.\n( 不一樣思考又怎樣啊... 解問題為什麼不先 google / survey? )\n\n明天就是嘴砲的 brain storming~ to be continued.\n\n延伸閱讀：\n[像福爾摩沙一樣解決社會問題 (同情心、同理心、觀察力)](http://www.seinsights.asia/story/1434/795/2018)\n[Problems Are Not Equal to Needs](http://kenshinfujiwara.com/2011/11/problems-are-not-equal-to-needs/)\n[Don't try to be original, try to be good.](http://www.logodesignlove.com/paul-rand-video)","slug":"台大不一樣思考社：設計思考工作坊-Day-1","published":1,"updated":"2017-12-23T06:08:08.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjblkzcle000rxq9kdsi39pat","content":"<p>和藝術不同，設計是一門客觀的學問。重視觀察、基於觀察做出像偵探一樣的推論、做出像科學家一樣的假設，用同理心而不是同情心去理解這一個人的行為和需求、從使用者的角度去看這個世界。</p>\n<p><strong><u>問題是和需求是不同的：</u></strong></p>\n<p>從8層樓高優雅的降落到地表不受傷是一個問題。但大多數人這輩子都不會有這樣的需求。</p>\n<p><u><br></u><u>需求要用動詞來描述而不是名詞：</u><br>需求：「吃到好吃的早餐」 =&gt; 人自動會把行動連接成</p>\n<ol>\n<li>怎麼 「吃到好吃的早餐?」</li>\n<li>為什麼要 「吃到好吃的早餐，原因是什麼？」需求「好吃的早餐」 =&gt; 推理就的莫名其妙的卡住，加上 5W1H 都很不順！</li>\n</ol>\n<p>今天請大家解的題目是「如何提升吃早餐的經驗」。</p>\n<p>流程：<br>&nbsp; &nbsp;1. 先用便利貼討論要訪談使用者的問題、把相近的問題Group後，針對每一類問題畫正字投票.</p>\n<p>&nbsp; &nbsp;2. 街訪：會有一個主訪、副訪和紀錄。大概十分鐘，主訪負責掌握進度、副訪負責見縫插針。</p>\n<p>&nbsp; &nbsp;3. 把數個人紀錄的資訊口述下載，每個人寫下事實 (Fact) 到便利貼上 &amp; 分類。</p>\n<p>==== 以下開始小組討論、瘋狂的 blocking I/O 超花時間，為什麼不繼續平行計算啊 ====<br>&nbsp; &nbsp;4. 試著從事實 (Fact) 中，推出這個人的需求 (need)<br>&nbsp; &nbsp;5. 從這個人的需求 (need)，找出洞察 &nbsp;(insight)</p>\n<p>[來到了 long long complain section]<br>一人一票決定街訪問題，真是不太好，就是一種讓人膚淺思考的快速解決方式吧、然後想問題的時候，好像沒有一個比較好的想法，怎麼問會得到提升早餐經驗的資訊，不過強調 empathize 那這次就不預設立場試試吧</p>\n<p>從列需求就一直卡，用動詞描述真的很重要 ( 回家才看文章才懂 )，然後訪的幾個學生都不是很愛吃早餐，他們的簡單需求早就在這個台灣早餐文化發達、便利商店充斥的環境滿足了。還說「提升早餐體驗」是簡單題目，結果需求列完，洞察完全列不出來。需求出來就解啊，為何要落在為做「設計思考」強說洞察的陷阱裡，Inception 一定要下到第幾層嗎？不過別組有些很順利的，希望明天報告的時候能搞清楚，我們和別人不同在哪？做錯了哪一步？</p>\n<p>另外一個是「提升早餐體驗」的題目定下來了，我們不知道客戶是誰、沒有辦法詢問客戶，沒法想問題背後的問題 / 找到真正要解的問題。然後一開始也沒決定是要生產品還是服務，也沒有定好 TA。最後我們這組 TA 好像是學生，但如果要解這個問題，自身的經驗、非訪談的觀察就不能使用。</p>\n<p>然後很討厭，台上報告有事沒事後面工作人員就很 high 的附和之類的，做設計一定要這樣搞嗎？不過開始前玩小遊戲提神真的還不錯。</p>\n<p>現在的想法就只有，使用者都想跟朋友一起吃早餐，那就請宿舍早餐店提出兩人同行，第二人早餐六折的優惠，這樣所有人的體驗都會好，早餐店也會比較賺錢。</p>\n<hr>\n<p>現在只能安慰自己，花了 1,600 元兩天就發覺 Design Thinking 沒啥用，也是不錯的收穫，反正還有一堆其他的設計流程。 UX 這條路 QQ 回家重看了設計的心理學的 Design Thinking 一章，特別強調不要用訪談耶…Orz</p>\n<p>Don’t try to be original, just try to be good.<br>I don’t want to be interesting, I want to be good.<br>( 不一樣思考又怎樣啊… 解問題為什麼不先 google / survey? )</p>\n<p>明天就是嘴砲的 brain storming~ to be continued.</p>\n<p>延伸閱讀：<br><a href=\"http://www.seinsights.asia/story/1434/795/2018\" target=\"_blank\" rel=\"noopener\">像福爾摩沙一樣解決社會問題 (同情心、同理心、觀察力)</a><br><a href=\"http://kenshinfujiwara.com/2011/11/problems-are-not-equal-to-needs/\" target=\"_blank\" rel=\"noopener\">Problems Are Not Equal to Needs</a><br><a href=\"http://www.logodesignlove.com/paul-rand-video\" target=\"_blank\" rel=\"noopener\">Don’t try to be original, try to be good.</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>和藝術不同，設計是一門客觀的學問。重視觀察、基於觀察做出像偵探一樣的推論、做出像科學家一樣的假設，用同理心而不是同情心去理解這一個人的行為和需求、從使用者的角度去看這個世界。</p>\n<p><strong><u>問題是和需求是不同的：</u></strong></p>\n<p>從8層樓高優雅的降落到地表不受傷是一個問題。但大多數人這輩子都不會有這樣的需求。</p>\n<p><u><br></u><u>需求要用動詞來描述而不是名詞：</u><br>需求：「吃到好吃的早餐」 =&gt; 人自動會把行動連接成</p>\n<ol>\n<li>怎麼 「吃到好吃的早餐?」</li>\n<li>為什麼要 「吃到好吃的早餐，原因是什麼？」需求「好吃的早餐」 =&gt; 推理就的莫名其妙的卡住，加上 5W1H 都很不順！</li>\n</ol>\n<p>今天請大家解的題目是「如何提升吃早餐的經驗」。</p>\n<p>流程：<br>&nbsp; &nbsp;1. 先用便利貼討論要訪談使用者的問題、把相近的問題Group後，針對每一類問題畫正字投票.</p>\n<p>&nbsp; &nbsp;2. 街訪：會有一個主訪、副訪和紀錄。大概十分鐘，主訪負責掌握進度、副訪負責見縫插針。</p>\n<p>&nbsp; &nbsp;3. 把數個人紀錄的資訊口述下載，每個人寫下事實 (Fact) 到便利貼上 &amp; 分類。</p>\n<p>==== 以下開始小組討論、瘋狂的 blocking I/O 超花時間，為什麼不繼續平行計算啊 ====<br>&nbsp; &nbsp;4. 試著從事實 (Fact) 中，推出這個人的需求 (need)<br>&nbsp; &nbsp;5. 從這個人的需求 (need)，找出洞察 &nbsp;(insight)</p>\n<p>[來到了 long long complain section]<br>一人一票決定街訪問題，真是不太好，就是一種讓人膚淺思考的快速解決方式吧、然後想問題的時候，好像沒有一個比較好的想法，怎麼問會得到提升早餐經驗的資訊，不過強調 empathize 那這次就不預設立場試試吧</p>\n<p>從列需求就一直卡，用動詞描述真的很重要 ( 回家才看文章才懂 )，然後訪的幾個學生都不是很愛吃早餐，他們的簡單需求早就在這個台灣早餐文化發達、便利商店充斥的環境滿足了。還說「提升早餐體驗」是簡單題目，結果需求列完，洞察完全列不出來。需求出來就解啊，為何要落在為做「設計思考」強說洞察的陷阱裡，Inception 一定要下到第幾層嗎？不過別組有些很順利的，希望明天報告的時候能搞清楚，我們和別人不同在哪？做錯了哪一步？</p>\n<p>另外一個是「提升早餐體驗」的題目定下來了，我們不知道客戶是誰、沒有辦法詢問客戶，沒法想問題背後的問題 / 找到真正要解的問題。然後一開始也沒決定是要生產品還是服務，也沒有定好 TA。最後我們這組 TA 好像是學生，但如果要解這個問題，自身的經驗、非訪談的觀察就不能使用。</p>\n<p>然後很討厭，台上報告有事沒事後面工作人員就很 high 的附和之類的，做設計一定要這樣搞嗎？不過開始前玩小遊戲提神真的還不錯。</p>\n<p>現在的想法就只有，使用者都想跟朋友一起吃早餐，那就請宿舍早餐店提出兩人同行，第二人早餐六折的優惠，這樣所有人的體驗都會好，早餐店也會比較賺錢。</p>\n<hr>\n<p>現在只能安慰自己，花了 1,600 元兩天就發覺 Design Thinking 沒啥用，也是不錯的收穫，反正還有一堆其他的設計流程。 UX 這條路 QQ 回家重看了設計的心理學的 Design Thinking 一章，特別強調不要用訪談耶…Orz</p>\n<p>Don’t try to be original, just try to be good.<br>I don’t want to be interesting, I want to be good.<br>( 不一樣思考又怎樣啊… 解問題為什麼不先 google / survey? )</p>\n<p>明天就是嘴砲的 brain storming~ to be continued.</p>\n<p>延伸閱讀：<br><a href=\"http://www.seinsights.asia/story/1434/795/2018\" target=\"_blank\" rel=\"noopener\">像福爾摩沙一樣解決社會問題 (同情心、同理心、觀察力)</a><br><a href=\"http://kenshinfujiwara.com/2011/11/problems-are-not-equal-to-needs/\" target=\"_blank\" rel=\"noopener\">Problems Are Not Equal to Needs</a><br><a href=\"http://www.logodesignlove.com/paul-rand-video\" target=\"_blank\" rel=\"noopener\">Don’t try to be original, try to be good.</a></p>\n"},{"title":"台大不一樣思考社：設計思考工作坊 Day 2","date":"2015-12-20T14:58:00.000Z","_content":"\n<u>組合虛擬人物 （CC）</u>\n\n第二天一早 Recap 的方式就是，從前一天的三個人物中合成一個叫 Jessica 的虛擬的人物 ( Composite Character )，這部分是很主觀的，先基於從現有列出來的 needs 和 insight 選出覺得有發展性的點。最後再藉由腦補內容、畫使用者畫像，像是 Persona 一樣把虛擬人物立體出來，因為花了一整天生出來的人，大家其實對他很熟悉 ( 比隨意的 Persona 熟的多 )。\n\n<u>腦力激盪 &nbsp;(Brain Storming )</u>\n\nCC有幾個 insight，最後選的 insight 是現代人會 Do something 來填補早餐的空白時間、像是滑手機，所以腦力激盪的目標變成就是想出一個「讓早餐時間不是空白時間」的方法。之後就是「不批評」「不打斷的」「不離題」的 Brain Storming 了。因為有了 Jessica，這個每個人都熟悉立體人物，**<u>溝通</u>**的時候變得方便很多，就像是有了使用者的原型一樣。Brain Storming 就是爽爽的啊，不過這次特別強調了「要延伸」他人想法、「要畫圖」要有「Title」等重點。\n\n發想的差不多後，用「強迫聯想」的方式做 Brain Storming，這部分也是蠻新奇的，先列出「教室」和「辦公室」裡的不相干用品，然後強迫生出可以滿足人物 insight 的想法，這邊會先卡住，然後只要有人開始分享，就會變得很多神奇的想法出來。最後再把所有的想法大概有 100 個吧，一人數票投票列出幾個、然後在二次投票，二次投票的時候才想起 Jessica，想哪一個想法比較可能滿足她。最後選擇用動的食物吸引注意力的迴轉壽司早餐。(好像是小隊輔提出來的... XD) 還有設定要驗證的幾個小想法，像是少量食物、多樣組合 blah 的\n\n<u>製作原型 (Prototyping)</u>\n\n快樂的 30分鐘 maker 時間，高級的扮家家酒和演戲，多次試驗。大家都玩開了~ 我只能說大家的手做能力很強大。\n\n<u>請使用者測試 ( Testing )</u>\n\n這步真的讓我看到 Prototype 的威力所在，第一個使用者就發現這個原型對使用者的感覺，雖來一進來就盯著移動中的食物，但跟我們思考的不一樣。因為迴轉壽司早餐比較像是有空閒時間才會去的地方，對想省時間的使用者。另外還有會發覺原型的問題，像是輸送列應該一開始就要有早餐在上面、最好加上文字說明。除了輸送列的早餐外，還要有菜單、送茶水的服務生不用帶位，特別強調是週末，悠閒的週六早上十點之類的情境。修一修加上演戲，原型多少有解到空白時間的問題，在第一個 iteration 應該算是不錯吧。\n\n<u>各小隊火力展示 ( Demo )</u>\n\n很意外的是其他六隊都做 App，而且有試著嘗試去解我認為早就被解完的問題：「有效率地得到早餐。」本來以為台灣早餐店林立、便利商店林立，早餐不用跑很遠、更不用自己做，還會剩下什麼需求沒被滿足嗎？結果是「熱騰騰好吃的早餐店要排隊」，於是就寫個注重體驗的訂餐、捷運門口取餐的App，然後第一次實體看到 App 的 Prototype長什麼樣子，點點點、換頁之類的，想到我做網頁、寫 App 錢真的也該先做好 Prototype 找個使用者來用用啊~~~\n\n<u>結語</u>\n這個工作坊是個團隊討論、體驗設計思考流程的好地方。本來以為價位有點高 ( 和我以前辦其他社團活動比 )。不過看到一組請三個陌生人使用者來受測、中午吃的還不錯、設計 conference 都很貴、1:2 的教練學員比，總總因素來說是 C/P 還不錯的。列一下 pros and cons：\n\npros:\n\n*   可以深入的練習觀察技巧\n*   思考使用者的需求和需求背後的原因\n*   快樂的團隊思考、討論體驗\n*   大量便利貼的利用技巧\n*   得到一種完整的設計流程體驗\n*   真實的和使用者接觸\n*   小隊輔們還蠻用心的\n*   可以碰到許多願意用溝通、用設計改變世界的人\n*   小遊戲很好玩\n*   一直放舞曲很High\ncons:\n\n*   和現實真的有一段距離 (感覺 TA 是學生)\n*   像「人本機構」的只鼓勵、不批評的環境讓「擁抱失敗」變成口號。\n*   建立「需求」、「insight」、「CC」，的過程中用了大量的假設，推論一錯就 GG\n*   完全不做現有解法的比較與調查 (像是摩斯訂餐 App)\n*   不介紹失敗的例子\n*   過度強調人本，但除了人的需求。技術和商業的重要性都不說明，一個好的偵探除了觀察和推理能力，對事物的知識也是很重要的。\n*   只有練習三個人以上的團體技巧。<div>---</div><div>有點小進步，不過感覺和 Design Researcher 的路還有好遠好遠。\n最後有點太專心討論和解題，好像沒有好好認識其他人啊，有點可惜~\n\n心理系的小隊輔一江、設計感的 Jarah、到處出現的 Boy、強大的設計師 美辰、很有主見的獸醫系 元皓、講話有趣的東璋、眼鏡很帥的財金系 軒凱、討厭心智圖但會組織演講的柏儒，這次有點忘記一期一會的決心...\n\n</div><div>記得感到痛苦和累的時候，稱讚一下自己吧「你努力離開舒適圈了喔 :p」</div>","source":"_posts/台大不一樣思考社：設計思考工作坊-Day-2.md","raw":"---\ntitle: 台大不一樣思考社：設計思考工作坊 Day 2\ntags:\n  - design\n  - ux\ndate: 2015-12-20 22:58:00\n---\n\n<u>組合虛擬人物 （CC）</u>\n\n第二天一早 Recap 的方式就是，從前一天的三個人物中合成一個叫 Jessica 的虛擬的人物 ( Composite Character )，這部分是很主觀的，先基於從現有列出來的 needs 和 insight 選出覺得有發展性的點。最後再藉由腦補內容、畫使用者畫像，像是 Persona 一樣把虛擬人物立體出來，因為花了一整天生出來的人，大家其實對他很熟悉 ( 比隨意的 Persona 熟的多 )。\n\n<u>腦力激盪 &nbsp;(Brain Storming )</u>\n\nCC有幾個 insight，最後選的 insight 是現代人會 Do something 來填補早餐的空白時間、像是滑手機，所以腦力激盪的目標變成就是想出一個「讓早餐時間不是空白時間」的方法。之後就是「不批評」「不打斷的」「不離題」的 Brain Storming 了。因為有了 Jessica，這個每個人都熟悉立體人物，**<u>溝通</u>**的時候變得方便很多，就像是有了使用者的原型一樣。Brain Storming 就是爽爽的啊，不過這次特別強調了「要延伸」他人想法、「要畫圖」要有「Title」等重點。\n\n發想的差不多後，用「強迫聯想」的方式做 Brain Storming，這部分也是蠻新奇的，先列出「教室」和「辦公室」裡的不相干用品，然後強迫生出可以滿足人物 insight 的想法，這邊會先卡住，然後只要有人開始分享，就會變得很多神奇的想法出來。最後再把所有的想法大概有 100 個吧，一人數票投票列出幾個、然後在二次投票，二次投票的時候才想起 Jessica，想哪一個想法比較可能滿足她。最後選擇用動的食物吸引注意力的迴轉壽司早餐。(好像是小隊輔提出來的... XD) 還有設定要驗證的幾個小想法，像是少量食物、多樣組合 blah 的\n\n<u>製作原型 (Prototyping)</u>\n\n快樂的 30分鐘 maker 時間，高級的扮家家酒和演戲，多次試驗。大家都玩開了~ 我只能說大家的手做能力很強大。\n\n<u>請使用者測試 ( Testing )</u>\n\n這步真的讓我看到 Prototype 的威力所在，第一個使用者就發現這個原型對使用者的感覺，雖來一進來就盯著移動中的食物，但跟我們思考的不一樣。因為迴轉壽司早餐比較像是有空閒時間才會去的地方，對想省時間的使用者。另外還有會發覺原型的問題，像是輸送列應該一開始就要有早餐在上面、最好加上文字說明。除了輸送列的早餐外，還要有菜單、送茶水的服務生不用帶位，特別強調是週末，悠閒的週六早上十點之類的情境。修一修加上演戲，原型多少有解到空白時間的問題，在第一個 iteration 應該算是不錯吧。\n\n<u>各小隊火力展示 ( Demo )</u>\n\n很意外的是其他六隊都做 App，而且有試著嘗試去解我認為早就被解完的問題：「有效率地得到早餐。」本來以為台灣早餐店林立、便利商店林立，早餐不用跑很遠、更不用自己做，還會剩下什麼需求沒被滿足嗎？結果是「熱騰騰好吃的早餐店要排隊」，於是就寫個注重體驗的訂餐、捷運門口取餐的App，然後第一次實體看到 App 的 Prototype長什麼樣子，點點點、換頁之類的，想到我做網頁、寫 App 錢真的也該先做好 Prototype 找個使用者來用用啊~~~\n\n<u>結語</u>\n這個工作坊是個團隊討論、體驗設計思考流程的好地方。本來以為價位有點高 ( 和我以前辦其他社團活動比 )。不過看到一組請三個陌生人使用者來受測、中午吃的還不錯、設計 conference 都很貴、1:2 的教練學員比，總總因素來說是 C/P 還不錯的。列一下 pros and cons：\n\npros:\n\n*   可以深入的練習觀察技巧\n*   思考使用者的需求和需求背後的原因\n*   快樂的團隊思考、討論體驗\n*   大量便利貼的利用技巧\n*   得到一種完整的設計流程體驗\n*   真實的和使用者接觸\n*   小隊輔們還蠻用心的\n*   可以碰到許多願意用溝通、用設計改變世界的人\n*   小遊戲很好玩\n*   一直放舞曲很High\ncons:\n\n*   和現實真的有一段距離 (感覺 TA 是學生)\n*   像「人本機構」的只鼓勵、不批評的環境讓「擁抱失敗」變成口號。\n*   建立「需求」、「insight」、「CC」，的過程中用了大量的假設，推論一錯就 GG\n*   完全不做現有解法的比較與調查 (像是摩斯訂餐 App)\n*   不介紹失敗的例子\n*   過度強調人本，但除了人的需求。技術和商業的重要性都不說明，一個好的偵探除了觀察和推理能力，對事物的知識也是很重要的。\n*   只有練習三個人以上的團體技巧。<div>---</div><div>有點小進步，不過感覺和 Design Researcher 的路還有好遠好遠。\n最後有點太專心討論和解題，好像沒有好好認識其他人啊，有點可惜~\n\n心理系的小隊輔一江、設計感的 Jarah、到處出現的 Boy、強大的設計師 美辰、很有主見的獸醫系 元皓、講話有趣的東璋、眼鏡很帥的財金系 軒凱、討厭心智圖但會組織演講的柏儒，這次有點忘記一期一會的決心...\n\n</div><div>記得感到痛苦和累的時候，稱讚一下自己吧「你努力離開舒適圈了喔 :p」</div>","slug":"台大不一樣思考社：設計思考工作坊-Day-2","published":1,"updated":"2017-12-23T06:08:08.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjblkzclg000sxq9k92rd8q18","content":"<p><u>組合虛擬人物 （CC）</u></p>\n<p>第二天一早 Recap 的方式就是，從前一天的三個人物中合成一個叫 Jessica 的虛擬的人物 ( Composite Character )，這部分是很主觀的，先基於從現有列出來的 needs 和 insight 選出覺得有發展性的點。最後再藉由腦補內容、畫使用者畫像，像是 Persona 一樣把虛擬人物立體出來，因為花了一整天生出來的人，大家其實對他很熟悉 ( 比隨意的 Persona 熟的多 )。</p>\n<p><u>腦力激盪 &nbsp;(Brain Storming )</u></p>\n<p>CC有幾個 insight，最後選的 insight 是現代人會 Do something 來填補早餐的空白時間、像是滑手機，所以腦力激盪的目標變成就是想出一個「讓早餐時間不是空白時間」的方法。之後就是「不批評」「不打斷的」「不離題」的 Brain Storming 了。因為有了 Jessica，這個每個人都熟悉立體人物，<strong><u>溝通</u></strong>的時候變得方便很多，就像是有了使用者的原型一樣。Brain Storming 就是爽爽的啊，不過這次特別強調了「要延伸」他人想法、「要畫圖」要有「Title」等重點。</p>\n<p>發想的差不多後，用「強迫聯想」的方式做 Brain Storming，這部分也是蠻新奇的，先列出「教室」和「辦公室」裡的不相干用品，然後強迫生出可以滿足人物 insight 的想法，這邊會先卡住，然後只要有人開始分享，就會變得很多神奇的想法出來。最後再把所有的想法大概有 100 個吧，一人數票投票列出幾個、然後在二次投票，二次投票的時候才想起 Jessica，想哪一個想法比較可能滿足她。最後選擇用動的食物吸引注意力的迴轉壽司早餐。(好像是小隊輔提出來的… XD) 還有設定要驗證的幾個小想法，像是少量食物、多樣組合 blah 的</p>\n<p><u>製作原型 (Prototyping)</u></p>\n<p>快樂的 30分鐘 maker 時間，高級的扮家家酒和演戲，多次試驗。大家都玩開了~ 我只能說大家的手做能力很強大。</p>\n<p><u>請使用者測試 ( Testing )</u></p>\n<p>這步真的讓我看到 Prototype 的威力所在，第一個使用者就發現這個原型對使用者的感覺，雖來一進來就盯著移動中的食物，但跟我們思考的不一樣。因為迴轉壽司早餐比較像是有空閒時間才會去的地方，對想省時間的使用者。另外還有會發覺原型的問題，像是輸送列應該一開始就要有早餐在上面、最好加上文字說明。除了輸送列的早餐外，還要有菜單、送茶水的服務生不用帶位，特別強調是週末，悠閒的週六早上十點之類的情境。修一修加上演戲，原型多少有解到空白時間的問題，在第一個 iteration 應該算是不錯吧。</p>\n<p><u>各小隊火力展示 ( Demo )</u></p>\n<p>很意外的是其他六隊都做 App，而且有試著嘗試去解我認為早就被解完的問題：「有效率地得到早餐。」本來以為台灣早餐店林立、便利商店林立，早餐不用跑很遠、更不用自己做，還會剩下什麼需求沒被滿足嗎？結果是「熱騰騰好吃的早餐店要排隊」，於是就寫個注重體驗的訂餐、捷運門口取餐的App，然後第一次實體看到 App 的 Prototype長什麼樣子，點點點、換頁之類的，想到我做網頁、寫 App 錢真的也該先做好 Prototype 找個使用者來用用啊~~~</p>\n<p><u>結語</u><br>這個工作坊是個團隊討論、體驗設計思考流程的好地方。本來以為價位有點高 ( 和我以前辦其他社團活動比 )。不過看到一組請三個陌生人使用者來受測、中午吃的還不錯、設計 conference 都很貴、1:2 的教練學員比，總總因素來說是 C/P 還不錯的。列一下 pros and cons：</p>\n<p>pros:</p>\n<ul>\n<li>可以深入的練習觀察技巧</li>\n<li>思考使用者的需求和需求背後的原因</li>\n<li>快樂的團隊思考、討論體驗</li>\n<li>大量便利貼的利用技巧</li>\n<li>得到一種完整的設計流程體驗</li>\n<li>真實的和使用者接觸</li>\n<li>小隊輔們還蠻用心的</li>\n<li>可以碰到許多願意用溝通、用設計改變世界的人</li>\n<li>小遊戲很好玩</li>\n<li><p>一直放舞曲很High<br>cons:</p>\n</li>\n<li><p>和現實真的有一段距離 (感覺 TA 是學生)</p>\n</li>\n<li>像「人本機構」的只鼓勵、不批評的環境讓「擁抱失敗」變成口號。</li>\n<li>建立「需求」、「insight」、「CC」，的過程中用了大量的假設，推論一錯就 GG</li>\n<li>完全不做現有解法的比較與調查 (像是摩斯訂餐 App)</li>\n<li>不介紹失敗的例子</li>\n<li>過度強調人本，但除了人的需求。技術和商業的重要性都不說明，一個好的偵探除了觀察和推理能力，對事物的知識也是很重要的。</li>\n<li>只有練習三個人以上的團體技巧。<div>—</div><div>有點小進步，不過感覺和 Design Researcher 的路還有好遠好遠。<br>最後有點太專心討論和解題，好像沒有好好認識其他人啊，有點可惜~</div></li>\n</ul>\n<p>心理系的小隊輔一江、設計感的 Jarah、到處出現的 Boy、強大的設計師 美辰、很有主見的獸醫系 元皓、講話有趣的東璋、眼鏡很帥的財金系 軒凱、討厭心智圖但會組織演講的柏儒，這次有點忘記一期一會的決心…</p>\n<p><div>記得感到痛苦和累的時候，稱讚一下自己吧「你努力離開舒適圈了喔 :p」</div></p>\n","site":{"data":{}},"excerpt":"","more":"<p><u>組合虛擬人物 （CC）</u></p>\n<p>第二天一早 Recap 的方式就是，從前一天的三個人物中合成一個叫 Jessica 的虛擬的人物 ( Composite Character )，這部分是很主觀的，先基於從現有列出來的 needs 和 insight 選出覺得有發展性的點。最後再藉由腦補內容、畫使用者畫像，像是 Persona 一樣把虛擬人物立體出來，因為花了一整天生出來的人，大家其實對他很熟悉 ( 比隨意的 Persona 熟的多 )。</p>\n<p><u>腦力激盪 &nbsp;(Brain Storming )</u></p>\n<p>CC有幾個 insight，最後選的 insight 是現代人會 Do something 來填補早餐的空白時間、像是滑手機，所以腦力激盪的目標變成就是想出一個「讓早餐時間不是空白時間」的方法。之後就是「不批評」「不打斷的」「不離題」的 Brain Storming 了。因為有了 Jessica，這個每個人都熟悉立體人物，<strong><u>溝通</u></strong>的時候變得方便很多，就像是有了使用者的原型一樣。Brain Storming 就是爽爽的啊，不過這次特別強調了「要延伸」他人想法、「要畫圖」要有「Title」等重點。</p>\n<p>發想的差不多後，用「強迫聯想」的方式做 Brain Storming，這部分也是蠻新奇的，先列出「教室」和「辦公室」裡的不相干用品，然後強迫生出可以滿足人物 insight 的想法，這邊會先卡住，然後只要有人開始分享，就會變得很多神奇的想法出來。最後再把所有的想法大概有 100 個吧，一人數票投票列出幾個、然後在二次投票，二次投票的時候才想起 Jessica，想哪一個想法比較可能滿足她。最後選擇用動的食物吸引注意力的迴轉壽司早餐。(好像是小隊輔提出來的… XD) 還有設定要驗證的幾個小想法，像是少量食物、多樣組合 blah 的</p>\n<p><u>製作原型 (Prototyping)</u></p>\n<p>快樂的 30分鐘 maker 時間，高級的扮家家酒和演戲，多次試驗。大家都玩開了~ 我只能說大家的手做能力很強大。</p>\n<p><u>請使用者測試 ( Testing )</u></p>\n<p>這步真的讓我看到 Prototype 的威力所在，第一個使用者就發現這個原型對使用者的感覺，雖來一進來就盯著移動中的食物，但跟我們思考的不一樣。因為迴轉壽司早餐比較像是有空閒時間才會去的地方，對想省時間的使用者。另外還有會發覺原型的問題，像是輸送列應該一開始就要有早餐在上面、最好加上文字說明。除了輸送列的早餐外，還要有菜單、送茶水的服務生不用帶位，特別強調是週末，悠閒的週六早上十點之類的情境。修一修加上演戲，原型多少有解到空白時間的問題，在第一個 iteration 應該算是不錯吧。</p>\n<p><u>各小隊火力展示 ( Demo )</u></p>\n<p>很意外的是其他六隊都做 App，而且有試著嘗試去解我認為早就被解完的問題：「有效率地得到早餐。」本來以為台灣早餐店林立、便利商店林立，早餐不用跑很遠、更不用自己做，還會剩下什麼需求沒被滿足嗎？結果是「熱騰騰好吃的早餐店要排隊」，於是就寫個注重體驗的訂餐、捷運門口取餐的App，然後第一次實體看到 App 的 Prototype長什麼樣子，點點點、換頁之類的，想到我做網頁、寫 App 錢真的也該先做好 Prototype 找個使用者來用用啊~~~</p>\n<p><u>結語</u><br>這個工作坊是個團隊討論、體驗設計思考流程的好地方。本來以為價位有點高 ( 和我以前辦其他社團活動比 )。不過看到一組請三個陌生人使用者來受測、中午吃的還不錯、設計 conference 都很貴、1:2 的教練學員比，總總因素來說是 C/P 還不錯的。列一下 pros and cons：</p>\n<p>pros:</p>\n<ul>\n<li>可以深入的練習觀察技巧</li>\n<li>思考使用者的需求和需求背後的原因</li>\n<li>快樂的團隊思考、討論體驗</li>\n<li>大量便利貼的利用技巧</li>\n<li>得到一種完整的設計流程體驗</li>\n<li>真實的和使用者接觸</li>\n<li>小隊輔們還蠻用心的</li>\n<li>可以碰到許多願意用溝通、用設計改變世界的人</li>\n<li>小遊戲很好玩</li>\n<li><p>一直放舞曲很High<br>cons:</p>\n</li>\n<li><p>和現實真的有一段距離 (感覺 TA 是學生)</p>\n</li>\n<li>像「人本機構」的只鼓勵、不批評的環境讓「擁抱失敗」變成口號。</li>\n<li>建立「需求」、「insight」、「CC」，的過程中用了大量的假設，推論一錯就 GG</li>\n<li>完全不做現有解法的比較與調查 (像是摩斯訂餐 App)</li>\n<li>不介紹失敗的例子</li>\n<li>過度強調人本，但除了人的需求。技術和商業的重要性都不說明，一個好的偵探除了觀察和推理能力，對事物的知識也是很重要的。</li>\n<li>只有練習三個人以上的團體技巧。<div>—</div><div>有點小進步，不過感覺和 Design Researcher 的路還有好遠好遠。<br>最後有點太專心討論和解題，好像沒有好好認識其他人啊，有點可惜~</div></li>\n</ul>\n<p>心理系的小隊輔一江、設計感的 Jarah、到處出現的 Boy、強大的設計師 美辰、很有主見的獸醫系 元皓、講話有趣的東璋、眼鏡很帥的財金系 軒凱、討厭心智圖但會組織演講的柏儒，這次有點忘記一期一會的決心…</p>\n<p><div>記得感到痛苦和累的時候，稱讚一下自己吧「你努力離開舒適圈了喔 :p」</div></p>\n"},{"title":"大腦超載時代的思考學 The Organized Mind: Thinking Straight in the Age of Information Overload","date":"2016-06-01T10:32:00.000Z","_content":"\n<div class=\"separator\" style=\"clear: both; text-align: center;\">\n  <iframe width=\"480\" height=\"320\" class=\"YOUTUBE-iframe-video\" data-thumbnail-src=\"https://i.ytimg.com/vi/aR1TNEHRY-U/0.jpg\" src=\"https://www.youtube.com/embed/aR1TNEHRY-U?feature=player_embedded\" frameborder=\"0\" allowfullscreen>\n  </iframe>\n</div>\n\n### 演講摘要：\n\n我今天要講三個大主題：多工(Multitasking)、延伸大腦(Brain Extender)、決策(Decision Making)。\n\n不過在開始之前我想先說一下為什麼我寫了這本書，過去十年的神經科學發現了許多「為什麼大腦對某些事情注意、而對其他事情忽略的」的原因。我相信大多數人都可以用這些資訊來更好的組織時間、家裡的事物、工作環境。\n\n講了現代資訊過載的問題，一堆數字...。\n\n我們可以怎麼做？大部分人想嘗試多工，不過現在的研究顯示，多工在人大腦是不存在的，大腦只能快速的在循序中切換。多工會造成釋放和壓力相關的...，幾個小時多工後會很累。大量多工的工作(航管員、同步口譯員) 都會安排中間休息的時間。根據研究，多工會降低產出。但大腦會欺騙自己多工也許是有用的，就像喝醉酒之後覺得自己很好一樣。\n\n那我們要怎麼辦，我們可以像航管員、同步口譯員一樣中間休息一下。研究顯示這樣會讓員工有更好的生產力和更好的產出。像是每幾個小時就有15分鐘的休息。小睡一下很有用，白天小睡15分鐘有時候等於夜裡睡一個半小時的效力，能提高你的IQ 10點。小睡一下會讓大腦補充用完的 glucose；而中間休息可以讓你進入另一個不同的注意力模式。\n\n人類大腦有兩種主要的注意力模式：中央主導模式(task positive network)、白日夢模式(default mode of brain / task negative network / mind wandering mode)。在白日夢模式你會開始覺得事物開始連結、以非線性思考的方式。所以在兩個模式交互切換是很重要的。\n\n注意力切換(attention switching)和決策(decision making)會消耗大腦中的燃料。明確的說，會消耗讓葡萄糖(glucose)，讓葡萄糖是神經元運作代謝需要的物質。而且讓葡萄糖並不能無限量供應，不管是大決定還是小決定都會消耗這個燃料。即使在挑選筆的顏色，你也在消耗人生重要決定的燃料。而切換到白日夢模式會讓你的大腦回到預設模式，讓葡萄糖(glucose)重新恢復。小睡一下、小中斷、去渡個假都很有幫助。當我說小中斷(take a break)指的並不是回電子郵件、去看個電視，這樣並不是中斷(break)。而是真正的中斷，讓你的大腦可以真正的做白日夢(really wander)。而我們每個人都有自己的方式可以開始白日夢模式。這個方式也許是，運動、在自然中散步... 像是快思慢想的作者，每天的下午都會找一段時間在史丹佛校園中散步，據他所說大部分的好想法都是那段時間產生的，這不是巧合，這是一個恢復的行為。\n\n根據研究，那些一週工作六十小時的人的產出只有比一週工作四十小時的人的產出多七個小時。想一想是不是值得多花二十小時得到多七個小時的產出。\n\n所以我們該怎麼辦，怎麼專注的做事情？一件專家會做的事是「強迫有生產力的時間」(enforce productivity hours)。他們會在一天中找一段時間，讓那段時間完全不會被中斷、打擾，關掉電子郵件軟體、甚至關掉手機。讓他們能進入全神貫注的狀態。如果你無法關掉電子郵件軟體，因為可能會有突發狀況進來，那試著開一個私下的帳號，告訴其他人有緊急的事才用這個郵件位置。不緊急的事請，送到那個公開不常開的帳號。 很多成功的執行長、藝術家都這樣的切分人生的時間，一次只做好一件事。\n\n接下來我將切換到談，大腦延伸器(Brain extender)。這是一個簡單的想法。如果你想要有生產力，不要把不需要的東西放進大腦裡。像是聽到明天會下雨，與其在腦袋記著說要帶傘、要帶傘，還不如把這個資訊放到環境裡面去，像是把傘從櫃子拿出來放到門邊，然後它就會在你出門時提醒你。另一個例子是設計心理學中門的例子，為什麼人要記得門要推開還是拉開，直接用設計隱藏預設用途就好(拉的話放門把)，像是廁所的門。另一個方式外部化是我們把事情寫下來。而把事情寫下來，其實比打字下來更適合，因爲寫字時的引發的神經活動是不同的，大腦會更深入的去處理這個資訊。最後一個例子是 Google，我們不用記得細節，只要記得關鍵字，就可以找到我們要的資訊。\n\n最後我想說的是決策(Decision Making)，我們現在擁有的資訊，能讓我們做出以前不能做出的決策。特別是在醫學上資訊的過載，而醫生並沒有受過大量資訊決策的訓練，像是取得和分析。我覺得我們的教育應該要開始改變，要教導資訊處理(information literacy)，而不是之前教育的大量事實。教導他們要如何有創意的使用這些事實來幫助他們去解決真實世界中的問題。判斷資訊到底是否可信。舉例了醫生決策有多複雜，因為每種藥都有有效率、多種副作用的成功率。我覺得像這種判斷應該從八歲開始教。\n——\n29:30 開始 Q&A。\n\n做決策的時候先把事項排優先順序，在狀態好的時候把大事情處理完。\n\n注意力缺失症？他們的白日夢模式很強，也就是說他們創意很強，但沒法做不完事情，也許他們可以和其他過度專注的人合作，會很成功。\n\nMotor learning怎樣會有效率？光只是重複性的運動並不是很有效，你必須有意識地、有目的的做那件事。音樂家叫這個故意練習(deliberately practice)。鋼琴家想像練習時不光只有想像手指怎麼動，還要思考音符的意義.... blah blah practice mindfully. \n\n夜晚六到十小時的睡眠，會經過一個記憶鞏固(memory consolidation)的過程，神經元會重新重現、處理白天有過的神經活動，然後想辦法讓它進入長期記憶、連結、 儲存他們。如果你白天很努力的工作四到五個小時，取得很多的資訊。這時候小睡一下，大腦會進入睡眠階段，開啟了神經元重啟的按鈕，讓某些迴路變的放鬆，你會預先處理一些資訊讓晚上再做後續處理。\n","source":"_posts/大腦超載時代的思考學-The-Organized-Mind-Thinking-Straight-in-the-Age-of-Information-Overload.md","raw":"---\ntitle: >-\n  大腦超載時代的思考學 The Organized Mind: Thinking Straight in the Age of Information\n  Overload\ntags:\n  - attention\n  - cognitive psychology\n  - information\n  - psychology\ndate: 2016-06-01 18:32:00\n---\n\n<div class=\"separator\" style=\"clear: both; text-align: center;\">\n  <iframe width=\"480\" height=\"320\" class=\"YOUTUBE-iframe-video\" data-thumbnail-src=\"https://i.ytimg.com/vi/aR1TNEHRY-U/0.jpg\" src=\"https://www.youtube.com/embed/aR1TNEHRY-U?feature=player_embedded\" frameborder=\"0\" allowfullscreen>\n  </iframe>\n</div>\n\n### 演講摘要：\n\n我今天要講三個大主題：多工(Multitasking)、延伸大腦(Brain Extender)、決策(Decision Making)。\n\n不過在開始之前我想先說一下為什麼我寫了這本書，過去十年的神經科學發現了許多「為什麼大腦對某些事情注意、而對其他事情忽略的」的原因。我相信大多數人都可以用這些資訊來更好的組織時間、家裡的事物、工作環境。\n\n講了現代資訊過載的問題，一堆數字...。\n\n我們可以怎麼做？大部分人想嘗試多工，不過現在的研究顯示，多工在人大腦是不存在的，大腦只能快速的在循序中切換。多工會造成釋放和壓力相關的...，幾個小時多工後會很累。大量多工的工作(航管員、同步口譯員) 都會安排中間休息的時間。根據研究，多工會降低產出。但大腦會欺騙自己多工也許是有用的，就像喝醉酒之後覺得自己很好一樣。\n\n那我們要怎麼辦，我們可以像航管員、同步口譯員一樣中間休息一下。研究顯示這樣會讓員工有更好的生產力和更好的產出。像是每幾個小時就有15分鐘的休息。小睡一下很有用，白天小睡15分鐘有時候等於夜裡睡一個半小時的效力，能提高你的IQ 10點。小睡一下會讓大腦補充用完的 glucose；而中間休息可以讓你進入另一個不同的注意力模式。\n\n人類大腦有兩種主要的注意力模式：中央主導模式(task positive network)、白日夢模式(default mode of brain / task negative network / mind wandering mode)。在白日夢模式你會開始覺得事物開始連結、以非線性思考的方式。所以在兩個模式交互切換是很重要的。\n\n注意力切換(attention switching)和決策(decision making)會消耗大腦中的燃料。明確的說，會消耗讓葡萄糖(glucose)，讓葡萄糖是神經元運作代謝需要的物質。而且讓葡萄糖並不能無限量供應，不管是大決定還是小決定都會消耗這個燃料。即使在挑選筆的顏色，你也在消耗人生重要決定的燃料。而切換到白日夢模式會讓你的大腦回到預設模式，讓葡萄糖(glucose)重新恢復。小睡一下、小中斷、去渡個假都很有幫助。當我說小中斷(take a break)指的並不是回電子郵件、去看個電視，這樣並不是中斷(break)。而是真正的中斷，讓你的大腦可以真正的做白日夢(really wander)。而我們每個人都有自己的方式可以開始白日夢模式。這個方式也許是，運動、在自然中散步... 像是快思慢想的作者，每天的下午都會找一段時間在史丹佛校園中散步，據他所說大部分的好想法都是那段時間產生的，這不是巧合，這是一個恢復的行為。\n\n根據研究，那些一週工作六十小時的人的產出只有比一週工作四十小時的人的產出多七個小時。想一想是不是值得多花二十小時得到多七個小時的產出。\n\n所以我們該怎麼辦，怎麼專注的做事情？一件專家會做的事是「強迫有生產力的時間」(enforce productivity hours)。他們會在一天中找一段時間，讓那段時間完全不會被中斷、打擾，關掉電子郵件軟體、甚至關掉手機。讓他們能進入全神貫注的狀態。如果你無法關掉電子郵件軟體，因為可能會有突發狀況進來，那試著開一個私下的帳號，告訴其他人有緊急的事才用這個郵件位置。不緊急的事請，送到那個公開不常開的帳號。 很多成功的執行長、藝術家都這樣的切分人生的時間，一次只做好一件事。\n\n接下來我將切換到談，大腦延伸器(Brain extender)。這是一個簡單的想法。如果你想要有生產力，不要把不需要的東西放進大腦裡。像是聽到明天會下雨，與其在腦袋記著說要帶傘、要帶傘，還不如把這個資訊放到環境裡面去，像是把傘從櫃子拿出來放到門邊，然後它就會在你出門時提醒你。另一個例子是設計心理學中門的例子，為什麼人要記得門要推開還是拉開，直接用設計隱藏預設用途就好(拉的話放門把)，像是廁所的門。另一個方式外部化是我們把事情寫下來。而把事情寫下來，其實比打字下來更適合，因爲寫字時的引發的神經活動是不同的，大腦會更深入的去處理這個資訊。最後一個例子是 Google，我們不用記得細節，只要記得關鍵字，就可以找到我們要的資訊。\n\n最後我想說的是決策(Decision Making)，我們現在擁有的資訊，能讓我們做出以前不能做出的決策。特別是在醫學上資訊的過載，而醫生並沒有受過大量資訊決策的訓練，像是取得和分析。我覺得我們的教育應該要開始改變，要教導資訊處理(information literacy)，而不是之前教育的大量事實。教導他們要如何有創意的使用這些事實來幫助他們去解決真實世界中的問題。判斷資訊到底是否可信。舉例了醫生決策有多複雜，因為每種藥都有有效率、多種副作用的成功率。我覺得像這種判斷應該從八歲開始教。\n——\n29:30 開始 Q&A。\n\n做決策的時候先把事項排優先順序，在狀態好的時候把大事情處理完。\n\n注意力缺失症？他們的白日夢模式很強，也就是說他們創意很強，但沒法做不完事情，也許他們可以和其他過度專注的人合作，會很成功。\n\nMotor learning怎樣會有效率？光只是重複性的運動並不是很有效，你必須有意識地、有目的的做那件事。音樂家叫這個故意練習(deliberately practice)。鋼琴家想像練習時不光只有想像手指怎麼動，還要思考音符的意義.... blah blah practice mindfully. \n\n夜晚六到十小時的睡眠，會經過一個記憶鞏固(memory consolidation)的過程，神經元會重新重現、處理白天有過的神經活動，然後想辦法讓它進入長期記憶、連結、 儲存他們。如果你白天很努力的工作四到五個小時，取得很多的資訊。這時候小睡一下，大腦會進入睡眠階段，開啟了神經元重啟的按鈕，讓某些迴路變的放鬆，你會預先處理一些資訊讓晚上再做後續處理。\n","slug":"大腦超載時代的思考學-The-Organized-Mind-Thinking-Straight-in-the-Age-of-Information-Overload","published":1,"updated":"2017-12-25T02:19:53.076Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjblkzclk000uxq9k4rzk4esc","content":"<div class=\"separator\" style=\"clear: both; text-align: center;\"><br>  <iframe width=\"480\" height=\"320\" class=\"YOUTUBE-iframe-video\" data-thumbnail-src=\"https://i.ytimg.com/vi/aR1TNEHRY-U/0.jpg\" src=\"https://www.youtube.com/embed/aR1TNEHRY-U?feature=player_embedded\" frameborder=\"0\" allowfullscreen><br>  </iframe><br></div>\n\n<h3 id=\"演講摘要：\"><a href=\"#演講摘要：\" class=\"headerlink\" title=\"演講摘要：\"></a>演講摘要：</h3><p>我今天要講三個大主題：多工(Multitasking)、延伸大腦(Brain Extender)、決策(Decision Making)。</p>\n<p>不過在開始之前我想先說一下為什麼我寫了這本書，過去十年的神經科學發現了許多「為什麼大腦對某些事情注意、而對其他事情忽略的」的原因。我相信大多數人都可以用這些資訊來更好的組織時間、家裡的事物、工作環境。</p>\n<p>講了現代資訊過載的問題，一堆數字…。</p>\n<p>我們可以怎麼做？大部分人想嘗試多工，不過現在的研究顯示，多工在人大腦是不存在的，大腦只能快速的在循序中切換。多工會造成釋放和壓力相關的…，幾個小時多工後會很累。大量多工的工作(航管員、同步口譯員) 都會安排中間休息的時間。根據研究，多工會降低產出。但大腦會欺騙自己多工也許是有用的，就像喝醉酒之後覺得自己很好一樣。</p>\n<p>那我們要怎麼辦，我們可以像航管員、同步口譯員一樣中間休息一下。研究顯示這樣會讓員工有更好的生產力和更好的產出。像是每幾個小時就有15分鐘的休息。小睡一下很有用，白天小睡15分鐘有時候等於夜裡睡一個半小時的效力，能提高你的IQ 10點。小睡一下會讓大腦補充用完的 glucose；而中間休息可以讓你進入另一個不同的注意力模式。</p>\n<p>人類大腦有兩種主要的注意力模式：中央主導模式(task positive network)、白日夢模式(default mode of brain / task negative network / mind wandering mode)。在白日夢模式你會開始覺得事物開始連結、以非線性思考的方式。所以在兩個模式交互切換是很重要的。</p>\n<p>注意力切換(attention switching)和決策(decision making)會消耗大腦中的燃料。明確的說，會消耗讓葡萄糖(glucose)，讓葡萄糖是神經元運作代謝需要的物質。而且讓葡萄糖並不能無限量供應，不管是大決定還是小決定都會消耗這個燃料。即使在挑選筆的顏色，你也在消耗人生重要決定的燃料。而切換到白日夢模式會讓你的大腦回到預設模式，讓葡萄糖(glucose)重新恢復。小睡一下、小中斷、去渡個假都很有幫助。當我說小中斷(take a break)指的並不是回電子郵件、去看個電視，這樣並不是中斷(break)。而是真正的中斷，讓你的大腦可以真正的做白日夢(really wander)。而我們每個人都有自己的方式可以開始白日夢模式。這個方式也許是，運動、在自然中散步… 像是快思慢想的作者，每天的下午都會找一段時間在史丹佛校園中散步，據他所說大部分的好想法都是那段時間產生的，這不是巧合，這是一個恢復的行為。</p>\n<p>根據研究，那些一週工作六十小時的人的產出只有比一週工作四十小時的人的產出多七個小時。想一想是不是值得多花二十小時得到多七個小時的產出。</p>\n<p>所以我們該怎麼辦，怎麼專注的做事情？一件專家會做的事是「強迫有生產力的時間」(enforce productivity hours)。他們會在一天中找一段時間，讓那段時間完全不會被中斷、打擾，關掉電子郵件軟體、甚至關掉手機。讓他們能進入全神貫注的狀態。如果你無法關掉電子郵件軟體，因為可能會有突發狀況進來，那試著開一個私下的帳號，告訴其他人有緊急的事才用這個郵件位置。不緊急的事請，送到那個公開不常開的帳號。 很多成功的執行長、藝術家都這樣的切分人生的時間，一次只做好一件事。</p>\n<p>接下來我將切換到談，大腦延伸器(Brain extender)。這是一個簡單的想法。如果你想要有生產力，不要把不需要的東西放進大腦裡。像是聽到明天會下雨，與其在腦袋記著說要帶傘、要帶傘，還不如把這個資訊放到環境裡面去，像是把傘從櫃子拿出來放到門邊，然後它就會在你出門時提醒你。另一個例子是設計心理學中門的例子，為什麼人要記得門要推開還是拉開，直接用設計隱藏預設用途就好(拉的話放門把)，像是廁所的門。另一個方式外部化是我們把事情寫下來。而把事情寫下來，其實比打字下來更適合，因爲寫字時的引發的神經活動是不同的，大腦會更深入的去處理這個資訊。最後一個例子是 Google，我們不用記得細節，只要記得關鍵字，就可以找到我們要的資訊。</p>\n<p>最後我想說的是決策(Decision Making)，我們現在擁有的資訊，能讓我們做出以前不能做出的決策。特別是在醫學上資訊的過載，而醫生並沒有受過大量資訊決策的訓練，像是取得和分析。我覺得我們的教育應該要開始改變，要教導資訊處理(information literacy)，而不是之前教育的大量事實。教導他們要如何有創意的使用這些事實來幫助他們去解決真實世界中的問題。判斷資訊到底是否可信。舉例了醫生決策有多複雜，因為每種藥都有有效率、多種副作用的成功率。我覺得像這種判斷應該從八歲開始教。<br>——<br>29:30 開始 Q&amp;A。</p>\n<p>做決策的時候先把事項排優先順序，在狀態好的時候把大事情處理完。</p>\n<p>注意力缺失症？他們的白日夢模式很強，也就是說他們創意很強，但沒法做不完事情，也許他們可以和其他過度專注的人合作，會很成功。</p>\n<p>Motor learning怎樣會有效率？光只是重複性的運動並不是很有效，你必須有意識地、有目的的做那件事。音樂家叫這個故意練習(deliberately practice)。鋼琴家想像練習時不光只有想像手指怎麼動，還要思考音符的意義…. blah blah practice mindfully. </p>\n<p>夜晚六到十小時的睡眠，會經過一個記憶鞏固(memory consolidation)的過程，神經元會重新重現、處理白天有過的神經活動，然後想辦法讓它進入長期記憶、連結、 儲存他們。如果你白天很努力的工作四到五個小時，取得很多的資訊。這時候小睡一下，大腦會進入睡眠階段，開啟了神經元重啟的按鈕，讓某些迴路變的放鬆，你會預先處理一些資訊讓晚上再做後續處理。</p>\n","site":{"data":{}},"excerpt":"","more":"<div class=\"separator\" style=\"clear: both; text-align: center;\"><br>  <iframe width=\"480\" height=\"320\" class=\"YOUTUBE-iframe-video\" data-thumbnail-src=\"https://i.ytimg.com/vi/aR1TNEHRY-U/0.jpg\" src=\"https://www.youtube.com/embed/aR1TNEHRY-U?feature=player_embedded\" frameborder=\"0\" allowfullscreen><br>  </iframe><br></div>\n\n<h3 id=\"演講摘要：\"><a href=\"#演講摘要：\" class=\"headerlink\" title=\"演講摘要：\"></a>演講摘要：</h3><p>我今天要講三個大主題：多工(Multitasking)、延伸大腦(Brain Extender)、決策(Decision Making)。</p>\n<p>不過在開始之前我想先說一下為什麼我寫了這本書，過去十年的神經科學發現了許多「為什麼大腦對某些事情注意、而對其他事情忽略的」的原因。我相信大多數人都可以用這些資訊來更好的組織時間、家裡的事物、工作環境。</p>\n<p>講了現代資訊過載的問題，一堆數字…。</p>\n<p>我們可以怎麼做？大部分人想嘗試多工，不過現在的研究顯示，多工在人大腦是不存在的，大腦只能快速的在循序中切換。多工會造成釋放和壓力相關的…，幾個小時多工後會很累。大量多工的工作(航管員、同步口譯員) 都會安排中間休息的時間。根據研究，多工會降低產出。但大腦會欺騙自己多工也許是有用的，就像喝醉酒之後覺得自己很好一樣。</p>\n<p>那我們要怎麼辦，我們可以像航管員、同步口譯員一樣中間休息一下。研究顯示這樣會讓員工有更好的生產力和更好的產出。像是每幾個小時就有15分鐘的休息。小睡一下很有用，白天小睡15分鐘有時候等於夜裡睡一個半小時的效力，能提高你的IQ 10點。小睡一下會讓大腦補充用完的 glucose；而中間休息可以讓你進入另一個不同的注意力模式。</p>\n<p>人類大腦有兩種主要的注意力模式：中央主導模式(task positive network)、白日夢模式(default mode of brain / task negative network / mind wandering mode)。在白日夢模式你會開始覺得事物開始連結、以非線性思考的方式。所以在兩個模式交互切換是很重要的。</p>\n<p>注意力切換(attention switching)和決策(decision making)會消耗大腦中的燃料。明確的說，會消耗讓葡萄糖(glucose)，讓葡萄糖是神經元運作代謝需要的物質。而且讓葡萄糖並不能無限量供應，不管是大決定還是小決定都會消耗這個燃料。即使在挑選筆的顏色，你也在消耗人生重要決定的燃料。而切換到白日夢模式會讓你的大腦回到預設模式，讓葡萄糖(glucose)重新恢復。小睡一下、小中斷、去渡個假都很有幫助。當我說小中斷(take a break)指的並不是回電子郵件、去看個電視，這樣並不是中斷(break)。而是真正的中斷，讓你的大腦可以真正的做白日夢(really wander)。而我們每個人都有自己的方式可以開始白日夢模式。這個方式也許是，運動、在自然中散步… 像是快思慢想的作者，每天的下午都會找一段時間在史丹佛校園中散步，據他所說大部分的好想法都是那段時間產生的，這不是巧合，這是一個恢復的行為。</p>\n<p>根據研究，那些一週工作六十小時的人的產出只有比一週工作四十小時的人的產出多七個小時。想一想是不是值得多花二十小時得到多七個小時的產出。</p>\n<p>所以我們該怎麼辦，怎麼專注的做事情？一件專家會做的事是「強迫有生產力的時間」(enforce productivity hours)。他們會在一天中找一段時間，讓那段時間完全不會被中斷、打擾，關掉電子郵件軟體、甚至關掉手機。讓他們能進入全神貫注的狀態。如果你無法關掉電子郵件軟體，因為可能會有突發狀況進來，那試著開一個私下的帳號，告訴其他人有緊急的事才用這個郵件位置。不緊急的事請，送到那個公開不常開的帳號。 很多成功的執行長、藝術家都這樣的切分人生的時間，一次只做好一件事。</p>\n<p>接下來我將切換到談，大腦延伸器(Brain extender)。這是一個簡單的想法。如果你想要有生產力，不要把不需要的東西放進大腦裡。像是聽到明天會下雨，與其在腦袋記著說要帶傘、要帶傘，還不如把這個資訊放到環境裡面去，像是把傘從櫃子拿出來放到門邊，然後它就會在你出門時提醒你。另一個例子是設計心理學中門的例子，為什麼人要記得門要推開還是拉開，直接用設計隱藏預設用途就好(拉的話放門把)，像是廁所的門。另一個方式外部化是我們把事情寫下來。而把事情寫下來，其實比打字下來更適合，因爲寫字時的引發的神經活動是不同的，大腦會更深入的去處理這個資訊。最後一個例子是 Google，我們不用記得細節，只要記得關鍵字，就可以找到我們要的資訊。</p>\n<p>最後我想說的是決策(Decision Making)，我們現在擁有的資訊，能讓我們做出以前不能做出的決策。特別是在醫學上資訊的過載，而醫生並沒有受過大量資訊決策的訓練，像是取得和分析。我覺得我們的教育應該要開始改變，要教導資訊處理(information literacy)，而不是之前教育的大量事實。教導他們要如何有創意的使用這些事實來幫助他們去解決真實世界中的問題。判斷資訊到底是否可信。舉例了醫生決策有多複雜，因為每種藥都有有效率、多種副作用的成功率。我覺得像這種判斷應該從八歲開始教。<br>——<br>29:30 開始 Q&amp;A。</p>\n<p>做決策的時候先把事項排優先順序，在狀態好的時候把大事情處理完。</p>\n<p>注意力缺失症？他們的白日夢模式很強，也就是說他們創意很強，但沒法做不完事情，也許他們可以和其他過度專注的人合作，會很成功。</p>\n<p>Motor learning怎樣會有效率？光只是重複性的運動並不是很有效，你必須有意識地、有目的的做那件事。音樂家叫這個故意練習(deliberately practice)。鋼琴家想像練習時不光只有想像手指怎麼動，還要思考音符的意義…. blah blah practice mindfully. </p>\n<p>夜晚六到十小時的睡眠，會經過一個記憶鞏固(memory consolidation)的過程，神經元會重新重現、處理白天有過的神經活動，然後想辦法讓它進入長期記憶、連結、 儲存他們。如果你白天很努力的工作四到五個小時，取得很多的資訊。這時候小睡一下，大腦會進入睡眠階段，開啟了神經元重啟的按鈕，讓某些迴路變的放鬆，你會預先處理一些資訊讓晚上再做後續處理。</p>\n"},{"title":"如何讓程式可維護 / 重構的方向 / 程式開發中的互動設計","date":"2016-03-04T09:55:00.000Z","_content":"\n# 要解決的問題：\n- 當要程式中增加功能、解決 bug 時，能：\n  * 有概念知道「要修改的地方們」在哪\n  * 能快速切換到「要修改的地方們」\n  * 能在「要修改的地方們」之間快速切換\n  *「修改的地方們」很容易修改\n  * 「修改的地方們」不多\n\n- 當程式要重構時，能：\n   * 測試重構後，外部行為是否一樣\n   * 輕易搬移搬動程式、不產生 bug\n\n# 解法：\n把程式切成小區塊，每個區塊只負責單一功能，幫這些區塊建立資訊架構，架構中設計狀態的流程管理。對應工作內容規劃工作環境。用多次微重構，代替大改。先重構、再解 bug、最後才寫新功能。在多人開發、或經常重構的專案，對穩定的外部 API 建立自動化測試。\n\n# 好習慣：\n\n## <u>把程式切成小區塊 ( ex: 4 - 30 行的小 chunks)</u>\n### 好處：\n* 好理解、好修改、也容易增加新功能、能塞進人腦的工作記憶裡\n\n### \n* 每個程式區塊 = 一個檔案 or 一個 function or 一個 folding\n* 每個區塊行數 (after folding)，大於一個螢幕可以顯示時就要 Refactoring\n\n## <u>每個區塊只負責單一功能</u>\n### 好處：\n* 容易重複利用、減少 dependency、容易理解、容易找到 debug\n\n### 方法：\n* 多寫純函數 / Stateless API、良好函數/模組命名、註解輸入/輸出參數\n## <u>建立程式碼的資訊架構</u>\n### 好處：\n* 容易找到要修改的地方 (在人很有限的 short-term memory 消散之前)\n\n### 方法：\n#### 把程式碼區塊分類\n* 依功能：模組 / MVC / 前後端 / 測試 / Layout or 細節 / Stable or Develop / Web or iOS or Android\n* 依架構：樹狀主從架構 / 分階層 / Data Layer / Rendering Layer\n* 依時間：version\n\n## <u>在架構設計中使用流程管理</u>\n### 好處：\n* 增加可預測性、減少程式碼依賴\n### 方法：\n* 單向資料流、State Machine、Single Source of Truth\n\n## <u>對應的工作內容建立環境</u>\n### 好處：\n* 在程式碼區塊 / 外在環境中移動時，大腦不會 context switch\n\n* Web 互動環境設計：\n  ```\n      1. 要規劃在下列環境簡單移動的方法 (環境一樣要有架構、資訊權重)\n            a. editor & browsers\n            b. shell / server / database / git\n            c. editor 中的不同檔案\n            d. 同個檔案中的 區塊、行、字母\n            e. MDN / stack overflow / Google Search / Github Search\n      2. IDE / shortcut switch / 多螢幕環境 / 切割螢幕畫面\n      3. Font / Syntax Highlight / AutoComplete / 文法檢查\n  ```\n\n## <u>Micro-Refactoring</u> ###\n### 好處：\n* 一次改一點比較好測試、失敗的損失也比較低\n## <u>改程式碼的優先順序：重構 > 修 bug > 增加功能</u>\n### 好處：\n* 重構會讓修 bug 變簡單、修完 bug 會讓增加新功能變得簡單\n## <u>為不常改變行為的外部 API 建立自動化測試</u>\n### 好處：\n* 每次重構時能夠確定沒有破壞這些 API\n\n---\nSimplicity is the prerequisite for reliability — by Dijkstra.<space><space>\n因為我們是人類，只有相當有限的注意力、短期記憶和工作記憶空間。\n","source":"_posts/如何讓程式可維護-重構的方向-程式開發中的互動設計.md","raw":"---\ntitle: 如何讓程式可維護 / 重構的方向 / 程式開發中的互動設計\ntags:\n  - coding\n  - interaction design\n  - refactoring\n  - separation of concerns\ndate: 2016-03-04 17:55:00\n---\n\n# 要解決的問題：\n- 當要程式中增加功能、解決 bug 時，能：\n  * 有概念知道「要修改的地方們」在哪\n  * 能快速切換到「要修改的地方們」\n  * 能在「要修改的地方們」之間快速切換\n  *「修改的地方們」很容易修改\n  * 「修改的地方們」不多\n\n- 當程式要重構時，能：\n   * 測試重構後，外部行為是否一樣\n   * 輕易搬移搬動程式、不產生 bug\n\n# 解法：\n把程式切成小區塊，每個區塊只負責單一功能，幫這些區塊建立資訊架構，架構中設計狀態的流程管理。對應工作內容規劃工作環境。用多次微重構，代替大改。先重構、再解 bug、最後才寫新功能。在多人開發、或經常重構的專案，對穩定的外部 API 建立自動化測試。\n\n# 好習慣：\n\n## <u>把程式切成小區塊 ( ex: 4 - 30 行的小 chunks)</u>\n### 好處：\n* 好理解、好修改、也容易增加新功能、能塞進人腦的工作記憶裡\n\n### \n* 每個程式區塊 = 一個檔案 or 一個 function or 一個 folding\n* 每個區塊行數 (after folding)，大於一個螢幕可以顯示時就要 Refactoring\n\n## <u>每個區塊只負責單一功能</u>\n### 好處：\n* 容易重複利用、減少 dependency、容易理解、容易找到 debug\n\n### 方法：\n* 多寫純函數 / Stateless API、良好函數/模組命名、註解輸入/輸出參數\n## <u>建立程式碼的資訊架構</u>\n### 好處：\n* 容易找到要修改的地方 (在人很有限的 short-term memory 消散之前)\n\n### 方法：\n#### 把程式碼區塊分類\n* 依功能：模組 / MVC / 前後端 / 測試 / Layout or 細節 / Stable or Develop / Web or iOS or Android\n* 依架構：樹狀主從架構 / 分階層 / Data Layer / Rendering Layer\n* 依時間：version\n\n## <u>在架構設計中使用流程管理</u>\n### 好處：\n* 增加可預測性、減少程式碼依賴\n### 方法：\n* 單向資料流、State Machine、Single Source of Truth\n\n## <u>對應的工作內容建立環境</u>\n### 好處：\n* 在程式碼區塊 / 外在環境中移動時，大腦不會 context switch\n\n* Web 互動環境設計：\n  ```\n      1. 要規劃在下列環境簡單移動的方法 (環境一樣要有架構、資訊權重)\n            a. editor & browsers\n            b. shell / server / database / git\n            c. editor 中的不同檔案\n            d. 同個檔案中的 區塊、行、字母\n            e. MDN / stack overflow / Google Search / Github Search\n      2. IDE / shortcut switch / 多螢幕環境 / 切割螢幕畫面\n      3. Font / Syntax Highlight / AutoComplete / 文法檢查\n  ```\n\n## <u>Micro-Refactoring</u> ###\n### 好處：\n* 一次改一點比較好測試、失敗的損失也比較低\n## <u>改程式碼的優先順序：重構 > 修 bug > 增加功能</u>\n### 好處：\n* 重構會讓修 bug 變簡單、修完 bug 會讓增加新功能變得簡單\n## <u>為不常改變行為的外部 API 建立自動化測試</u>\n### 好處：\n* 每次重構時能夠確定沒有破壞這些 API\n\n---\nSimplicity is the prerequisite for reliability — by Dijkstra.<space><space>\n因為我們是人類，只有相當有限的注意力、短期記憶和工作記憶空間。\n","slug":"如何讓程式可維護-重構的方向-程式開發中的互動設計","published":1,"updated":"2017-12-25T02:19:53.077Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjblkzcln000wxq9ksjve1qxq","content":"<h1 id=\"要解決的問題：\"><a href=\"#要解決的問題：\" class=\"headerlink\" title=\"要解決的問題：\"></a>要解決的問題：</h1><ul>\n<li><p>當要程式中增加功能、解決 bug 時，能：</p>\n<ul>\n<li>有概念知道「要修改的地方們」在哪</li>\n<li>能快速切換到「要修改的地方們」</li>\n<li>能在「要修改的地方們」之間快速切換<br>*「修改的地方們」很容易修改</li>\n<li>「修改的地方們」不多</li>\n</ul>\n</li>\n<li><p>當程式要重構時，能：</p>\n<ul>\n<li>測試重構後，外部行為是否一樣</li>\n<li>輕易搬移搬動程式、不產生 bug</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"解法：\"><a href=\"#解法：\" class=\"headerlink\" title=\"解法：\"></a>解法：</h1><p>把程式切成小區塊，每個區塊只負責單一功能，幫這些區塊建立資訊架構，架構中設計狀態的流程管理。對應工作內容規劃工作環境。用多次微重構，代替大改。先重構、再解 bug、最後才寫新功能。在多人開發、或經常重構的專案，對穩定的外部 API 建立自動化測試。</p>\n<h1 id=\"好習慣：\"><a href=\"#好習慣：\" class=\"headerlink\" title=\"好習慣：\"></a>好習慣：</h1><h2 id=\"把程式切成小區塊-ex-4-30-行的小-chunks\"><a href=\"#把程式切成小區塊-ex-4-30-行的小-chunks\" class=\"headerlink\" title=\"把程式切成小區塊 ( ex: 4 - 30 行的小 chunks)\"></a><u>把程式切成小區塊 ( ex: 4 - 30 行的小 chunks)</u></h2><h3 id=\"好處：\"><a href=\"#好處：\" class=\"headerlink\" title=\"好處：\"></a>好處：</h3><ul>\n<li>好理解、好修改、也容易增加新功能、能塞進人腦的工作記憶裡</li>\n</ul>\n<p>### </p>\n<ul>\n<li>每個程式區塊 = 一個檔案 or 一個 function or 一個 folding</li>\n<li>每個區塊行數 (after folding)，大於一個螢幕可以顯示時就要 Refactoring</li>\n</ul>\n<h2 id=\"每個區塊只負責單一功能\"><a href=\"#每個區塊只負責單一功能\" class=\"headerlink\" title=\"每個區塊只負責單一功能\"></a><u>每個區塊只負責單一功能</u></h2><h3 id=\"好處：-1\"><a href=\"#好處：-1\" class=\"headerlink\" title=\"好處：\"></a>好處：</h3><ul>\n<li>容易重複利用、減少 dependency、容易理解、容易找到 debug</li>\n</ul>\n<h3 id=\"方法：\"><a href=\"#方法：\" class=\"headerlink\" title=\"方法：\"></a>方法：</h3><ul>\n<li>多寫純函數 / Stateless API、良好函數/模組命名、註解輸入/輸出參數<h2 id=\"建立程式碼的資訊架構\"><a href=\"#建立程式碼的資訊架構\" class=\"headerlink\" title=\"建立程式碼的資訊架構\"></a><u>建立程式碼的資訊架構</u></h2><h3 id=\"好處：-2\"><a href=\"#好處：-2\" class=\"headerlink\" title=\"好處：\"></a>好處：</h3></li>\n<li>容易找到要修改的地方 (在人很有限的 short-term memory 消散之前)</li>\n</ul>\n<h3 id=\"方法：-1\"><a href=\"#方法：-1\" class=\"headerlink\" title=\"方法：\"></a>方法：</h3><h4 id=\"把程式碼區塊分類\"><a href=\"#把程式碼區塊分類\" class=\"headerlink\" title=\"把程式碼區塊分類\"></a>把程式碼區塊分類</h4><ul>\n<li>依功能：模組 / MVC / 前後端 / 測試 / Layout or 細節 / Stable or Develop / Web or iOS or Android</li>\n<li>依架構：樹狀主從架構 / 分階層 / Data Layer / Rendering Layer</li>\n<li>依時間：version</li>\n</ul>\n<h2 id=\"在架構設計中使用流程管理\"><a href=\"#在架構設計中使用流程管理\" class=\"headerlink\" title=\"在架構設計中使用流程管理\"></a><u>在架構設計中使用流程管理</u></h2><h3 id=\"好處：-3\"><a href=\"#好處：-3\" class=\"headerlink\" title=\"好處：\"></a>好處：</h3><ul>\n<li>增加可預測性、減少程式碼依賴<h3 id=\"方法：-2\"><a href=\"#方法：-2\" class=\"headerlink\" title=\"方法：\"></a>方法：</h3></li>\n<li>單向資料流、State Machine、Single Source of Truth</li>\n</ul>\n<h2 id=\"對應的工作內容建立環境\"><a href=\"#對應的工作內容建立環境\" class=\"headerlink\" title=\"對應的工作內容建立環境\"></a><u>對應的工作內容建立環境</u></h2><h3 id=\"好處：-4\"><a href=\"#好處：-4\" class=\"headerlink\" title=\"好處：\"></a>好處：</h3><ul>\n<li><p>在程式碼區塊 / 外在環境中移動時，大腦不會 context switch</p>\n</li>\n<li><p>Web 互動環境設計：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 要規劃在下列環境簡單移動的方法 (環境一樣要有架構、資訊權重)</span><br><span class=\"line\">      a. editor &amp; browsers</span><br><span class=\"line\">      b. shell / server / database / git</span><br><span class=\"line\">      c. editor 中的不同檔案</span><br><span class=\"line\">      d. 同個檔案中的 區塊、行、字母</span><br><span class=\"line\">      e. MDN / stack overflow / Google Search / Github Search</span><br><span class=\"line\">2. IDE / shortcut switch / 多螢幕環境 / 切割螢幕畫面</span><br><span class=\"line\">3. Font / Syntax Highlight / AutoComplete / 文法檢查</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"Micro-Refactoring\"><a href=\"#Micro-Refactoring\" class=\"headerlink\" title=\"Micro-Refactoring\"></a><u>Micro-Refactoring</u></h2><h3 id=\"好處：-5\"><a href=\"#好處：-5\" class=\"headerlink\" title=\"好處：\"></a>好處：</h3><ul>\n<li>一次改一點比較好測試、失敗的損失也比較低<h2 id=\"改程式碼的優先順序：重構-gt-修-bug-gt-增加功能\"><a href=\"#改程式碼的優先順序：重構-gt-修-bug-gt-增加功能\" class=\"headerlink\" title=\"改程式碼的優先順序：重構 &gt; 修 bug &gt; 增加功能\"></a><u>改程式碼的優先順序：重構 &gt; 修 bug &gt; 增加功能</u></h2><h3 id=\"好處：-6\"><a href=\"#好處：-6\" class=\"headerlink\" title=\"好處：\"></a>好處：</h3></li>\n<li>重構會讓修 bug 變簡單、修完 bug 會讓增加新功能變得簡單<h2 id=\"為不常改變行為的外部-API-建立自動化測試\"><a href=\"#為不常改變行為的外部-API-建立自動化測試\" class=\"headerlink\" title=\"為不常改變行為的外部 API 建立自動化測試\"></a><u>為不常改變行為的外部 API 建立自動化測試</u></h2><h3 id=\"好處：-7\"><a href=\"#好處：-7\" class=\"headerlink\" title=\"好處：\"></a>好處：</h3></li>\n<li>每次重構時能夠確定沒有破壞這些 API</li>\n</ul>\n<hr>\n<p>Simplicity is the prerequisite for reliability — by Dijkstra.<space><space><br>因為我們是人類，只有相當有限的注意力、短期記憶和工作記憶空間。</space></space></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"要解決的問題：\"><a href=\"#要解決的問題：\" class=\"headerlink\" title=\"要解決的問題：\"></a>要解決的問題：</h1><ul>\n<li><p>當要程式中增加功能、解決 bug 時，能：</p>\n<ul>\n<li>有概念知道「要修改的地方們」在哪</li>\n<li>能快速切換到「要修改的地方們」</li>\n<li>能在「要修改的地方們」之間快速切換<br>*「修改的地方們」很容易修改</li>\n<li>「修改的地方們」不多</li>\n</ul>\n</li>\n<li><p>當程式要重構時，能：</p>\n<ul>\n<li>測試重構後，外部行為是否一樣</li>\n<li>輕易搬移搬動程式、不產生 bug</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"解法：\"><a href=\"#解法：\" class=\"headerlink\" title=\"解法：\"></a>解法：</h1><p>把程式切成小區塊，每個區塊只負責單一功能，幫這些區塊建立資訊架構，架構中設計狀態的流程管理。對應工作內容規劃工作環境。用多次微重構，代替大改。先重構、再解 bug、最後才寫新功能。在多人開發、或經常重構的專案，對穩定的外部 API 建立自動化測試。</p>\n<h1 id=\"好習慣：\"><a href=\"#好習慣：\" class=\"headerlink\" title=\"好習慣：\"></a>好習慣：</h1><h2 id=\"把程式切成小區塊-ex-4-30-行的小-chunks\"><a href=\"#把程式切成小區塊-ex-4-30-行的小-chunks\" class=\"headerlink\" title=\"把程式切成小區塊 ( ex: 4 - 30 行的小 chunks)\"></a><u>把程式切成小區塊 ( ex: 4 - 30 行的小 chunks)</u></h2><h3 id=\"好處：\"><a href=\"#好處：\" class=\"headerlink\" title=\"好處：\"></a>好處：</h3><ul>\n<li>好理解、好修改、也容易增加新功能、能塞進人腦的工作記憶裡</li>\n</ul>\n<p>### </p>\n<ul>\n<li>每個程式區塊 = 一個檔案 or 一個 function or 一個 folding</li>\n<li>每個區塊行數 (after folding)，大於一個螢幕可以顯示時就要 Refactoring</li>\n</ul>\n<h2 id=\"每個區塊只負責單一功能\"><a href=\"#每個區塊只負責單一功能\" class=\"headerlink\" title=\"每個區塊只負責單一功能\"></a><u>每個區塊只負責單一功能</u></h2><h3 id=\"好處：-1\"><a href=\"#好處：-1\" class=\"headerlink\" title=\"好處：\"></a>好處：</h3><ul>\n<li>容易重複利用、減少 dependency、容易理解、容易找到 debug</li>\n</ul>\n<h3 id=\"方法：\"><a href=\"#方法：\" class=\"headerlink\" title=\"方法：\"></a>方法：</h3><ul>\n<li>多寫純函數 / Stateless API、良好函數/模組命名、註解輸入/輸出參數<h2 id=\"建立程式碼的資訊架構\"><a href=\"#建立程式碼的資訊架構\" class=\"headerlink\" title=\"建立程式碼的資訊架構\"></a><u>建立程式碼的資訊架構</u></h2><h3 id=\"好處：-2\"><a href=\"#好處：-2\" class=\"headerlink\" title=\"好處：\"></a>好處：</h3></li>\n<li>容易找到要修改的地方 (在人很有限的 short-term memory 消散之前)</li>\n</ul>\n<h3 id=\"方法：-1\"><a href=\"#方法：-1\" class=\"headerlink\" title=\"方法：\"></a>方法：</h3><h4 id=\"把程式碼區塊分類\"><a href=\"#把程式碼區塊分類\" class=\"headerlink\" title=\"把程式碼區塊分類\"></a>把程式碼區塊分類</h4><ul>\n<li>依功能：模組 / MVC / 前後端 / 測試 / Layout or 細節 / Stable or Develop / Web or iOS or Android</li>\n<li>依架構：樹狀主從架構 / 分階層 / Data Layer / Rendering Layer</li>\n<li>依時間：version</li>\n</ul>\n<h2 id=\"在架構設計中使用流程管理\"><a href=\"#在架構設計中使用流程管理\" class=\"headerlink\" title=\"在架構設計中使用流程管理\"></a><u>在架構設計中使用流程管理</u></h2><h3 id=\"好處：-3\"><a href=\"#好處：-3\" class=\"headerlink\" title=\"好處：\"></a>好處：</h3><ul>\n<li>增加可預測性、減少程式碼依賴<h3 id=\"方法：-2\"><a href=\"#方法：-2\" class=\"headerlink\" title=\"方法：\"></a>方法：</h3></li>\n<li>單向資料流、State Machine、Single Source of Truth</li>\n</ul>\n<h2 id=\"對應的工作內容建立環境\"><a href=\"#對應的工作內容建立環境\" class=\"headerlink\" title=\"對應的工作內容建立環境\"></a><u>對應的工作內容建立環境</u></h2><h3 id=\"好處：-4\"><a href=\"#好處：-4\" class=\"headerlink\" title=\"好處：\"></a>好處：</h3><ul>\n<li><p>在程式碼區塊 / 外在環境中移動時，大腦不會 context switch</p>\n</li>\n<li><p>Web 互動環境設計：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 要規劃在下列環境簡單移動的方法 (環境一樣要有架構、資訊權重)</span><br><span class=\"line\">      a. editor &amp; browsers</span><br><span class=\"line\">      b. shell / server / database / git</span><br><span class=\"line\">      c. editor 中的不同檔案</span><br><span class=\"line\">      d. 同個檔案中的 區塊、行、字母</span><br><span class=\"line\">      e. MDN / stack overflow / Google Search / Github Search</span><br><span class=\"line\">2. IDE / shortcut switch / 多螢幕環境 / 切割螢幕畫面</span><br><span class=\"line\">3. Font / Syntax Highlight / AutoComplete / 文法檢查</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"Micro-Refactoring\"><a href=\"#Micro-Refactoring\" class=\"headerlink\" title=\"Micro-Refactoring\"></a><u>Micro-Refactoring</u></h2><h3 id=\"好處：-5\"><a href=\"#好處：-5\" class=\"headerlink\" title=\"好處：\"></a>好處：</h3><ul>\n<li>一次改一點比較好測試、失敗的損失也比較低<h2 id=\"改程式碼的優先順序：重構-gt-修-bug-gt-增加功能\"><a href=\"#改程式碼的優先順序：重構-gt-修-bug-gt-增加功能\" class=\"headerlink\" title=\"改程式碼的優先順序：重構 &gt; 修 bug &gt; 增加功能\"></a><u>改程式碼的優先順序：重構 &gt; 修 bug &gt; 增加功能</u></h2><h3 id=\"好處：-6\"><a href=\"#好處：-6\" class=\"headerlink\" title=\"好處：\"></a>好處：</h3></li>\n<li>重構會讓修 bug 變簡單、修完 bug 會讓增加新功能變得簡單<h2 id=\"為不常改變行為的外部-API-建立自動化測試\"><a href=\"#為不常改變行為的外部-API-建立自動化測試\" class=\"headerlink\" title=\"為不常改變行為的外部 API 建立自動化測試\"></a><u>為不常改變行為的外部 API 建立自動化測試</u></h2><h3 id=\"好處：-7\"><a href=\"#好處：-7\" class=\"headerlink\" title=\"好處：\"></a>好處：</h3></li>\n<li>每次重構時能夠確定沒有破壞這些 API</li>\n</ul>\n<hr>\n<p>Simplicity is the prerequisite for reliability — by Dijkstra.<space><space><br>因為我們是人類，只有相當有限的注意力、短期記憶和工作記憶空間。</space></space></p>\n"},{"title":"淺談函數式編程和 React","date":"2016-01-29T08:08:00.000Z","_content":"\n函數是有定義介面的運算單元。<space><space><space><space>\n\n介面有用的地方是抽象化，你只需要知道輸入什麼(Input)、會得到什麼輸出(Output)，你不用知道它細節是怎麼做到的。其實有個超能力在背後，也沒關係。當然這是在沒有碰到 bug 和有良好文件、不需要修改它的前提之下。<space><space><space><space>\n\n再強調一次，你只需要理解輸入(input)會對應到什麼輸出(output)就夠了。<space><space>\n\n### <u>問題來了，怎樣的輸入和輸出的對應「介面」會容易讓人理解？</u>\n\n- 有意義的函數名稱\n- 多寫沒有副作用的純函數\n  - 有可預測性：\n       每次輸入得到相同的輸出、函數內部不存狀態    \n  - 沒有副作用：\n       運算過程中不會改到外界的變數，像是不改傳進來的參數、不改可以存取的全域變數。    \n  - 顯式(Explict)：\n       函數和外界溝通的管道只有，傳進來的參數和回傳值。\n\n- 簡化參數、對資料結構的 Information Architecture 做良好設計\n\n- 用函數來定義函數\n  - 柯里化(Currying)：\n       透過不同給參數來產生新的函數\n  - 合成(Compose)：\n       透過 pipeline 串接函數的input和output、隱藏參數，產生新的函數。\n\n### <u>函數式編程為什麼強大、有彈性？</u>\n\n- 把每個函數切得很小，容易更新、維護、平行處理、多人共同開發、被理解\n\n- 透過合成(Compose)把小函數變成大函數，比用繼承有彈性的多\n\n- 對集合實做 Functor 介面，讓一般函數都可以對集合操作。(array, matrix, tensor)\n\n- 把純和不純的函數分開來管理，容易找到問題點。\n\n### <u>函數式編程為什麼難寫？</u>\n\n因為函數式編程想要把程式變簡單。但大家都知道「變複雜是簡單的、變簡單是複雜的」。所以這種方式寫程式需要設計、思考，你會是一個程式「設計師」。但如果你現在的專案寫完之後沒人會看、不會再改、不用維護、規模不大，也許函數式編程並不能幫到這個專案多少。\n\n### <u>寫 React 就是實踐函數式編程</u>\n\n- 透過自定義元件，定義畫 View 的抽象化函數樹\n\n- 透過 JSX 語法把小函數組合成大的函數 (等同於 compose)\n\n- 鼓勵大家寫 dumb 元件、也就是純函數\n\n- 用唯讀的 props，限制大家不能改傳進來的參數、減少副作用\n\n- 透過導入 flux，把純和不純的函數分開來管理\n  - 純的 (對資料只做讀的動作)：每個元件中的 render function\n  - 不純的 (對資料做讀和寫的動作)：\n       flux中對 action 的 callback、redux 中的 reducer、父元件傳給子元件的 callback\n  - glue code：元件中其他的 javascript\n![](http://2.bp.blogspot.com/-wg5mnU0UosE/VqsbPjd6AfI/AAAAAAAA4Ak/FN1MAFQndCY/s640/unnamed.jpg)\n\n### <u>從函數式編程的角度看 React 的問題？</u>\n\n- 沒有什麼高階的集合操作方法：\n  - 把 lodash.js 集合操作拉進來用？\n  - 用 lenses 的方式來穿透深長不露的 states?\n\n- 沒有簡單的 currying 語法\n  - 像是傳不同參數給 html5 input 元件，生出各式各樣對數字的、email、submit、text的自定義元件。最簡單寫法應該是 \n  - export function NumberInput(props) { 角括弧input type=“number” {…props} /> }\n  - PS: function 一定要有名字不然 debug 會很慘。\n\n- 雖然集中管理了不純的函數，但還是很難寫：現在透過修改 store 中的 state 來控制元件，這邊 action 觸發的都是不純的函數，如果元件架構一深，還是會很難改。有解嗎？這邊還沒找到什麼 coding guideline…\n  - 多個 container smart 元件\n  - flux 的多個 store\n  - redux 的階層式 reducers\n\n-----------\n延伸閱讀：\n[deku: functional alternative to react ](https://segment.com/blog/deku-our-functional-alternative-to-react/)\n[how to use classes and sleep at night (in a functional way)](https://medium.com/@dan_abramov/how-to-use-classes-and-sleep-at-night-9af8de78ccb4#.jkarowg5n)\n","source":"_posts/淺談函數式編程和-React.md","raw":"---\ntitle: 淺談函數式編程和 React\ntags:\n  - functional programming\n  - react\ndate: 2016-01-29 16:08:00\n---\n\n函數是有定義介面的運算單元。<space><space><space><space>\n\n介面有用的地方是抽象化，你只需要知道輸入什麼(Input)、會得到什麼輸出(Output)，你不用知道它細節是怎麼做到的。其實有個超能力在背後，也沒關係。當然這是在沒有碰到 bug 和有良好文件、不需要修改它的前提之下。<space><space><space><space>\n\n再強調一次，你只需要理解輸入(input)會對應到什麼輸出(output)就夠了。<space><space>\n\n### <u>問題來了，怎樣的輸入和輸出的對應「介面」會容易讓人理解？</u>\n\n- 有意義的函數名稱\n- 多寫沒有副作用的純函數\n  - 有可預測性：\n       每次輸入得到相同的輸出、函數內部不存狀態    \n  - 沒有副作用：\n       運算過程中不會改到外界的變數，像是不改傳進來的參數、不改可以存取的全域變數。    \n  - 顯式(Explict)：\n       函數和外界溝通的管道只有，傳進來的參數和回傳值。\n\n- 簡化參數、對資料結構的 Information Architecture 做良好設計\n\n- 用函數來定義函數\n  - 柯里化(Currying)：\n       透過不同給參數來產生新的函數\n  - 合成(Compose)：\n       透過 pipeline 串接函數的input和output、隱藏參數，產生新的函數。\n\n### <u>函數式編程為什麼強大、有彈性？</u>\n\n- 把每個函數切得很小，容易更新、維護、平行處理、多人共同開發、被理解\n\n- 透過合成(Compose)把小函數變成大函數，比用繼承有彈性的多\n\n- 對集合實做 Functor 介面，讓一般函數都可以對集合操作。(array, matrix, tensor)\n\n- 把純和不純的函數分開來管理，容易找到問題點。\n\n### <u>函數式編程為什麼難寫？</u>\n\n因為函數式編程想要把程式變簡單。但大家都知道「變複雜是簡單的、變簡單是複雜的」。所以這種方式寫程式需要設計、思考，你會是一個程式「設計師」。但如果你現在的專案寫完之後沒人會看、不會再改、不用維護、規模不大，也許函數式編程並不能幫到這個專案多少。\n\n### <u>寫 React 就是實踐函數式編程</u>\n\n- 透過自定義元件，定義畫 View 的抽象化函數樹\n\n- 透過 JSX 語法把小函數組合成大的函數 (等同於 compose)\n\n- 鼓勵大家寫 dumb 元件、也就是純函數\n\n- 用唯讀的 props，限制大家不能改傳進來的參數、減少副作用\n\n- 透過導入 flux，把純和不純的函數分開來管理\n  - 純的 (對資料只做讀的動作)：每個元件中的 render function\n  - 不純的 (對資料做讀和寫的動作)：\n       flux中對 action 的 callback、redux 中的 reducer、父元件傳給子元件的 callback\n  - glue code：元件中其他的 javascript\n![](http://2.bp.blogspot.com/-wg5mnU0UosE/VqsbPjd6AfI/AAAAAAAA4Ak/FN1MAFQndCY/s640/unnamed.jpg)\n\n### <u>從函數式編程的角度看 React 的問題？</u>\n\n- 沒有什麼高階的集合操作方法：\n  - 把 lodash.js 集合操作拉進來用？\n  - 用 lenses 的方式來穿透深長不露的 states?\n\n- 沒有簡單的 currying 語法\n  - 像是傳不同參數給 html5 input 元件，生出各式各樣對數字的、email、submit、text的自定義元件。最簡單寫法應該是 \n  - export function NumberInput(props) { 角括弧input type=“number” {…props} /> }\n  - PS: function 一定要有名字不然 debug 會很慘。\n\n- 雖然集中管理了不純的函數，但還是很難寫：現在透過修改 store 中的 state 來控制元件，這邊 action 觸發的都是不純的函數，如果元件架構一深，還是會很難改。有解嗎？這邊還沒找到什麼 coding guideline…\n  - 多個 container smart 元件\n  - flux 的多個 store\n  - redux 的階層式 reducers\n\n-----------\n延伸閱讀：\n[deku: functional alternative to react ](https://segment.com/blog/deku-our-functional-alternative-to-react/)\n[how to use classes and sleep at night (in a functional way)](https://medium.com/@dan_abramov/how-to-use-classes-and-sleep-at-night-9af8de78ccb4#.jkarowg5n)\n","slug":"淺談函數式編程和-React","published":1,"updated":"2017-12-25T02:19:53.077Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjblkzclq000zxq9kwytp2ryp","content":"<p>函數是有定義介面的運算單元。<space><space><space><space></space></space></space></space></p>\n<p>介面有用的地方是抽象化，你只需要知道輸入什麼(Input)、會得到什麼輸出(Output)，你不用知道它細節是怎麼做到的。其實有個超能力在背後，也沒關係。當然這是在沒有碰到 bug 和有良好文件、不需要修改它的前提之下。<space><space><space><space></space></space></space></space></p>\n<p>再強調一次，你只需要理解輸入(input)會對應到什麼輸出(output)就夠了。<space><space></space></space></p>\n<h3 id=\"問題來了，怎樣的輸入和輸出的對應「介面」會容易讓人理解？\"><a href=\"#問題來了，怎樣的輸入和輸出的對應「介面」會容易讓人理解？\" class=\"headerlink\" title=\"問題來了，怎樣的輸入和輸出的對應「介面」會容易讓人理解？\"></a><u>問題來了，怎樣的輸入和輸出的對應「介面」會容易讓人理解？</u></h3><ul>\n<li>有意義的函數名稱</li>\n<li><p>多寫沒有副作用的純函數</p>\n<ul>\n<li>有可預測性：<br>   每次輸入得到相同的輸出、函數內部不存狀態    </li>\n<li>沒有副作用：<br>   運算過程中不會改到外界的變數，像是不改傳進來的參數、不改可以存取的全域變數。    </li>\n<li>顯式(Explict)：<br>   函數和外界溝通的管道只有，傳進來的參數和回傳值。</li>\n</ul>\n</li>\n<li><p>簡化參數、對資料結構的 Information Architecture 做良好設計</p>\n</li>\n<li><p>用函數來定義函數</p>\n<ul>\n<li>柯里化(Currying)：<br>   透過不同給參數來產生新的函數</li>\n<li>合成(Compose)：<br>   透過 pipeline 串接函數的input和output、隱藏參數，產生新的函數。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"函數式編程為什麼強大、有彈性？\"><a href=\"#函數式編程為什麼強大、有彈性？\" class=\"headerlink\" title=\"函數式編程為什麼強大、有彈性？\"></a><u>函數式編程為什麼強大、有彈性？</u></h3><ul>\n<li><p>把每個函數切得很小，容易更新、維護、平行處理、多人共同開發、被理解</p>\n</li>\n<li><p>透過合成(Compose)把小函數變成大函數，比用繼承有彈性的多</p>\n</li>\n<li><p>對集合實做 Functor 介面，讓一般函數都可以對集合操作。(array, matrix, tensor)</p>\n</li>\n<li><p>把純和不純的函數分開來管理，容易找到問題點。</p>\n</li>\n</ul>\n<h3 id=\"函數式編程為什麼難寫？\"><a href=\"#函數式編程為什麼難寫？\" class=\"headerlink\" title=\"函數式編程為什麼難寫？\"></a><u>函數式編程為什麼難寫？</u></h3><p>因為函數式編程想要把程式變簡單。但大家都知道「變複雜是簡單的、變簡單是複雜的」。所以這種方式寫程式需要設計、思考，你會是一個程式「設計師」。但如果你現在的專案寫完之後沒人會看、不會再改、不用維護、規模不大，也許函數式編程並不能幫到這個專案多少。</p>\n<h3 id=\"寫-React-就是實踐函數式編程\"><a href=\"#寫-React-就是實踐函數式編程\" class=\"headerlink\" title=\"寫 React 就是實踐函數式編程\"></a><u>寫 React 就是實踐函數式編程</u></h3><ul>\n<li><p>透過自定義元件，定義畫 View 的抽象化函數樹</p>\n</li>\n<li><p>透過 JSX 語法把小函數組合成大的函數 (等同於 compose)</p>\n</li>\n<li><p>鼓勵大家寫 dumb 元件、也就是純函數</p>\n</li>\n<li><p>用唯讀的 props，限制大家不能改傳進來的參數、減少副作用</p>\n</li>\n<li><p>透過導入 flux，把純和不純的函數分開來管理</p>\n<ul>\n<li>純的 (對資料只做讀的動作)：每個元件中的 render function</li>\n<li>不純的 (對資料做讀和寫的動作)：<br>   flux中對 action 的 callback、redux 中的 reducer、父元件傳給子元件的 callback</li>\n<li>glue code：元件中其他的 javascript<br><img src=\"http://2.bp.blogspot.com/-wg5mnU0UosE/VqsbPjd6AfI/AAAAAAAA4Ak/FN1MAFQndCY/s640/unnamed.jpg\" alt=\"\"></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"從函數式編程的角度看-React-的問題？\"><a href=\"#從函數式編程的角度看-React-的問題？\" class=\"headerlink\" title=\"從函數式編程的角度看 React 的問題？\"></a><u>從函數式編程的角度看 React 的問題？</u></h3><ul>\n<li><p>沒有什麼高階的集合操作方法：</p>\n<ul>\n<li>把 lodash.js 集合操作拉進來用？</li>\n<li>用 lenses 的方式來穿透深長不露的 states?</li>\n</ul>\n</li>\n<li><p>沒有簡單的 currying 語法</p>\n<ul>\n<li>像是傳不同參數給 html5 input 元件，生出各式各樣對數字的、email、submit、text的自定義元件。最簡單寫法應該是 </li>\n<li>export function NumberInput(props) { 角括弧input type=“number” {…props} /&gt; }</li>\n<li>PS: function 一定要有名字不然 debug 會很慘。</li>\n</ul>\n</li>\n<li><p>雖然集中管理了不純的函數，但還是很難寫：現在透過修改 store 中的 state 來控制元件，這邊 action 觸發的都是不純的函數，如果元件架構一深，還是會很難改。有解嗎？這邊還沒找到什麼 coding guideline…</p>\n<ul>\n<li>多個 container smart 元件</li>\n<li>flux 的多個 store</li>\n<li>redux 的階層式 reducers</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p>延伸閱讀：<br><a href=\"https://segment.com/blog/deku-our-functional-alternative-to-react/\" target=\"_blank\" rel=\"noopener\">deku: functional alternative to react </a><br><a href=\"https://medium.com/@dan_abramov/how-to-use-classes-and-sleep-at-night-9af8de78ccb4#.jkarowg5n\" target=\"_blank\" rel=\"noopener\">how to use classes and sleep at night (in a functional way)</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>函數是有定義介面的運算單元。<space><space><space><space></space></space></space></space></p>\n<p>介面有用的地方是抽象化，你只需要知道輸入什麼(Input)、會得到什麼輸出(Output)，你不用知道它細節是怎麼做到的。其實有個超能力在背後，也沒關係。當然這是在沒有碰到 bug 和有良好文件、不需要修改它的前提之下。<space><space><space><space></space></space></space></space></p>\n<p>再強調一次，你只需要理解輸入(input)會對應到什麼輸出(output)就夠了。<space><space></space></space></p>\n<h3 id=\"問題來了，怎樣的輸入和輸出的對應「介面」會容易讓人理解？\"><a href=\"#問題來了，怎樣的輸入和輸出的對應「介面」會容易讓人理解？\" class=\"headerlink\" title=\"問題來了，怎樣的輸入和輸出的對應「介面」會容易讓人理解？\"></a><u>問題來了，怎樣的輸入和輸出的對應「介面」會容易讓人理解？</u></h3><ul>\n<li>有意義的函數名稱</li>\n<li><p>多寫沒有副作用的純函數</p>\n<ul>\n<li>有可預測性：<br>   每次輸入得到相同的輸出、函數內部不存狀態    </li>\n<li>沒有副作用：<br>   運算過程中不會改到外界的變數，像是不改傳進來的參數、不改可以存取的全域變數。    </li>\n<li>顯式(Explict)：<br>   函數和外界溝通的管道只有，傳進來的參數和回傳值。</li>\n</ul>\n</li>\n<li><p>簡化參數、對資料結構的 Information Architecture 做良好設計</p>\n</li>\n<li><p>用函數來定義函數</p>\n<ul>\n<li>柯里化(Currying)：<br>   透過不同給參數來產生新的函數</li>\n<li>合成(Compose)：<br>   透過 pipeline 串接函數的input和output、隱藏參數，產生新的函數。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"函數式編程為什麼強大、有彈性？\"><a href=\"#函數式編程為什麼強大、有彈性？\" class=\"headerlink\" title=\"函數式編程為什麼強大、有彈性？\"></a><u>函數式編程為什麼強大、有彈性？</u></h3><ul>\n<li><p>把每個函數切得很小，容易更新、維護、平行處理、多人共同開發、被理解</p>\n</li>\n<li><p>透過合成(Compose)把小函數變成大函數，比用繼承有彈性的多</p>\n</li>\n<li><p>對集合實做 Functor 介面，讓一般函數都可以對集合操作。(array, matrix, tensor)</p>\n</li>\n<li><p>把純和不純的函數分開來管理，容易找到問題點。</p>\n</li>\n</ul>\n<h3 id=\"函數式編程為什麼難寫？\"><a href=\"#函數式編程為什麼難寫？\" class=\"headerlink\" title=\"函數式編程為什麼難寫？\"></a><u>函數式編程為什麼難寫？</u></h3><p>因為函數式編程想要把程式變簡單。但大家都知道「變複雜是簡單的、變簡單是複雜的」。所以這種方式寫程式需要設計、思考，你會是一個程式「設計師」。但如果你現在的專案寫完之後沒人會看、不會再改、不用維護、規模不大，也許函數式編程並不能幫到這個專案多少。</p>\n<h3 id=\"寫-React-就是實踐函數式編程\"><a href=\"#寫-React-就是實踐函數式編程\" class=\"headerlink\" title=\"寫 React 就是實踐函數式編程\"></a><u>寫 React 就是實踐函數式編程</u></h3><ul>\n<li><p>透過自定義元件，定義畫 View 的抽象化函數樹</p>\n</li>\n<li><p>透過 JSX 語法把小函數組合成大的函數 (等同於 compose)</p>\n</li>\n<li><p>鼓勵大家寫 dumb 元件、也就是純函數</p>\n</li>\n<li><p>用唯讀的 props，限制大家不能改傳進來的參數、減少副作用</p>\n</li>\n<li><p>透過導入 flux，把純和不純的函數分開來管理</p>\n<ul>\n<li>純的 (對資料只做讀的動作)：每個元件中的 render function</li>\n<li>不純的 (對資料做讀和寫的動作)：<br>   flux中對 action 的 callback、redux 中的 reducer、父元件傳給子元件的 callback</li>\n<li>glue code：元件中其他的 javascript<br><img src=\"http://2.bp.blogspot.com/-wg5mnU0UosE/VqsbPjd6AfI/AAAAAAAA4Ak/FN1MAFQndCY/s640/unnamed.jpg\" alt=\"\"></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"從函數式編程的角度看-React-的問題？\"><a href=\"#從函數式編程的角度看-React-的問題？\" class=\"headerlink\" title=\"從函數式編程的角度看 React 的問題？\"></a><u>從函數式編程的角度看 React 的問題？</u></h3><ul>\n<li><p>沒有什麼高階的集合操作方法：</p>\n<ul>\n<li>把 lodash.js 集合操作拉進來用？</li>\n<li>用 lenses 的方式來穿透深長不露的 states?</li>\n</ul>\n</li>\n<li><p>沒有簡單的 currying 語法</p>\n<ul>\n<li>像是傳不同參數給 html5 input 元件，生出各式各樣對數字的、email、submit、text的自定義元件。最簡單寫法應該是 </li>\n<li>export function NumberInput(props) { 角括弧input type=“number” {…props} /&gt; }</li>\n<li>PS: function 一定要有名字不然 debug 會很慘。</li>\n</ul>\n</li>\n<li><p>雖然集中管理了不純的函數，但還是很難寫：現在透過修改 store 中的 state 來控制元件，這邊 action 觸發的都是不純的函數，如果元件架構一深，還是會很難改。有解嗎？這邊還沒找到什麼 coding guideline…</p>\n<ul>\n<li>多個 container smart 元件</li>\n<li>flux 的多個 store</li>\n<li>redux 的階層式 reducers</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p>延伸閱讀：<br><a href=\"https://segment.com/blog/deku-our-functional-alternative-to-react/\" target=\"_blank\" rel=\"noopener\">deku: functional alternative to react </a><br><a href=\"https://medium.com/@dan_abramov/how-to-use-classes-and-sleep-at-night-9af8de78ccb4#.jkarowg5n\" target=\"_blank\" rel=\"noopener\">how to use classes and sleep at night (in a functional way)</a></p>\n"},{"title":"從買蘋果看工程師和設計師的差別？","date":"2016-02-08T06:04:00.000Z","_content":"\n高中的時候，有個留級的朋友問我，你會不會覺得唸這些東西一點用都沒有。書呆子的我，帶著疑惑問：「為什麼會這樣覺得？」但現在過了 15 年，我真的很想問那時候的我，為什麼不會這樣覺得。\n\n```\n工程和管理的訓練是解決問題，而設計師受的訓練是發現真正的問題。 \n--- from 設計的心理學 by Donald A. Norman\n```\n\n### 聽到「幫我買一顆蘋果」這個問題，工程師會這樣做。\n```\n工程師：花一小時，找出一大堆的購物網站，列出各種蘋果的價格和評價，然後請你挑最好的一個。\n\n妹子：我只是想和你見個面聊個天，為什麼我必須要看那麼多資料... 而且還要我上網訂、見不到面，還是放棄治療好了。\n```\n\n### 聽到「幫我買一顆蘋果」這個問題，設計師會這樣做。(這邊設計師不含 VD)\n```\n情況一：\n問：你為什麼要買蘋果？\n答: 因為想幫房間增加一點紅色。\n問: 為什麼想幫房間增加一點紅色?\n答: 因為想把房間變漂亮？\n解: 設計師把房間的燈從冷色系換成暖色系。\n\n情況二：\n問：你為什麼要買蘋果？\n答：因為我肚子餓。\n問：可是你不是剛剛才吃完飯？\n答：嗯，對喔。(OS: 我只是看你太閒，要給你一點事做。)\n\n情況三：\n問：你為什麼要買蘋果？\n答：因為要吃。\n問：你為什麼要吃？\n答：我每天都要吃一顆，今天沒帶。你廢話那麼多要幹麻？(OS: 這個下屬理由很多。)\n```\n\n工程師和管理把問題往下展開。\n設計師把問題往上展，如果找到更簡單的問題再往下展。\n\n### 工程師：直接把問題往下展開：\n```\n優：能最快速找到這個問題的解法。\n缺：你解決的可能根本不是重要的問題。\n```\n### 設計師：把問題往後回推，找新問題解\n```\n優：也許能找到真正需要解的問題、花更少的時間就能解決問題。\n缺：別人會以為你不想理他在找藉口。老闆會以為你在故意質疑他。如果原來的問題本來就是對的問題，你只是在浪費時間。\n```\n### 理性與感性\n```\n「現階段的實際工作中，設計師們無論是在方案的設計還是方案的表達上，往往都顯得感性有餘、理性不足。」\n--- by 汪方進 ＠ 阿里巴巴 1688用戶體驗部\n```\n\n一個設計師，不光只有同理心、邏輯推理能力、各種知識也很重要。沒有知識不能推理啊... 所以工程師們快和我一樣跳進來吧~~~ 當設計界的理性之光。其實就演算法的角度來看，就是兩種不同的方法，各有各的使用時機、各有各的風險報酬，如果要能解決生活中的問題，這兩個都很重要。所以也別分什麼工程、設計、商業，如果有需要就學吧。大學四年可以學一個專業，但人生有多少個四年啊... 是不是該多學幾個專業 XD\n\n註： 把視覺設計師(VD)和程式設計師特別切出來的原因是：他們的工作都偏向在給定的問題中找解法、做的是實作中一定要做的事。但真正優秀的會去觀察使用者。(工程師的話推薦看：程序員的修煉、駭客與畫家，都有提到這點)\n\n註：上面的對話都是我的想像舉例，別太認真。想知道真正答案的話，或是測試這個人的工程設計傾向，可以請他幫你買顆蘋果看看。\n","source":"_posts/從買蘋果看工程師和設計師的差別？.md","raw":"---\ntitle: 從買蘋果看工程師和設計師的差別？\ntags:\n  - design\n  - design thinking\n  - designer\n  - engineering\ndate: 2016-02-08 14:04:00\n---\n\n高中的時候，有個留級的朋友問我，你會不會覺得唸這些東西一點用都沒有。書呆子的我，帶著疑惑問：「為什麼會這樣覺得？」但現在過了 15 年，我真的很想問那時候的我，為什麼不會這樣覺得。\n\n```\n工程和管理的訓練是解決問題，而設計師受的訓練是發現真正的問題。 \n--- from 設計的心理學 by Donald A. Norman\n```\n\n### 聽到「幫我買一顆蘋果」這個問題，工程師會這樣做。\n```\n工程師：花一小時，找出一大堆的購物網站，列出各種蘋果的價格和評價，然後請你挑最好的一個。\n\n妹子：我只是想和你見個面聊個天，為什麼我必須要看那麼多資料... 而且還要我上網訂、見不到面，還是放棄治療好了。\n```\n\n### 聽到「幫我買一顆蘋果」這個問題，設計師會這樣做。(這邊設計師不含 VD)\n```\n情況一：\n問：你為什麼要買蘋果？\n答: 因為想幫房間增加一點紅色。\n問: 為什麼想幫房間增加一點紅色?\n答: 因為想把房間變漂亮？\n解: 設計師把房間的燈從冷色系換成暖色系。\n\n情況二：\n問：你為什麼要買蘋果？\n答：因為我肚子餓。\n問：可是你不是剛剛才吃完飯？\n答：嗯，對喔。(OS: 我只是看你太閒，要給你一點事做。)\n\n情況三：\n問：你為什麼要買蘋果？\n答：因為要吃。\n問：你為什麼要吃？\n答：我每天都要吃一顆，今天沒帶。你廢話那麼多要幹麻？(OS: 這個下屬理由很多。)\n```\n\n工程師和管理把問題往下展開。\n設計師把問題往上展，如果找到更簡單的問題再往下展。\n\n### 工程師：直接把問題往下展開：\n```\n優：能最快速找到這個問題的解法。\n缺：你解決的可能根本不是重要的問題。\n```\n### 設計師：把問題往後回推，找新問題解\n```\n優：也許能找到真正需要解的問題、花更少的時間就能解決問題。\n缺：別人會以為你不想理他在找藉口。老闆會以為你在故意質疑他。如果原來的問題本來就是對的問題，你只是在浪費時間。\n```\n### 理性與感性\n```\n「現階段的實際工作中，設計師們無論是在方案的設計還是方案的表達上，往往都顯得感性有餘、理性不足。」\n--- by 汪方進 ＠ 阿里巴巴 1688用戶體驗部\n```\n\n一個設計師，不光只有同理心、邏輯推理能力、各種知識也很重要。沒有知識不能推理啊... 所以工程師們快和我一樣跳進來吧~~~ 當設計界的理性之光。其實就演算法的角度來看，就是兩種不同的方法，各有各的使用時機、各有各的風險報酬，如果要能解決生活中的問題，這兩個都很重要。所以也別分什麼工程、設計、商業，如果有需要就學吧。大學四年可以學一個專業，但人生有多少個四年啊... 是不是該多學幾個專業 XD\n\n註： 把視覺設計師(VD)和程式設計師特別切出來的原因是：他們的工作都偏向在給定的問題中找解法、做的是實作中一定要做的事。但真正優秀的會去觀察使用者。(工程師的話推薦看：程序員的修煉、駭客與畫家，都有提到這點)\n\n註：上面的對話都是我的想像舉例，別太認真。想知道真正答案的話，或是測試這個人的工程設計傾向，可以請他幫你買顆蘋果看看。\n","slug":"從買蘋果看工程師和設計師的差別？","published":1,"updated":"2017-12-25T02:19:53.077Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjblkzcls0011xq9k4ndq72qs","content":"<p>高中的時候，有個留級的朋友問我，你會不會覺得唸這些東西一點用都沒有。書呆子的我，帶著疑惑問：「為什麼會這樣覺得？」但現在過了 15 年，我真的很想問那時候的我，為什麼不會這樣覺得。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">工程和管理的訓練是解決問題，而設計師受的訓練是發現真正的問題。 </span><br><span class=\"line\">--- from 設計的心理學 by Donald A. Norman</span><br></pre></td></tr></table></figure>\n<h3 id=\"聽到「幫我買一顆蘋果」這個問題，工程師會這樣做。\"><a href=\"#聽到「幫我買一顆蘋果」這個問題，工程師會這樣做。\" class=\"headerlink\" title=\"聽到「幫我買一顆蘋果」這個問題，工程師會這樣做。\"></a>聽到「幫我買一顆蘋果」這個問題，工程師會這樣做。</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">工程師：花一小時，找出一大堆的購物網站，列出各種蘋果的價格和評價，然後請你挑最好的一個。</span><br><span class=\"line\"></span><br><span class=\"line\">妹子：我只是想和你見個面聊個天，為什麼我必須要看那麼多資料... 而且還要我上網訂、見不到面，還是放棄治療好了。</span><br></pre></td></tr></table></figure>\n<h3 id=\"聽到「幫我買一顆蘋果」這個問題，設計師會這樣做。-這邊設計師不含-VD\"><a href=\"#聽到「幫我買一顆蘋果」這個問題，設計師會這樣做。-這邊設計師不含-VD\" class=\"headerlink\" title=\"聽到「幫我買一顆蘋果」這個問題，設計師會這樣做。(這邊設計師不含 VD)\"></a>聽到「幫我買一顆蘋果」這個問題，設計師會這樣做。(這邊設計師不含 VD)</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">情況一：</span><br><span class=\"line\">問：你為什麼要買蘋果？</span><br><span class=\"line\">答: 因為想幫房間增加一點紅色。</span><br><span class=\"line\">問: 為什麼想幫房間增加一點紅色?</span><br><span class=\"line\">答: 因為想把房間變漂亮？</span><br><span class=\"line\">解: 設計師把房間的燈從冷色系換成暖色系。</span><br><span class=\"line\"></span><br><span class=\"line\">情況二：</span><br><span class=\"line\">問：你為什麼要買蘋果？</span><br><span class=\"line\">答：因為我肚子餓。</span><br><span class=\"line\">問：可是你不是剛剛才吃完飯？</span><br><span class=\"line\">答：嗯，對喔。(OS: 我只是看你太閒，要給你一點事做。)</span><br><span class=\"line\"></span><br><span class=\"line\">情況三：</span><br><span class=\"line\">問：你為什麼要買蘋果？</span><br><span class=\"line\">答：因為要吃。</span><br><span class=\"line\">問：你為什麼要吃？</span><br><span class=\"line\">答：我每天都要吃一顆，今天沒帶。你廢話那麼多要幹麻？(OS: 這個下屬理由很多。)</span><br></pre></td></tr></table></figure>\n<p>工程師和管理把問題往下展開。<br>設計師把問題往上展，如果找到更簡單的問題再往下展。</p>\n<h3 id=\"工程師：直接把問題往下展開：\"><a href=\"#工程師：直接把問題往下展開：\" class=\"headerlink\" title=\"工程師：直接把問題往下展開：\"></a>工程師：直接把問題往下展開：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">優：能最快速找到這個問題的解法。</span><br><span class=\"line\">缺：你解決的可能根本不是重要的問題。</span><br></pre></td></tr></table></figure>\n<h3 id=\"設計師：把問題往後回推，找新問題解\"><a href=\"#設計師：把問題往後回推，找新問題解\" class=\"headerlink\" title=\"設計師：把問題往後回推，找新問題解\"></a>設計師：把問題往後回推，找新問題解</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">優：也許能找到真正需要解的問題、花更少的時間就能解決問題。</span><br><span class=\"line\">缺：別人會以為你不想理他在找藉口。老闆會以為你在故意質疑他。如果原來的問題本來就是對的問題，你只是在浪費時間。</span><br></pre></td></tr></table></figure>\n<h3 id=\"理性與感性\"><a href=\"#理性與感性\" class=\"headerlink\" title=\"理性與感性\"></a>理性與感性</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">「現階段的實際工作中，設計師們無論是在方案的設計還是方案的表達上，往往都顯得感性有餘、理性不足。」</span><br><span class=\"line\">--- by 汪方進 ＠ 阿里巴巴 1688用戶體驗部</span><br></pre></td></tr></table></figure>\n<p>一個設計師，不光只有同理心、邏輯推理能力、各種知識也很重要。沒有知識不能推理啊… 所以工程師們快和我一樣跳進來吧~~~ 當設計界的理性之光。其實就演算法的角度來看，就是兩種不同的方法，各有各的使用時機、各有各的風險報酬，如果要能解決生活中的問題，這兩個都很重要。所以也別分什麼工程、設計、商業，如果有需要就學吧。大學四年可以學一個專業，但人生有多少個四年啊… 是不是該多學幾個專業 XD</p>\n<p>註： 把視覺設計師(VD)和程式設計師特別切出來的原因是：他們的工作都偏向在給定的問題中找解法、做的是實作中一定要做的事。但真正優秀的會去觀察使用者。(工程師的話推薦看：程序員的修煉、駭客與畫家，都有提到這點)</p>\n<p>註：上面的對話都是我的想像舉例，別太認真。想知道真正答案的話，或是測試這個人的工程設計傾向，可以請他幫你買顆蘋果看看。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>高中的時候，有個留級的朋友問我，你會不會覺得唸這些東西一點用都沒有。書呆子的我，帶著疑惑問：「為什麼會這樣覺得？」但現在過了 15 年，我真的很想問那時候的我，為什麼不會這樣覺得。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">工程和管理的訓練是解決問題，而設計師受的訓練是發現真正的問題。 </span><br><span class=\"line\">--- from 設計的心理學 by Donald A. Norman</span><br></pre></td></tr></table></figure>\n<h3 id=\"聽到「幫我買一顆蘋果」這個問題，工程師會這樣做。\"><a href=\"#聽到「幫我買一顆蘋果」這個問題，工程師會這樣做。\" class=\"headerlink\" title=\"聽到「幫我買一顆蘋果」這個問題，工程師會這樣做。\"></a>聽到「幫我買一顆蘋果」這個問題，工程師會這樣做。</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">工程師：花一小時，找出一大堆的購物網站，列出各種蘋果的價格和評價，然後請你挑最好的一個。</span><br><span class=\"line\"></span><br><span class=\"line\">妹子：我只是想和你見個面聊個天，為什麼我必須要看那麼多資料... 而且還要我上網訂、見不到面，還是放棄治療好了。</span><br></pre></td></tr></table></figure>\n<h3 id=\"聽到「幫我買一顆蘋果」這個問題，設計師會這樣做。-這邊設計師不含-VD\"><a href=\"#聽到「幫我買一顆蘋果」這個問題，設計師會這樣做。-這邊設計師不含-VD\" class=\"headerlink\" title=\"聽到「幫我買一顆蘋果」這個問題，設計師會這樣做。(這邊設計師不含 VD)\"></a>聽到「幫我買一顆蘋果」這個問題，設計師會這樣做。(這邊設計師不含 VD)</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">情況一：</span><br><span class=\"line\">問：你為什麼要買蘋果？</span><br><span class=\"line\">答: 因為想幫房間增加一點紅色。</span><br><span class=\"line\">問: 為什麼想幫房間增加一點紅色?</span><br><span class=\"line\">答: 因為想把房間變漂亮？</span><br><span class=\"line\">解: 設計師把房間的燈從冷色系換成暖色系。</span><br><span class=\"line\"></span><br><span class=\"line\">情況二：</span><br><span class=\"line\">問：你為什麼要買蘋果？</span><br><span class=\"line\">答：因為我肚子餓。</span><br><span class=\"line\">問：可是你不是剛剛才吃完飯？</span><br><span class=\"line\">答：嗯，對喔。(OS: 我只是看你太閒，要給你一點事做。)</span><br><span class=\"line\"></span><br><span class=\"line\">情況三：</span><br><span class=\"line\">問：你為什麼要買蘋果？</span><br><span class=\"line\">答：因為要吃。</span><br><span class=\"line\">問：你為什麼要吃？</span><br><span class=\"line\">答：我每天都要吃一顆，今天沒帶。你廢話那麼多要幹麻？(OS: 這個下屬理由很多。)</span><br></pre></td></tr></table></figure>\n<p>工程師和管理把問題往下展開。<br>設計師把問題往上展，如果找到更簡單的問題再往下展。</p>\n<h3 id=\"工程師：直接把問題往下展開：\"><a href=\"#工程師：直接把問題往下展開：\" class=\"headerlink\" title=\"工程師：直接把問題往下展開：\"></a>工程師：直接把問題往下展開：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">優：能最快速找到這個問題的解法。</span><br><span class=\"line\">缺：你解決的可能根本不是重要的問題。</span><br></pre></td></tr></table></figure>\n<h3 id=\"設計師：把問題往後回推，找新問題解\"><a href=\"#設計師：把問題往後回推，找新問題解\" class=\"headerlink\" title=\"設計師：把問題往後回推，找新問題解\"></a>設計師：把問題往後回推，找新問題解</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">優：也許能找到真正需要解的問題、花更少的時間就能解決問題。</span><br><span class=\"line\">缺：別人會以為你不想理他在找藉口。老闆會以為你在故意質疑他。如果原來的問題本來就是對的問題，你只是在浪費時間。</span><br></pre></td></tr></table></figure>\n<h3 id=\"理性與感性\"><a href=\"#理性與感性\" class=\"headerlink\" title=\"理性與感性\"></a>理性與感性</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">「現階段的實際工作中，設計師們無論是在方案的設計還是方案的表達上，往往都顯得感性有餘、理性不足。」</span><br><span class=\"line\">--- by 汪方進 ＠ 阿里巴巴 1688用戶體驗部</span><br></pre></td></tr></table></figure>\n<p>一個設計師，不光只有同理心、邏輯推理能力、各種知識也很重要。沒有知識不能推理啊… 所以工程師們快和我一樣跳進來吧~~~ 當設計界的理性之光。其實就演算法的角度來看，就是兩種不同的方法，各有各的使用時機、各有各的風險報酬，如果要能解決生活中的問題，這兩個都很重要。所以也別分什麼工程、設計、商業，如果有需要就學吧。大學四年可以學一個專業，但人生有多少個四年啊… 是不是該多學幾個專業 XD</p>\n<p>註： 把視覺設計師(VD)和程式設計師特別切出來的原因是：他們的工作都偏向在給定的問題中找解法、做的是實作中一定要做的事。但真正優秀的會去觀察使用者。(工程師的話推薦看：程序員的修煉、駭客與畫家，都有提到這點)</p>\n<p>註：上面的對話都是我的想像舉例，別太認真。想知道真正答案的話，或是測試這個人的工程設計傾向，可以請他幫你買顆蘋果看看。</p>\n"},{"title":"用 Redux 實踐「狀態機導向的介面開發」","date":"2015-11-06T07:44:00.000Z","_content":"\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">BIG WORD ALERT!!!</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">———</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">研究了Redux.js之後，對State Machine有了更深的領悟。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">上個月解了一百多題 LeetCode，深深覺得程式解問題很重要的一點就是，想出一個「資料的表達的方式」讓問題運算過程中的所有「狀態」能夠清楚的表達，之後只要叫電腦從 Initial State 算到 Final State，題目就解完了。這個「資料表達的方式」也許是 stack、也許是 Array 再加上兩個 Pointer、也許是 2D Array表達地圖狀態、或複雜一點的像是 八皇后(N-queens) 問題用四個 array 來表達row, column, 兩個斜線方向有沒有皇后。只要想完「怎麼用資料來清楚表達所有狀態？」這個題目就解一半了，如果是 backtracking / 窮舉的問題的話，那你就已經解完了。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">不過，這個跟 Redux 有什麼關係呢？Redux做為Flux概念的實現，設計中 Store 是唯一的資料儲存中心，它把所有「元件狀態的資料」集中放在一起。</span><span style=\"font-family: '&quot;helvetica neue&quot;', '&quot;arial&quot;', '&quot;helvetica&quot;', sans-serif;\">讓開發者很容易用</span><span style=\"font-family: 'helvetica neue', arial, helvetica, sans-serif;\">抽離 UI 的角度思考，一開始就把應用程式中「0\\. 怎麼用資料來清楚表達所有邏輯狀態？」這個問題給想清楚。這個問題解完了之後，剩下的只有兩件事：</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp;1\\. 收到使用者 Action 或伺服器的更新，要從哪個 state 換到 哪個 state：應用程式的運作邏輯，這部分 Redux 用 Reducer 做掉了。在 Reducer 中你要清楚定義狀態機中的 Transition 也就是 ( previousState, Action ) =&gt; newState 這件事</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp;2\\. 在每個state的時候，應用程式 / 元件要畫成什麼樣子：React 想解的問題</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">0 和 1 兩個步驟常常會平行設計、互相影響，這部分會定義你的產品功能面。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">2 的步驟就是視覺化、資料傳達的部分。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">—</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">總結，從State Machine的角度來開發只要做下面三件事：</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span class=\"Apple-tab-span\" style=\"white-space: pre;\"> </span>1\\. 想好怎麼表達 state。 ( Redux Store )</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span class=\"Apple-tab-span\" style=\"white-space: pre;\"> </span>2\\. 想好有哪些事件，事件會讓 state 間怎麼切換。 ( Redux Reducer )</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span class=\"Apple-tab-span\" style=\"white-space: pre;\"> </span>3\\. 如何把狀態傳達給使用者。 ( React )</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">從此開發就有了 SOP。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">PS: 「資料的表達方式」包含了「資料結構」和裡面結構中資料代表的意義。</span>","source":"_posts/用-Redux-實踐「狀態機導向的介面開發」.md","raw":"---\ntitle: 用 Redux 實踐「狀態機導向的介面開發」\ntags:\n  - redux\n  - state machine\ndate: 2015-11-06 15:44:00\n---\n\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">BIG WORD ALERT!!!</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">———</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">研究了Redux.js之後，對State Machine有了更深的領悟。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">上個月解了一百多題 LeetCode，深深覺得程式解問題很重要的一點就是，想出一個「資料的表達的方式」讓問題運算過程中的所有「狀態」能夠清楚的表達，之後只要叫電腦從 Initial State 算到 Final State，題目就解完了。這個「資料表達的方式」也許是 stack、也許是 Array 再加上兩個 Pointer、也許是 2D Array表達地圖狀態、或複雜一點的像是 八皇后(N-queens) 問題用四個 array 來表達row, column, 兩個斜線方向有沒有皇后。只要想完「怎麼用資料來清楚表達所有狀態？」這個題目就解一半了，如果是 backtracking / 窮舉的問題的話，那你就已經解完了。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">不過，這個跟 Redux 有什麼關係呢？Redux做為Flux概念的實現，設計中 Store 是唯一的資料儲存中心，它把所有「元件狀態的資料」集中放在一起。</span><span style=\"font-family: '&quot;helvetica neue&quot;', '&quot;arial&quot;', '&quot;helvetica&quot;', sans-serif;\">讓開發者很容易用</span><span style=\"font-family: 'helvetica neue', arial, helvetica, sans-serif;\">抽離 UI 的角度思考，一開始就把應用程式中「0\\. 怎麼用資料來清楚表達所有邏輯狀態？」這個問題給想清楚。這個問題解完了之後，剩下的只有兩件事：</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp;1\\. 收到使用者 Action 或伺服器的更新，要從哪個 state 換到 哪個 state：應用程式的運作邏輯，這部分 Redux 用 Reducer 做掉了。在 Reducer 中你要清楚定義狀態機中的 Transition 也就是 ( previousState, Action ) =&gt; newState 這件事</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp;2\\. 在每個state的時候，應用程式 / 元件要畫成什麼樣子：React 想解的問題</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">0 和 1 兩個步驟常常會平行設計、互相影響，這部分會定義你的產品功能面。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">2 的步驟就是視覺化、資料傳達的部分。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">—</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">總結，從State Machine的角度來開發只要做下面三件事：</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span class=\"Apple-tab-span\" style=\"white-space: pre;\"> </span>1\\. 想好怎麼表達 state。 ( Redux Store )</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span class=\"Apple-tab-span\" style=\"white-space: pre;\"> </span>2\\. 想好有哪些事件，事件會讓 state 間怎麼切換。 ( Redux Reducer )</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span class=\"Apple-tab-span\" style=\"white-space: pre;\"> </span>3\\. 如何把狀態傳達給使用者。 ( React )</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">從此開發就有了 SOP。</span>\n<span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">PS: 「資料的表達方式」包含了「資料結構」和裡面結構中資料代表的意義。</span>","slug":"用-Redux-實踐「狀態機導向的介面開發」","published":1,"updated":"2017-12-23T06:08:08.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjblkzclu0014xq9kchu3kvt4","content":"<p><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">BIG WORD ALERT!!!</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">———</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">研究了Redux.js之後，對State Machine有了更深的領悟。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">上個月解了一百多題 LeetCode，深深覺得程式解問題很重要的一點就是，想出一個「資料的表達的方式」讓問題運算過程中的所有「狀態」能夠清楚的表達，之後只要叫電腦從 Initial State 算到 Final State，題目就解完了。這個「資料表達的方式」也許是 stack、也許是 Array 再加上兩個 Pointer、也許是 2D Array表達地圖狀態、或複雜一點的像是 八皇后(N-queens) 問題用四個 array 來表達row, column, 兩個斜線方向有沒有皇后。只要想完「怎麼用資料來清楚表達所有狀態？」這個題目就解一半了，如果是 backtracking / 窮舉的問題的話，那你就已經解完了。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">不過，這個跟 Redux 有什麼關係呢？Redux做為Flux概念的實現，設計中 Store 是唯一的資料儲存中心，它把所有「元件狀態的資料」集中放在一起。</span><span style=\"font-family: '&quot;helvetica neue&quot;', '&quot;arial&quot;', '&quot;helvetica&quot;', sans-serif;\">讓開發者很容易用</span><span style=\"font-family: 'helvetica neue', arial, helvetica, sans-serif;\">抽離 UI 的角度思考，一開始就把應用程式中「0. 怎麼用資料來清楚表達所有邏輯狀態？」這個問題給想清楚。這個問題解完了之後，剩下的只有兩件事：</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp;1. 收到使用者 Action 或伺服器的更新，要從哪個 state 換到 哪個 state：應用程式的運作邏輯，這部分 Redux 用 Reducer 做掉了。在 Reducer 中你要清楚定義狀態機中的 Transition 也就是 ( previousState, Action ) =&gt; newState 這件事</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp;2. 在每個state的時候，應用程式 / 元件要畫成什麼樣子：React 想解的問題</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">0 和 1 兩個步驟常常會平行設計、互相影響，這部分會定義你的產品功能面。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">2 的步驟就是視覺化、資料傳達的部分。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">—</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">總結，從State Machine的角度來開發只要做下面三件事：</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span class=\"Apple-tab-span\" style=\"white-space: pre;\"> </span>1. 想好怎麼表達 state。 ( Redux Store )</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span class=\"Apple-tab-span\" style=\"white-space: pre;\"> </span>2. 想好有哪些事件，事件會讓 state 間怎麼切換。 ( Redux Reducer )</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span class=\"Apple-tab-span\" style=\"white-space: pre;\"> </span>3. 如何把狀態傳達給使用者。 ( React )</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">從此開發就有了 SOP。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">PS: 「資料的表達方式」包含了「資料結構」和裡面結構中資料代表的意義。</span></p>\n","site":{"data":{}},"excerpt":"","more":"<p><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">BIG WORD ALERT!!!</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">———</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">研究了Redux.js之後，對State Machine有了更深的領悟。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">上個月解了一百多題 LeetCode，深深覺得程式解問題很重要的一點就是，想出一個「資料的表達的方式」讓問題運算過程中的所有「狀態」能夠清楚的表達，之後只要叫電腦從 Initial State 算到 Final State，題目就解完了。這個「資料表達的方式」也許是 stack、也許是 Array 再加上兩個 Pointer、也許是 2D Array表達地圖狀態、或複雜一點的像是 八皇后(N-queens) 問題用四個 array 來表達row, column, 兩個斜線方向有沒有皇后。只要想完「怎麼用資料來清楚表達所有狀態？」這個題目就解一半了，如果是 backtracking / 窮舉的問題的話，那你就已經解完了。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">不過，這個跟 Redux 有什麼關係呢？Redux做為Flux概念的實現，設計中 Store 是唯一的資料儲存中心，它把所有「元件狀態的資料」集中放在一起。</span><span style=\"font-family: '&quot;helvetica neue&quot;', '&quot;arial&quot;', '&quot;helvetica&quot;', sans-serif;\">讓開發者很容易用</span><span style=\"font-family: 'helvetica neue', arial, helvetica, sans-serif;\">抽離 UI 的角度思考，一開始就把應用程式中「0. 怎麼用資料來清楚表達所有邏輯狀態？」這個問題給想清楚。這個問題解完了之後，剩下的只有兩件事：</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp;1. 收到使用者 Action 或伺服器的更新，要從哪個 state 換到 哪個 state：應用程式的運作邏輯，這部分 Redux 用 Reducer 做掉了。在 Reducer 中你要清楚定義狀態機中的 Transition 也就是 ( previousState, Action ) =&gt; newState 這件事</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">&nbsp;2. 在每個state的時候，應用程式 / 元件要畫成什麼樣子：React 想解的問題</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">0 和 1 兩個步驟常常會平行設計、互相影響，這部分會定義你的產品功能面。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">2 的步驟就是視覺化、資料傳達的部分。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">—</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">總結，從State Machine的角度來開發只要做下面三件事：</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span class=\"Apple-tab-span\" style=\"white-space: pre;\"> </span>1. 想好怎麼表達 state。 ( Redux Store )</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span class=\"Apple-tab-span\" style=\"white-space: pre;\"> </span>2. 想好有哪些事件，事件會讓 state 間怎麼切換。 ( Redux Reducer )</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><span class=\"Apple-tab-span\" style=\"white-space: pre;\"> </span>3. 如何把狀態傳達給使用者。 ( React )</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">從此開發就有了 SOP。</span><br><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">PS: 「資料的表達方式」包含了「資料結構」和裡面結構中資料代表的意義。</span></p>\n"},{"title":"研究 Node.js 和 Express.js 有感","date":"2015-11-04T07:50:00.000Z","_content":"\n<div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">簡單來說網頁設計，就是設計ㄧ個讓在給了Key 後把相關資料轉換成網頁的 function。</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Node 提供ㄧ個可以用 JS 與其溝通的 non-blocking http server。Express 在上面提供了簡易建立 RESTFUL API、在頁面間 (在 server 上) 傳遞資料的方法。</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">從外部來看，就是一個 JavaScript 程式，然後你對它送一些 Request，他就會吐 http response 回來。</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Http response 包含了資料 ( ex: 文章、作者、照片、標題、按鈕文字 ) 和 UI/排板 ( CSS / HTML / client-side JavaScript )。通常資料是不重複的。但根據不同的資料，UI 很多重複的地方就變成用 UI Template/UI 元件來表示。</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">傳統產生網頁的方式是把資料和 UI 原件混成一個個各別的網頁然後傳給 Browser 畫出來；最近流行的方式是把資料和UI原件分別傳給 Browser，在 client-side browser 再用 JavaScript 把資料和 UI 原件組合成網頁。</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">近年流行的 json 是一顆用 ( key:value or array ) pair建起來的關聯式資料樹。因此後端資料庫不再用關聯式資料庫，用簡單 NoSql 資料庫 ( 即 dictionary ) 就夠了。</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">簡單來說現代的網頁開發就是開發一個程式：從後端抓一顆 json 資料樹，然後轉成前端美美的 DOM Tree。就是模組化的 Data Visualization，這樣想一切都輕鬆多了。</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">這樣的想法很自然的催生了一堆 UI 的程式庫，像是 Angular.js 和 react.js，然後還有 mobile上的 react native。</span></div>","source":"_posts/研究-Node-js-和-Express-js-有感.md","raw":"---\ntitle: 研究 Node.js 和 Express.js 有感\ntags:\n  - backend\n  - express\n  - node\ndate: 2015-11-04 15:50:00\n---\n\n<div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">簡單來說網頁設計，就是設計ㄧ個讓在給了Key 後把相關資料轉換成網頁的 function。</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Node 提供ㄧ個可以用 JS 與其溝通的 non-blocking http server。Express 在上面提供了簡易建立 RESTFUL API、在頁面間 (在 server 上) 傳遞資料的方法。</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">從外部來看，就是一個 JavaScript 程式，然後你對它送一些 Request，他就會吐 http response 回來。</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Http response 包含了資料 ( ex: 文章、作者、照片、標題、按鈕文字 ) 和 UI/排板 ( CSS / HTML / client-side JavaScript )。通常資料是不重複的。但根據不同的資料，UI 很多重複的地方就變成用 UI Template/UI 元件來表示。</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">傳統產生網頁的方式是把資料和 UI 原件混成一個個各別的網頁然後傳給 Browser 畫出來；最近流行的方式是把資料和UI原件分別傳給 Browser，在 client-side browser 再用 JavaScript 把資料和 UI 原件組合成網頁。</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">近年流行的 json 是一顆用 ( key:value or array ) pair建起來的關聯式資料樹。因此後端資料庫不再用關聯式資料庫，用簡單 NoSql 資料庫 ( 即 dictionary ) 就夠了。</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">簡單來說現代的網頁開發就是開發一個程式：從後端抓一顆 json 資料樹，然後轉成前端美美的 DOM Tree。就是模組化的 Data Visualization，這樣想一切都輕鬆多了。</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">\n</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">這樣的想法很自然的催生了一堆 UI 的程式庫，像是 Angular.js 和 react.js，然後還有 mobile上的 react native。</span></div>","slug":"研究-Node-js-和-Express-js-有感","published":1,"updated":"2017-12-23T06:08:08.301Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjblkzclx0016xq9k9b405i3w","content":"<div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">簡單來說網頁設計，就是設計ㄧ個讓在給了Key 後把相關資料轉換成網頁的 function。</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Node 提供ㄧ個可以用 JS 與其溝通的 non-blocking http server。Express 在上面提供了簡易建立 RESTFUL API、在頁面間 (在 server 上) 傳遞資料的方法。</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">從外部來看，就是一個 JavaScript 程式，然後你對它送一些 Request，他就會吐 http response 回來。</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Http response 包含了資料 ( ex: 文章、作者、照片、標題、按鈕文字 ) 和 UI/排板 ( CSS / HTML / client-side JavaScript )。通常資料是不重複的。但根據不同的資料，UI 很多重複的地方就變成用 UI Template/UI 元件來表示。</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">傳統產生網頁的方式是把資料和 UI 原件混成一個個各別的網頁然後傳給 Browser 畫出來；最近流行的方式是把資料和UI原件分別傳給 Browser，在 client-side browser 再用 JavaScript 把資料和 UI 原件組合成網頁。</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">近年流行的 json 是一顆用 ( key:value or array ) pair建起來的關聯式資料樹。因此後端資料庫不再用關聯式資料庫，用簡單 NoSql 資料庫 ( 即 dictionary ) 就夠了。</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">簡單來說現代的網頁開發就是開發一個程式：從後端抓一顆 json 資料樹，然後轉成前端美美的 DOM Tree。就是模組化的 Data Visualization，這樣想一切都輕鬆多了。</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">這樣的想法很自然的催生了一堆 UI 的程式庫，像是 Angular.js 和 react.js，然後還有 mobile上的 react native。</span></div>","site":{"data":{}},"excerpt":"","more":"<div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">簡單來說網頁設計，就是設計ㄧ個讓在給了Key 後把相關資料轉換成網頁的 function。</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Node 提供ㄧ個可以用 JS 與其溝通的 non-blocking http server。Express 在上面提供了簡易建立 RESTFUL API、在頁面間 (在 server 上) 傳遞資料的方法。</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">從外部來看，就是一個 JavaScript 程式，然後你對它送一些 Request，他就會吐 http response 回來。</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">Http response 包含了資料 ( ex: 文章、作者、照片、標題、按鈕文字 ) 和 UI/排板 ( CSS / HTML / client-side JavaScript )。通常資料是不重複的。但根據不同的資料，UI 很多重複的地方就變成用 UI Template/UI 元件來表示。</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">傳統產生網頁的方式是把資料和 UI 原件混成一個個各別的網頁然後傳給 Browser 畫出來；最近流行的方式是把資料和UI原件分別傳給 Browser，在 client-side browser 再用 JavaScript 把資料和 UI 原件組合成網頁。</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">近年流行的 json 是一顆用 ( key:value or array ) pair建起來的關聯式資料樹。因此後端資料庫不再用關聯式資料庫，用簡單 NoSql 資料庫 ( 即 dictionary ) 就夠了。</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">簡單來說現代的網頁開發就是開發一個程式：從後端抓一顆 json 資料樹，然後轉成前端美美的 DOM Tree。就是模組化的 Data Visualization，這樣想一切都輕鬆多了。</span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\"><br></span></div><div><span style=\"font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;\">這樣的想法很自然的催生了一堆 UI 的程式庫，像是 Angular.js 和 react.js，然後還有 mobile上的 react native。</span></div>"},{"title":"程式設計法與人生 (Programming Paradigm and Life)","date":"2015-11-20T20:06:00.000Z","_content":"\n<div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">解決問題流行的方式有兩種。</span></div>\n\n1.  <span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">想出第一步要做什麼，然後開始做、做完再想下一個。</span>\n2.  <span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">是把大問題切成數個小問題一直切到夠小，然後再一個一個做。</span><div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">第一個<span style=\"line-height: normal;\"> </span>叫做命令式程式設計、第二個<span style=\"line-height: normal;\"> </span>叫做宣告式程式設計。</span></div><div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">第一個<span style=\"line-height: normal;\"> </span>想要回答「怎麼做」、第二個<span style=\"line-height: normal;\"> </span>想要回答「做什麼」。</span>\n<span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">第一個 是工程師做的事、第二個是設計師做的事。</span></div><div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">第一個<span style=\"line-height: normal;\"> </span>叫做敏捷式開發流程、第二個<span style=\"line-height: normal;\"> </span>叫做瀑布式開發流程。</span></div><div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\"><span style=\"line-height: normal;\">第一個</span> <span style=\"line-height: normal;\">叫做</span> connecting the dots<span style=\"line-height: normal;\">、第二個叫做</span> <span style=\"line-height: normal;\">設計研究。</span></span></div><div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">第一個<span style=\"line-height: normal;\"> </span>叫貪婪演算法、第二個叫分治演算法。</span></div><div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">第一個<span style=\"line-height: normal;\"> </span>叫活在當下、第二個叫有遠見。</span></div><div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">第一個 把問題序列化、第二個把問題 心智圖化。</span></div><div style=\"color: #454545; font-size: 15px; line-height: normal; min-height: 18px;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">\n</span></div><div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\"><span style=\"line-height: normal;\">用第一種的人想出了外掛</span> - <span style=\"line-height: normal;\">設計模式</span> (design pattern)<span style=\"line-height: normal;\">。</span></span></div><div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\"><span style=\"line-height: normal;\">用第二種的人想出了外掛</span> - <span style=\"line-height: normal;\">狀態機和不變資料</span> (state machine + immutable data)<span style=\"line-height: normal;\">。</span></span></div><div style=\"color: #454545; font-size: 15px; line-height: normal; min-height: 18px;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">\n</span></div><div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">還記得大二演算法排序的作業，標準解法是先做第二個<span style=\"line-height: normal;\"> (qsort)</span>、然後問題變小了就接第一個<span style=\"line-height: normal;\"> (shell sort)</span>。</span></div><div style=\"color: #454545; font-size: 15px; line-height: normal; min-height: 21px;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">\n</span></div><div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">各有各的使用時機，冷靜分析後我從函數式編程的信仰者回到無神論者了。</span></div><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">第一個適合許多未知、經常變動的問題。</span>\n<span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">第二個適合有固定答案、行為可預測的問題。</span>\n<span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">\n</span><div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">嗯嗯 不過當然用 react 還是比其他好 XD</span>\n<span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">---</span>\n<span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">目標努力 iterative 的 functional programming~&nbsp;</span>\n<span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">=&gt; 每次用第一個方法切一小塊問題，用第二個方法解。</span>\n\n</div>","source":"_posts/程式設計法與人生-Programming-Paradigm-and-Life.md","raw":"---\ntitle: 程式設計法與人生 (Programming Paradigm and Life)\ntags:\n  - functional programming\n  - oop\ndate: 2015-11-21 04:06:00\n---\n\n<div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">解決問題流行的方式有兩種。</span></div>\n\n1.  <span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">想出第一步要做什麼，然後開始做、做完再想下一個。</span>\n2.  <span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">是把大問題切成數個小問題一直切到夠小，然後再一個一個做。</span><div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">第一個<span style=\"line-height: normal;\"> </span>叫做命令式程式設計、第二個<span style=\"line-height: normal;\"> </span>叫做宣告式程式設計。</span></div><div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">第一個<span style=\"line-height: normal;\"> </span>想要回答「怎麼做」、第二個<span style=\"line-height: normal;\"> </span>想要回答「做什麼」。</span>\n<span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">第一個 是工程師做的事、第二個是設計師做的事。</span></div><div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">第一個<span style=\"line-height: normal;\"> </span>叫做敏捷式開發流程、第二個<span style=\"line-height: normal;\"> </span>叫做瀑布式開發流程。</span></div><div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\"><span style=\"line-height: normal;\">第一個</span> <span style=\"line-height: normal;\">叫做</span> connecting the dots<span style=\"line-height: normal;\">、第二個叫做</span> <span style=\"line-height: normal;\">設計研究。</span></span></div><div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">第一個<span style=\"line-height: normal;\"> </span>叫貪婪演算法、第二個叫分治演算法。</span></div><div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">第一個<span style=\"line-height: normal;\"> </span>叫活在當下、第二個叫有遠見。</span></div><div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">第一個 把問題序列化、第二個把問題 心智圖化。</span></div><div style=\"color: #454545; font-size: 15px; line-height: normal; min-height: 18px;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">\n</span></div><div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\"><span style=\"line-height: normal;\">用第一種的人想出了外掛</span> - <span style=\"line-height: normal;\">設計模式</span> (design pattern)<span style=\"line-height: normal;\">。</span></span></div><div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\"><span style=\"line-height: normal;\">用第二種的人想出了外掛</span> - <span style=\"line-height: normal;\">狀態機和不變資料</span> (state machine + immutable data)<span style=\"line-height: normal;\">。</span></span></div><div style=\"color: #454545; font-size: 15px; line-height: normal; min-height: 18px;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">\n</span></div><div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">還記得大二演算法排序的作業，標準解法是先做第二個<span style=\"line-height: normal;\"> (qsort)</span>、然後問題變小了就接第一個<span style=\"line-height: normal;\"> (shell sort)</span>。</span></div><div style=\"color: #454545; font-size: 15px; line-height: normal; min-height: 21px;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">\n</span></div><div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">各有各的使用時機，冷靜分析後我從函數式編程的信仰者回到無神論者了。</span></div><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">第一個適合許多未知、經常變動的問題。</span>\n<span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">第二個適合有固定答案、行為可預測的問題。</span>\n<span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">\n</span><div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">嗯嗯 不過當然用 react 還是比其他好 XD</span>\n<span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">---</span>\n<span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">目標努力 iterative 的 functional programming~&nbsp;</span>\n<span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">=&gt; 每次用第一個方法切一小塊問題，用第二個方法解。</span>\n\n</div>","slug":"程式設計法與人生-Programming-Paradigm-and-Life","published":1,"updated":"2017-12-23T06:08:08.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjblkzclz0018xq9ksc87urpb","content":"<div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">解決問題流行的方式有兩種。</span></div>\n\n<ol>\n<li><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">想出第一步要做什麼，然後開始做、做完再想下一個。</span></li>\n<li><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">是把大問題切成數個小問題一直切到夠小，然後再一個一個做。</span><div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">第一個<span style=\"line-height: normal;\"> </span>叫做命令式程式設計、第二個<span style=\"line-height: normal;\"> </span>叫做宣告式程式設計。</span></div><div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">第一個<span style=\"line-height: normal;\"> </span>想要回答「怎麼做」、第二個<span style=\"line-height: normal;\"> </span>想要回答「做什麼」。</span><br><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">第一個 是工程師做的事、第二個是設計師做的事。</span></div><div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">第一個<span style=\"line-height: normal;\"> </span>叫做敏捷式開發流程、第二個<span style=\"line-height: normal;\"> </span>叫做瀑布式開發流程。</span></div><div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\"><span style=\"line-height: normal;\">第一個</span> <span style=\"line-height: normal;\">叫做</span> connecting the dots<span style=\"line-height: normal;\">、第二個叫做</span> <span style=\"line-height: normal;\">設計研究。</span></span></div><div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">第一個<span style=\"line-height: normal;\"> </span>叫貪婪演算法、第二個叫分治演算法。</span></div><div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">第一個<span style=\"line-height: normal;\"> </span>叫活在當下、第二個叫有遠見。</span></div><div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">第一個 把問題序列化、第二個把問題 心智圖化。</span></div><div style=\"color: #454545; font-size: 15px; line-height: normal; min-height: 18px;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\"><br></span></div><div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\"><span style=\"line-height: normal;\">用第一種的人想出了外掛</span> - <span style=\"line-height: normal;\">設計模式</span> (design pattern)<span style=\"line-height: normal;\">。</span></span></div><div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\"><span style=\"line-height: normal;\">用第二種的人想出了外掛</span> - <span style=\"line-height: normal;\">狀態機和不變資料</span> (state machine + immutable data)<span style=\"line-height: normal;\">。</span></span></div><div style=\"color: #454545; font-size: 15px; line-height: normal; min-height: 18px;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\"><br></span></div><div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">還記得大二演算法排序的作業，標準解法是先做第二個<span style=\"line-height: normal;\"> (qsort)</span>、然後問題變小了就接第一個<span style=\"line-height: normal;\"> (shell sort)</span>。</span></div><div style=\"color: #454545; font-size: 15px; line-height: normal; min-height: 21px;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\"><br></span></div><div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">各有各的使用時機，冷靜分析後我從函數式編程的信仰者回到無神論者了。</span></div><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">第一個適合許多未知、經常變動的問題。</span><br><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">第二個適合有固定答案、行為可預測的問題。</span><br><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\"><br></span><div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">嗯嗯 不過當然用 react 還是比其他好 XD</span><br><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">—</span><br><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">目標努力 iterative 的 functional programming~&nbsp;</span><br><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">=&gt; 每次用第一個方法切一小塊問題，用第二個方法解。</span></div></li>\n</ol>\n<p></p>\n","site":{"data":{}},"excerpt":"","more":"<div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">解決問題流行的方式有兩種。</span></div>\n\n<ol>\n<li><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">想出第一步要做什麼，然後開始做、做完再想下一個。</span></li>\n<li><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">是把大問題切成數個小問題一直切到夠小，然後再一個一個做。</span><div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">第一個<span style=\"line-height: normal;\"> </span>叫做命令式程式設計、第二個<span style=\"line-height: normal;\"> </span>叫做宣告式程式設計。</span></div><div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">第一個<span style=\"line-height: normal;\"> </span>想要回答「怎麼做」、第二個<span style=\"line-height: normal;\"> </span>想要回答「做什麼」。</span><br><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">第一個 是工程師做的事、第二個是設計師做的事。</span></div><div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">第一個<span style=\"line-height: normal;\"> </span>叫做敏捷式開發流程、第二個<span style=\"line-height: normal;\"> </span>叫做瀑布式開發流程。</span></div><div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\"><span style=\"line-height: normal;\">第一個</span> <span style=\"line-height: normal;\">叫做</span> connecting the dots<span style=\"line-height: normal;\">、第二個叫做</span> <span style=\"line-height: normal;\">設計研究。</span></span></div><div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">第一個<span style=\"line-height: normal;\"> </span>叫貪婪演算法、第二個叫分治演算法。</span></div><div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">第一個<span style=\"line-height: normal;\"> </span>叫活在當下、第二個叫有遠見。</span></div><div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">第一個 把問題序列化、第二個把問題 心智圖化。</span></div><div style=\"color: #454545; font-size: 15px; line-height: normal; min-height: 18px;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\"><br></span></div><div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\"><span style=\"line-height: normal;\">用第一種的人想出了外掛</span> - <span style=\"line-height: normal;\">設計模式</span> (design pattern)<span style=\"line-height: normal;\">。</span></span></div><div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\"><span style=\"line-height: normal;\">用第二種的人想出了外掛</span> - <span style=\"line-height: normal;\">狀態機和不變資料</span> (state machine + immutable data)<span style=\"line-height: normal;\">。</span></span></div><div style=\"color: #454545; font-size: 15px; line-height: normal; min-height: 18px;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\"><br></span></div><div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">還記得大二演算法排序的作業，標準解法是先做第二個<span style=\"line-height: normal;\"> (qsort)</span>、然後問題變小了就接第一個<span style=\"line-height: normal;\"> (shell sort)</span>。</span></div><div style=\"color: #454545; font-size: 15px; line-height: normal; min-height: 21px;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\"><br></span></div><div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">各有各的使用時機，冷靜分析後我從函數式編程的信仰者回到無神論者了。</span></div><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">第一個適合許多未知、經常變動的問題。</span><br><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">第二個適合有固定答案、行為可預測的問題。</span><br><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\"><br></span><div style=\"color: #454545; font-size: 15px; line-height: normal;\"><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">嗯嗯 不過當然用 react 還是比其他好 XD</span><br><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">—</span><br><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">目標努力 iterative 的 functional programming~&nbsp;</span><br><span style=\"font-family: Helvetica Neue, Arial, Helvetica, sans-serif;\">=&gt; 每次用第一個方法切一小塊問題，用第二個方法解。</span></div></li>\n</ol>\n<p></p>\n"},{"title":"聊預測自己未來的能力","date":"2015-11-28T07:42:00.000Z","_content":"\n比起預測下一期大樂透號碼的能力，這邊說的「預測未來的能力」跟「對未來的想像力」比較相關，是更日常生活相關的能力，。\n\n這個故事是我最近一個月經常發生的事，剛剛又發生了。我經常會有沒洗澡就睡覺，隔天要出門去咖啡館寫程式的情況，這時就想還是洗一下澡好了、但為了時間還是不要洗頭好。但進入浴室在熱騰騰的蒸氣中間，就會想熱水洗頭會很舒服，然後就洗頭，舒服的回到房間，吹個頭舒服的弄很久才出門。然後隔天出門時又做了一樣的規劃，嗯 洗澡但不洗頭。\n\n這故事跟個人工作能力無關，但卻大大了影響了我工作的計畫和效率。我缺乏的是清楚地理解自己在不同環境中，會受到怎樣的環境影響，就簡單地做出計畫。\n\n如果我清楚地想像就算「現在做了決定不洗頭，等下還是會洗頭」，那在趕時間時，我就會決定不洗澡就出門。如果我清楚地想像到「現在在浴室中洗了頭，會舒服到等下在房間吹頭髮、花半小時東摸摸、西摸摸」，那我可能就會忍住不洗頭。\n\n在這個小故事中影響不大。但在現實工作中，一樣會有這樣的情況。像是被問「這東西下個禮拜做得出來嗎？」腦袋中的想像是每天加班，努力工作，然後下週準時交差。但現實是，加班個兩天，發生了一些問題、或是加班三天後沒心情工作，這些都和你寫程式的能力無關，但卻會在你承諾的時間交不出東西，拖累整個團隊。\n\n對自己能力過於樂觀的估計是大忌!!! 會拖累他人進度。\n\n對自己能力過於悲觀的估計是大忌!!! 會拖累自己成長步調、不敢嘗試。\n\n這種想像力、對過去歷史的記憶力、也許是可以訓練的。再不然只對自己一定能預測正確的情況做預測，其他情況就清楚明白的放在「不知道」這個類別。\n\n俗話說得好「人貴自知，知己者明」。\n努力認識自己吧~ 培養自知之明。\n\n參考：《老子》第三十三章：「知人者智，自知者明；勝人者有力，自勝者強」\n---\nBTW, 這個能力是很容易被觀察的，只要看一個人有沒有準時完成他的承諾就知道了。","source":"_posts/聊預測自己未來的能力.md","raw":"---\ntitle: 聊預測自己未來的能力\ntags:\n  - vivid dream\n  - 老子\ndate: 2015-11-28 15:42:00\n---\n\n比起預測下一期大樂透號碼的能力，這邊說的「預測未來的能力」跟「對未來的想像力」比較相關，是更日常生活相關的能力，。\n\n這個故事是我最近一個月經常發生的事，剛剛又發生了。我經常會有沒洗澡就睡覺，隔天要出門去咖啡館寫程式的情況，這時就想還是洗一下澡好了、但為了時間還是不要洗頭好。但進入浴室在熱騰騰的蒸氣中間，就會想熱水洗頭會很舒服，然後就洗頭，舒服的回到房間，吹個頭舒服的弄很久才出門。然後隔天出門時又做了一樣的規劃，嗯 洗澡但不洗頭。\n\n這故事跟個人工作能力無關，但卻大大了影響了我工作的計畫和效率。我缺乏的是清楚地理解自己在不同環境中，會受到怎樣的環境影響，就簡單地做出計畫。\n\n如果我清楚地想像就算「現在做了決定不洗頭，等下還是會洗頭」，那在趕時間時，我就會決定不洗澡就出門。如果我清楚地想像到「現在在浴室中洗了頭，會舒服到等下在房間吹頭髮、花半小時東摸摸、西摸摸」，那我可能就會忍住不洗頭。\n\n在這個小故事中影響不大。但在現實工作中，一樣會有這樣的情況。像是被問「這東西下個禮拜做得出來嗎？」腦袋中的想像是每天加班，努力工作，然後下週準時交差。但現實是，加班個兩天，發生了一些問題、或是加班三天後沒心情工作，這些都和你寫程式的能力無關，但卻會在你承諾的時間交不出東西，拖累整個團隊。\n\n對自己能力過於樂觀的估計是大忌!!! 會拖累他人進度。\n\n對自己能力過於悲觀的估計是大忌!!! 會拖累自己成長步調、不敢嘗試。\n\n這種想像力、對過去歷史的記憶力、也許是可以訓練的。再不然只對自己一定能預測正確的情況做預測，其他情況就清楚明白的放在「不知道」這個類別。\n\n俗話說得好「人貴自知，知己者明」。\n努力認識自己吧~ 培養自知之明。\n\n參考：《老子》第三十三章：「知人者智，自知者明；勝人者有力，自勝者強」\n---\nBTW, 這個能力是很容易被觀察的，只要看一個人有沒有準時完成他的承諾就知道了。","slug":"聊預測自己未來的能力","published":1,"updated":"2017-12-23T06:08:08.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjblkzcm2001axq9kbs0d5lsg","content":"<p>比起預測下一期大樂透號碼的能力，這邊說的「預測未來的能力」跟「對未來的想像力」比較相關，是更日常生活相關的能力，。</p>\n<p>這個故事是我最近一個月經常發生的事，剛剛又發生了。我經常會有沒洗澡就睡覺，隔天要出門去咖啡館寫程式的情況，這時就想還是洗一下澡好了、但為了時間還是不要洗頭好。但進入浴室在熱騰騰的蒸氣中間，就會想熱水洗頭會很舒服，然後就洗頭，舒服的回到房間，吹個頭舒服的弄很久才出門。然後隔天出門時又做了一樣的規劃，嗯 洗澡但不洗頭。</p>\n<p>這故事跟個人工作能力無關，但卻大大了影響了我工作的計畫和效率。我缺乏的是清楚地理解自己在不同環境中，會受到怎樣的環境影響，就簡單地做出計畫。</p>\n<p>如果我清楚地想像就算「現在做了決定不洗頭，等下還是會洗頭」，那在趕時間時，我就會決定不洗澡就出門。如果我清楚地想像到「現在在浴室中洗了頭，會舒服到等下在房間吹頭髮、花半小時東摸摸、西摸摸」，那我可能就會忍住不洗頭。</p>\n<p>在這個小故事中影響不大。但在現實工作中，一樣會有這樣的情況。像是被問「這東西下個禮拜做得出來嗎？」腦袋中的想像是每天加班，努力工作，然後下週準時交差。但現實是，加班個兩天，發生了一些問題、或是加班三天後沒心情工作，這些都和你寫程式的能力無關，但卻會在你承諾的時間交不出東西，拖累整個團隊。</p>\n<p>對自己能力過於樂觀的估計是大忌!!! 會拖累他人進度。</p>\n<p>對自己能力過於悲觀的估計是大忌!!! 會拖累自己成長步調、不敢嘗試。</p>\n<p>這種想像力、對過去歷史的記憶力、也許是可以訓練的。再不然只對自己一定能預測正確的情況做預測，其他情況就清楚明白的放在「不知道」這個類別。</p>\n<p>俗話說得好「人貴自知，知己者明」。<br>努力認識自己吧~ 培養自知之明。</p>\n<h2 id=\"參考：《老子》第三十三章：「知人者智，自知者明；勝人者有力，自勝者強」\"><a href=\"#參考：《老子》第三十三章：「知人者智，自知者明；勝人者有力，自勝者強」\" class=\"headerlink\" title=\"參考：《老子》第三十三章：「知人者智，自知者明；勝人者有力，自勝者強」\"></a>參考：《老子》第三十三章：「知人者智，自知者明；勝人者有力，自勝者強」</h2><p>BTW, 這個能力是很容易被觀察的，只要看一個人有沒有準時完成他的承諾就知道了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>比起預測下一期大樂透號碼的能力，這邊說的「預測未來的能力」跟「對未來的想像力」比較相關，是更日常生活相關的能力，。</p>\n<p>這個故事是我最近一個月經常發生的事，剛剛又發生了。我經常會有沒洗澡就睡覺，隔天要出門去咖啡館寫程式的情況，這時就想還是洗一下澡好了、但為了時間還是不要洗頭好。但進入浴室在熱騰騰的蒸氣中間，就會想熱水洗頭會很舒服，然後就洗頭，舒服的回到房間，吹個頭舒服的弄很久才出門。然後隔天出門時又做了一樣的規劃，嗯 洗澡但不洗頭。</p>\n<p>這故事跟個人工作能力無關，但卻大大了影響了我工作的計畫和效率。我缺乏的是清楚地理解自己在不同環境中，會受到怎樣的環境影響，就簡單地做出計畫。</p>\n<p>如果我清楚地想像就算「現在做了決定不洗頭，等下還是會洗頭」，那在趕時間時，我就會決定不洗澡就出門。如果我清楚地想像到「現在在浴室中洗了頭，會舒服到等下在房間吹頭髮、花半小時東摸摸、西摸摸」，那我可能就會忍住不洗頭。</p>\n<p>在這個小故事中影響不大。但在現實工作中，一樣會有這樣的情況。像是被問「這東西下個禮拜做得出來嗎？」腦袋中的想像是每天加班，努力工作，然後下週準時交差。但現實是，加班個兩天，發生了一些問題、或是加班三天後沒心情工作，這些都和你寫程式的能力無關，但卻會在你承諾的時間交不出東西，拖累整個團隊。</p>\n<p>對自己能力過於樂觀的估計是大忌!!! 會拖累他人進度。</p>\n<p>對自己能力過於悲觀的估計是大忌!!! 會拖累自己成長步調、不敢嘗試。</p>\n<p>這種想像力、對過去歷史的記憶力、也許是可以訓練的。再不然只對自己一定能預測正確的情況做預測，其他情況就清楚明白的放在「不知道」這個類別。</p>\n<p>俗話說得好「人貴自知，知己者明」。<br>努力認識自己吧~ 培養自知之明。</p>\n<h2 id=\"參考：《老子》第三十三章：「知人者智，自知者明；勝人者有力，自勝者強」\"><a href=\"#參考：《老子》第三十三章：「知人者智，自知者明；勝人者有力，自勝者強」\" class=\"headerlink\" title=\"參考：《老子》第三十三章：「知人者智，自知者明；勝人者有力，自勝者強」\"></a>參考：《老子》第三十三章：「知人者智，自知者明；勝人者有力，自勝者強」</h2><p>BTW, 這個能力是很容易被觀察的，只要看一個人有沒有準時完成他的承諾就知道了。</p>\n"},{"title":"訓練英文的閱讀能力","date":"2015-11-07T04:35:00.000Z","_content":"\n<div class=\"separator\" style=\"clear: both; text-align: center;\"><iframe allowfullscreen=\"\" class=\"YOUTUBE-iframe-video\" data-thumbnail-src=\"https://i.ytimg.com/vi/PZqXBhGR_W8/0.jpg\" frameborder=\"0\" height=\"266\" src=\"https://www.youtube.com/embed/PZqXBhGR_W8?feature=player_embedded\" width=\"320\"></iframe></div>\n最近每天就是一直上網苦苦追趕 Javascript 的 state of art。吸取資訊需要三個重要的能力：英文聽力能力、簡體中文閱讀能力、英文閱讀能力\n\n英聽：\n看youtube都開 1.25x 或 1.5x 的速度，聽得很順、完全可以理解。(感謝無字幕的 冰與火之歌 和 廢話很多的 ASP Surfing Championship 對我的訓練 )\n\n簡體中文閱讀：\n看了很多對岸的文件和字幕 XD，一下就適應了。快要和繁體一樣快。( 因為看太多小說，我對中文的閱讀速度真的很有自信 )\n\n英文閱讀能力：\n唯一的問題就是我的英文閱讀速度，上不去啊。想十年前 ibt 托福閱讀還拿了 29/30，還是不夠。做了這個&nbsp;[英文閱讀能力線上測驗](http://www.staples.com/sbd/cre/marketing/technology-research-centers/ereaders/speed-reader/index.html)&nbsp;發現我現在的閱讀速度只有每分鐘 150 個字 ( 退化...? )，大概是美國小學生的能力。成人平均是 300 個字、大學生平均 500 個字、成績好的大學生大概是 800 個字 ( 這應該是一般部落客的水準吧 )、練過速讀大概是 1500 字。測完就知道我瓶頸在哪了。以前看論文或是教科書，完全沒問題啊，因為那時的瓶頸是理解能力。但現在 Javascript 的資訊很多是部落格，廢話跟我一樣多的部落格，英文閱讀能力就變得超重要。\n\n偷吃步的解法：一個是叫 Mac 唸給你聽... 叫 Mac 念得很快，測過快到超過我的英文閱讀速度還是聽得懂。另一個是只看程式碼，但這畢竟只是治標，今天開始尋找治本的方法。\n\n速讀的訓練的方法：\n1\\. **練習眼睛移動**：\n用規律的速度，拿支筆從每行的開頭，指到每行的結尾。影片剛開始建議的速度是 1.0 秒/行，然後縮減到 0.5 秒 / 行的速度。換算下來大概是每分鐘 800 個字到 1500個字。但對我這個小弱弱，剛開始每三秒一行就好，然後目標練到一秒一行就好。練習的方式是開著節拍器，跟打鼓一樣，設定它每十五分鐘從 20 bpm 加速到 60 bpm，每拍一行開個 16 分音符剛好，每個聲響移動1/4行，慢慢進步。\n\n2\\. &nbsp;練習邊緣視覺：\n筆不用從開頭指到句尾。從開頭第 N 個字開始，看到結尾前第 N 個字就好，因為邊緣視覺會看見。慢慢練習 讓 N 從 0 變成 3。\n\n今天開始每天練十五分鐘，看到底管不管用、目標每分鐘 800 字。 (快五倍... 這有可能嗎？)\n目前能力：每分鐘 150 字 (每五秒一行)\n週目標：每分鐘 400 字 (每兩秒一行, 30 bpm)\n月目標：每分鐘 800 字\n\n好像會有個 browser extension 來訓練這種事吧，我找找...\n\n---\nwow... 估了一下，我國中看一本金庸大概五小時、大概每分鐘 900 個字。是我現在英文閱讀能力的六倍 T.T","source":"_posts/訓練英文的閱讀能力.md","raw":"---\ntitle: 訓練英文的閱讀能力\ntags: []\ndate: 2015-11-07 12:35:00\n---\n\n<div class=\"separator\" style=\"clear: both; text-align: center;\"><iframe allowfullscreen=\"\" class=\"YOUTUBE-iframe-video\" data-thumbnail-src=\"https://i.ytimg.com/vi/PZqXBhGR_W8/0.jpg\" frameborder=\"0\" height=\"266\" src=\"https://www.youtube.com/embed/PZqXBhGR_W8?feature=player_embedded\" width=\"320\"></iframe></div>\n最近每天就是一直上網苦苦追趕 Javascript 的 state of art。吸取資訊需要三個重要的能力：英文聽力能力、簡體中文閱讀能力、英文閱讀能力\n\n英聽：\n看youtube都開 1.25x 或 1.5x 的速度，聽得很順、完全可以理解。(感謝無字幕的 冰與火之歌 和 廢話很多的 ASP Surfing Championship 對我的訓練 )\n\n簡體中文閱讀：\n看了很多對岸的文件和字幕 XD，一下就適應了。快要和繁體一樣快。( 因為看太多小說，我對中文的閱讀速度真的很有自信 )\n\n英文閱讀能力：\n唯一的問題就是我的英文閱讀速度，上不去啊。想十年前 ibt 托福閱讀還拿了 29/30，還是不夠。做了這個&nbsp;[英文閱讀能力線上測驗](http://www.staples.com/sbd/cre/marketing/technology-research-centers/ereaders/speed-reader/index.html)&nbsp;發現我現在的閱讀速度只有每分鐘 150 個字 ( 退化...? )，大概是美國小學生的能力。成人平均是 300 個字、大學生平均 500 個字、成績好的大學生大概是 800 個字 ( 這應該是一般部落客的水準吧 )、練過速讀大概是 1500 字。測完就知道我瓶頸在哪了。以前看論文或是教科書，完全沒問題啊，因為那時的瓶頸是理解能力。但現在 Javascript 的資訊很多是部落格，廢話跟我一樣多的部落格，英文閱讀能力就變得超重要。\n\n偷吃步的解法：一個是叫 Mac 唸給你聽... 叫 Mac 念得很快，測過快到超過我的英文閱讀速度還是聽得懂。另一個是只看程式碼，但這畢竟只是治標，今天開始尋找治本的方法。\n\n速讀的訓練的方法：\n1\\. **練習眼睛移動**：\n用規律的速度，拿支筆從每行的開頭，指到每行的結尾。影片剛開始建議的速度是 1.0 秒/行，然後縮減到 0.5 秒 / 行的速度。換算下來大概是每分鐘 800 個字到 1500個字。但對我這個小弱弱，剛開始每三秒一行就好，然後目標練到一秒一行就好。練習的方式是開著節拍器，跟打鼓一樣，設定它每十五分鐘從 20 bpm 加速到 60 bpm，每拍一行開個 16 分音符剛好，每個聲響移動1/4行，慢慢進步。\n\n2\\. &nbsp;練習邊緣視覺：\n筆不用從開頭指到句尾。從開頭第 N 個字開始，看到結尾前第 N 個字就好，因為邊緣視覺會看見。慢慢練習 讓 N 從 0 變成 3。\n\n今天開始每天練十五分鐘，看到底管不管用、目標每分鐘 800 字。 (快五倍... 這有可能嗎？)\n目前能力：每分鐘 150 字 (每五秒一行)\n週目標：每分鐘 400 字 (每兩秒一行, 30 bpm)\n月目標：每分鐘 800 字\n\n好像會有個 browser extension 來訓練這種事吧，我找找...\n\n---\nwow... 估了一下，我國中看一本金庸大概五小時、大概每分鐘 900 個字。是我現在英文閱讀能力的六倍 T.T","slug":"訓練英文的閱讀能力","published":1,"updated":"2017-12-23T06:08:08.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjblkzcm6001bxq9ktzrs4c6c","content":"<p><div class=\"separator\" style=\"clear: both; text-align: center;\"><iframe allowfullscreen class=\"YOUTUBE-iframe-video\" data-thumbnail-src=\"https://i.ytimg.com/vi/PZqXBhGR_W8/0.jpg\" frameborder=\"0\" height=\"266\" src=\"https://www.youtube.com/embed/PZqXBhGR_W8?feature=player_embedded\" width=\"320\"></iframe></div><br>最近每天就是一直上網苦苦追趕 Javascript 的 state of art。吸取資訊需要三個重要的能力：英文聽力能力、簡體中文閱讀能力、英文閱讀能力</p>\n<p>英聽：<br>看youtube都開 1.25x 或 1.5x 的速度，聽得很順、完全可以理解。(感謝無字幕的 冰與火之歌 和 廢話很多的 ASP Surfing Championship 對我的訓練 )</p>\n<p>簡體中文閱讀：<br>看了很多對岸的文件和字幕 XD，一下就適應了。快要和繁體一樣快。( 因為看太多小說，我對中文的閱讀速度真的很有自信 )</p>\n<p>英文閱讀能力：<br>唯一的問題就是我的英文閱讀速度，上不去啊。想十年前 ibt 托福閱讀還拿了 29/30，還是不夠。做了這個&nbsp;<a href=\"http://www.staples.com/sbd/cre/marketing/technology-research-centers/ereaders/speed-reader/index.html\" target=\"_blank\" rel=\"noopener\">英文閱讀能力線上測驗</a>&nbsp;發現我現在的閱讀速度只有每分鐘 150 個字 ( 退化…? )，大概是美國小學生的能力。成人平均是 300 個字、大學生平均 500 個字、成績好的大學生大概是 800 個字 ( 這應該是一般部落客的水準吧 )、練過速讀大概是 1500 字。測完就知道我瓶頸在哪了。以前看論文或是教科書，完全沒問題啊，因為那時的瓶頸是理解能力。但現在 Javascript 的資訊很多是部落格，廢話跟我一樣多的部落格，英文閱讀能力就變得超重要。</p>\n<p>偷吃步的解法：一個是叫 Mac 唸給你聽… 叫 Mac 念得很快，測過快到超過我的英文閱讀速度還是聽得懂。另一個是只看程式碼，但這畢竟只是治標，今天開始尋找治本的方法。</p>\n<p>速讀的訓練的方法：<br>1. <strong>練習眼睛移動</strong>：<br>用規律的速度，拿支筆從每行的開頭，指到每行的結尾。影片剛開始建議的速度是 1.0 秒/行，然後縮減到 0.5 秒 / 行的速度。換算下來大概是每分鐘 800 個字到 1500個字。但對我這個小弱弱，剛開始每三秒一行就好，然後目標練到一秒一行就好。練習的方式是開著節拍器，跟打鼓一樣，設定它每十五分鐘從 20 bpm 加速到 60 bpm，每拍一行開個 16 分音符剛好，每個聲響移動1/4行，慢慢進步。</p>\n<p>2. &nbsp;練習邊緣視覺：<br>筆不用從開頭指到句尾。從開頭第 N 個字開始，看到結尾前第 N 個字就好，因為邊緣視覺會看見。慢慢練習 讓 N 從 0 變成 3。</p>\n<p>今天開始每天練十五分鐘，看到底管不管用、目標每分鐘 800 字。 (快五倍… 這有可能嗎？)<br>目前能力：每分鐘 150 字 (每五秒一行)<br>週目標：每分鐘 400 字 (每兩秒一行, 30 bpm)<br>月目標：每分鐘 800 字</p>\n<p>好像會有個 browser extension 來訓練這種事吧，我找找…</p>\n<hr>\n<p>wow… 估了一下，我國中看一本金庸大概五小時、大概每分鐘 900 個字。是我現在英文閱讀能力的六倍 T.T</p>\n","site":{"data":{}},"excerpt":"","more":"<p><div class=\"separator\" style=\"clear: both; text-align: center;\"><iframe allowfullscreen class=\"YOUTUBE-iframe-video\" data-thumbnail-src=\"https://i.ytimg.com/vi/PZqXBhGR_W8/0.jpg\" frameborder=\"0\" height=\"266\" src=\"https://www.youtube.com/embed/PZqXBhGR_W8?feature=player_embedded\" width=\"320\"></iframe></div><br>最近每天就是一直上網苦苦追趕 Javascript 的 state of art。吸取資訊需要三個重要的能力：英文聽力能力、簡體中文閱讀能力、英文閱讀能力</p>\n<p>英聽：<br>看youtube都開 1.25x 或 1.5x 的速度，聽得很順、完全可以理解。(感謝無字幕的 冰與火之歌 和 廢話很多的 ASP Surfing Championship 對我的訓練 )</p>\n<p>簡體中文閱讀：<br>看了很多對岸的文件和字幕 XD，一下就適應了。快要和繁體一樣快。( 因為看太多小說，我對中文的閱讀速度真的很有自信 )</p>\n<p>英文閱讀能力：<br>唯一的問題就是我的英文閱讀速度，上不去啊。想十年前 ibt 托福閱讀還拿了 29/30，還是不夠。做了這個&nbsp;<a href=\"http://www.staples.com/sbd/cre/marketing/technology-research-centers/ereaders/speed-reader/index.html\" target=\"_blank\" rel=\"noopener\">英文閱讀能力線上測驗</a>&nbsp;發現我現在的閱讀速度只有每分鐘 150 個字 ( 退化…? )，大概是美國小學生的能力。成人平均是 300 個字、大學生平均 500 個字、成績好的大學生大概是 800 個字 ( 這應該是一般部落客的水準吧 )、練過速讀大概是 1500 字。測完就知道我瓶頸在哪了。以前看論文或是教科書，完全沒問題啊，因為那時的瓶頸是理解能力。但現在 Javascript 的資訊很多是部落格，廢話跟我一樣多的部落格，英文閱讀能力就變得超重要。</p>\n<p>偷吃步的解法：一個是叫 Mac 唸給你聽… 叫 Mac 念得很快，測過快到超過我的英文閱讀速度還是聽得懂。另一個是只看程式碼，但這畢竟只是治標，今天開始尋找治本的方法。</p>\n<p>速讀的訓練的方法：<br>1. <strong>練習眼睛移動</strong>：<br>用規律的速度，拿支筆從每行的開頭，指到每行的結尾。影片剛開始建議的速度是 1.0 秒/行，然後縮減到 0.5 秒 / 行的速度。換算下來大概是每分鐘 800 個字到 1500個字。但對我這個小弱弱，剛開始每三秒一行就好，然後目標練到一秒一行就好。練習的方式是開著節拍器，跟打鼓一樣，設定它每十五分鐘從 20 bpm 加速到 60 bpm，每拍一行開個 16 分音符剛好，每個聲響移動1/4行，慢慢進步。</p>\n<p>2. &nbsp;練習邊緣視覺：<br>筆不用從開頭指到句尾。從開頭第 N 個字開始，看到結尾前第 N 個字就好，因為邊緣視覺會看見。慢慢練習 讓 N 從 0 變成 3。</p>\n<p>今天開始每天練十五分鐘，看到底管不管用、目標每分鐘 800 字。 (快五倍… 這有可能嗎？)<br>目前能力：每分鐘 150 字 (每五秒一行)<br>週目標：每分鐘 400 字 (每兩秒一行, 30 bpm)<br>月目標：每分鐘 800 字</p>\n<p>好像會有個 browser extension 來訓練這種事吧，我找找…</p>\n<hr>\n<p>wow… 估了一下，我國中看一本金庸大概五小時、大概每分鐘 900 個字。是我現在英文閱讀能力的六倍 T.T</p>\n"},{"title":"見樹又見林 - 書摘 & 心得","date":"2016-07-23T01:01:00.000Z","_content":"\n### 書摘的摘要\n社會學是一種讓你看到社會現象背後，整體樣貌的工具，看清楚後就可以尋求一點一滴的改變方法。\n\n用個人主義的方式理解世界，將無法理解社會現象。\n\n社會學中有很多概念工具。社會體系中有文化與結構。社會文化中有符號、信念、價值觀、規範、物質環境。社會結構中有角色、與角色的關係與資源分配。\n\n「社會文化」是社會學中的一個概念工具。文化中的「符號/概念」限制了你對現實世界的理解，我們處於文化中只能透過符號/概念在心中建構出來的真實理解，如果文化中沒有這概念，就無法理解。文化中的「信念、價值觀與規範」，是人判斷哪個選擇比較好、做或不做的依歸，形塑了社會體系中每個角色最小阻力的路。文化中的「物質環境」，像是電視機、手機、農業、工業社會，都會被文化影響、也會影響文化。人常忘了自己的文化只是眾多文化的一種，透過意識到文化盒子的存在，人可以看到自己社會體系的侷限、也可以想像在不同社會體系的世界會怎樣。\n\n「社會結構」是社會學中的另一個概念工具。角色有天生的像是性別、後天的像是職業和情境式的像是行人。人同時會參與多個社會體系，在每個社會體系中扮演一個以上的角色。透過角色關係，每個角色有他的權力與限制，有他阻力最小的路。角色位置和佔據角色位置的人是兩個不同的概念，扮演這個角色的人可以決定要不要，這個角色在社會中被期待的方式走。所以理解一個人的行為時要，理解是結構性的原因，還是個人的選擇。每個社會體系會賦予每個「角色位置」，想要的內容(ex: 資本社會：財富)，和獲得這些內容的合法機會。如果想要的和機會相差太大，這個角色就會容易陷入困境，而對社會體系有四種偏差行為，創新、反叛、退縮與脫離。\n\n人透過行動參與社會體系，社會體系改變現實中的物質環境，物質環境影響人，形成一個循環、這就是人類的生態學。\n\n自我和其他文化中的概念一樣，只是一個被文化符號建構出來的真實。我們是誰，不在於自己本身，而是由我們對社會體系的參與以及學習如何參與的社會化過程來決定的。\n\n社會體系就像一齣電視劇，劇本為文化、場景為物質世界、角色為社會體系中的身份。我們就是其中的演員，大多數人從個人主義的視角看世界，忘了我們可以透過挑劇本、挑角色。如果沒有意識到社會體系的盒子，就只能一直演同個劇本、同個角色，嗯 你的演員人生入戲太深就這樣子了。自己現在的劇本、現在的角色是什麼呢？現在扮演的角色、社會體系真的存在嗎？有其他人也參與這個你想像中的社會體系嗎？還是只是你自己以為而已。透過理解社會學去理解你生活中的劇本，好好演出你的人生、改變其他人的人生。\n\n第一次說「我愛你」不僅是取悅他人而已，而是一種邀請，一種意圖的表示，想要改變一種社會關係。\n\n### 本書介紹 p1~p7\n\n社會學存在的理由是我們身處的社會中總有一些無所謂的苦難的現象。碰到這個時候，我們會問：「為什麼會這樣？」這時社會學成為找到這問題答案的一個工具，幫助我們理解事情如何相互牽連，看清楚後，也就能尋求一點一滴的改變方法。社會學無法讓你全盤理解整個世界，但可以思辨如何參與在生活中的環境，像是社區、家庭和公司。\n\n社會學提供的是一種有系統的思考方式。實踐社會學，使得我們觀察、思索、理解這個世界，改變這個我們身處其中的世界。社會學中有很多理論，都由社會學的本質核心觀念而來。這本書不介紹一大堆理論和專有名詞，但會介紹這個核心觀念，讓人能從社會學的角度來看這個世界。\n\n### 第一章 - 森林、樹群，還有那件事 p8~p42\n多元的社會中的差異會形成特權的基礎，不平等持續的現象，是因為大家都不願意討論特權。因為討論時，享有特權的人會覺得自己被攻擊、沒有特權的人害怕可能會被報復所以不討論。「享有特權的人討論時覺得自己被攻擊」的原因是他們用個人主義的方式看世界，這看法在美國尤其普遍。個人主義的問題是他們忽略了社會中的現象，除了每個個人之外也受社會中的各種關係影響。社會學要研究森林、樹、樹與樹之間的關係。我們叫我們參與的那廣大一點的世界「社會體系」。家庭、公司都是社會體系的一種。社會體系中的角色不等於佔據那個角色的人，個人主義的角度無法理解這點，所以當我們在討論特權「角色」時，他們會以為我們在攻擊「佔據這個角色的個人」。我們必須理解社會體系不同於我，我也不是社會體系本身。\n\n社會體系中會有社會規則，形成每個人面對到最小阻力的路。如果只把社會體系的這些規則當作權威，當成人外在的系統，忘了人是社會體系的一部份、社會規則運作需要人配合，就會忘記自己是可以改變社會體系的。\n\n人參與社會體系會發生什麼事取決於系統本身和運作規則、人在其中的作為。體系影響參與者的想法、感受和行為，靠著就是鋪陳出這些阻力最小的路，雖然任何時刻參與其中的人都有無限多種事可做，但我們通常都不這麼想，只看到體系中很有限的幾個可能性。人也許會同時參與多個體系，然後不同體系中最小阻力的路互相衝突，讓人覺得進退兩難，社會學叫這種情況「角色衝突」\n\n個人主義對理解社會現象沒有用，因為他只看到人、沒看到社會體系。個人主義沒法解釋，不同社會間同個現象個人的差異(ex: 自殺率)。社會學會問「在 xxx 社會體系中，yyy 會覺得做 zzz 是最小阻力的路的原因是什麼？」靠這個問題來探究比自己範圍更大一點的外在情境。但要注意，我們無法只看人，就理解體系的運作；我們也無法只看體系的運作，就理解人的一舉一動。個人主義的人常會問：「是怎樣的人會做出如此殘暴的事？」。把社會現象簡化為「什麼樣的人」的緣由，忽略這些人所身處的社會體系。\n\n在社會體系中總是會和最小阻力的路有所牽連，因為即使你不照社會規則走，其他人會照社會規則來對待你。\n\n社會現象，和參與人有關、又跟他們無關。無關是因為並不是他們創造出這個種族歧視的社會。有關是因為，對於如何參與這種族歧視的社會，人總是還有一些選擇。\n\n那社會中的人該如何呢？透過社會學我們可以知道，不用為社會問題感到自責，因為這不是我的錯。社會學也讓人了解到如何透過參與這個社會，讓我做的選擇如何影響這個社會體系。\n\n個人式的解決之道，無法處理社會問題。社會學對改變社會，比起個人式採用更為複雜的模型，同時著眼社會生活的不同層次。透過體系的層次、個人的層次一起看社會問題。\n\n社會體系影響人，人的行為影響社會體系的運作，就這樣不停循環著。每個人對同個社會體系的理解的、對同個社會體系的心理模型也不同，理解每個人的想法、理解每個體系。這就是社會學要研究的事。\n\n簡單說：實踐社會學會問兩個問題，「人們參與之中的是什麼？」「人們又如何參與？」兩個問題相互碰撞。本書比較著重第一個問題，對於社會體系的分析。\n\n### 第二章 - 文化 — 符號、觀念和生活的種種 p43~p95\n\n人透過詞彙/符號，把感官經驗在心中重新建構一個真實。然後在這個詞彙建構真實的基礎上思考、判斷、做出行為。然而人沒有意識到在心中建構真實時，人也正在選擇。這選擇是一個創造性描述的過程(像是翻譯)，選擇詞彙的同時也就建構出了新的真實。\n\n詞彙從哪裡來？答案是，我所參與的社會是有文化的，那文化主要包含符號，特別是語言中的詞彙和各種想法。文化同時是物質的，像是社會生活中的「東西」、也是非物質性的，透過符號和想法來思考並且賦予任何事物意義。\n\n當我們命名一個感官上的東西，例如「雷聲」，在最簡單的意義下，我們藉著對它的感受，創造了與它的關係。如果沒有命名，我們不會注意到它、會被人有限的注意力忽略。我們的注意力只能集中在一小部分上，唯有透過符號命名，我們才能把注意力集中在這些事物上，我們才能建構一個真實。蘇珊.朗格：『用符號去建構真實，是人類之所以能成為人類最重要的關鍵』\n\n(os: 世界的大小由想像的範圍決定。符號像是 support vector/basis 界定了世界的邊界，用符號把真實投影在心中世界。)\n\n語言可以建構各式各樣的真實，包括我們沒有感官經驗的真實。像是我們不能聽到、聞到或觸摸到所謂的愛。我們看到他人的行為，但行為本身不是愛，而是我們把它想成：「這行為意味著這個人愛我們。」像是大多數人沒能直接觀察到的「原子」，光是透過語言文字就足夠建構出我們視為的現實。在這個意義下，符號的力量遠遠超過它標示的東西。\n\n對於同一件事人有不同的理解版本。每個人心中對於每個符號的意義有不同理解。\n\n每個文化的第一個目的，是提供一種人們可以辨識什麼是真的，什麼是假的方法，這是所謂的信念。在某一意義下，符號是最簡單的信仰陳述，字典的每一個定義就是宣稱某些東西是真實存在的。當文化定義某些是真的，不管實際上是真的還是假的，都會有真實的後果。稱為「顯而易見」的，卻未必是真的，只是在某一特定文化中，被預設為無需懷疑的。(文化中大家都當真的事物...)\n\n文化中有價值觀。價值滲透到我們生活的每個層面，因為種種價值為我們提供一個方法，以便在很多看起來都相似的事物間做選擇。價值除了影響我們怎麼選擇行動的路線之外，還影響我們怎麼看待、對待我們自己和別人。人常忘了，我們把價值當成真實本身自然而然的一部份，而不把它當成是「關於」社會如何建構真實的想法。除了人的基因中的基本偏好，大多數的偏好是來自於在某一特定文化中經由「社會化」所學來的價值。社會體系的組織方式，決定了價值的選擇。經驗過越多文化，我越意識到自己的文化只是一個文化而已，也看到自己總是從文化所提供的有限可能中選擇。\n\n作為個人，我可以意識到文化實質存在，並且形塑我們的觀點和經驗，包括我認為我要的是什麼。我唯有藉著把我自己從我身處的文化所提供的狹隘選擇範圍解放出來，才能擴大我的「自由」。要達到這目的，我需要「跨越出」我習慣的文化框架，這樣才能看到我處的文化「框架」，其實只是很多可能的一種。\n\n價值就像是語法原則，我們用它來解釋從未見過的句子。至於我們怎麼應用那些原則，完全看我們自己。文化中的價值有時會被轉換成規範(norm)，以獎勵和懲罰的「社會後果」來要求人們遵守。若能改變他所參與的「社會體系」，在不同文化規範下就能改變他行動的社會後果。\n\n為什麼要有規範？功能學派認為每個社會體系都有一些要求，在達到這些要求之後社會體系才能運作。如果沒有規範，社會之中的關係就會被瓦解。這關係主要包含我們對彼此的期望。規範對於界定體系的疆界也很重要，規範告訴我們區別自己人與其他人。最能獲得社群的接受並能形成影響的方法是，從一開始就接受這社群的文化。拒絕接受的話，這文化就不會接受你。\n\n文化觀念對人們來說是在體系中應該有怎樣的角色。小孩子玩在一起一定要成立「一國」，第一件事是訂定規則，服從的人才能加入。規則本身是什麼不重要，重要的是建立一種比較大的東西，使成員感覺自己是其中一員，同時也讓成員藉此知道自己是誰。法國社會大師涂爾幹把這種集體感覺的「我們」，當成社會生活的基礎，這是唯一可以控制人們行為的方式。這就是道德，體系中一種共同分享的感覺。沒有這集體感覺，人們會失落，社會體系會瓦解。\n\n所有規範都帶有歸屬和認定的色彩。如果道德是屬於歸屬的問題，那些被視為外人的人，會被當成違反道德準則的偏差者對待，不是因為他們做了什麼，而是因為他們就是他們。在不同形式的社會不平等和壓迫中，這扮演關鍵的角色。\n\n功能學派的學派的觀點是有了規範社會才能運作。但這個觀點沒法看到的是：規範可以排除和壓迫社會上某些人。我們很難理解為什麼一個需要有這樣的安排，讓其中有些團體取得優勢，而讓其他成員承受痛苦。(價值的方向性？)\n\n從社會學的衝突觀點來看，比較能理解社會中存在的有系統的排擠、剝削、宰制和濫權。優勢團體會藉著自己的權利和影響去形塑文化以利於自己的利益；包括保護自己的特權。資本主義中有資本的人有權力，他們會形塑一個文化來保護有資本的人，所以在文化中特別強調不是每個文化中有的「私有財產」的概念。價值為影響別種價值，所以看起來只是保護財產的規範，也可能維護者以特權和不平等為基礎的社會秩序。社會生活的每個面向就是：我們在容易直接了解當地看到的連結關係，其實只是冰山一角。整體理解是社會學實踐很重要的面向，能帶我們深入表層，發覺背後關係的連結。\n\n文化的態度：文化作為感覺。信念、價值觀和規範，對我們如何認識真實，如何思考真實，言行舉止該如何，有很大的影響。他們使我們對人們(ex: 同性戀)有某些感覺。對在這文化中，這類被辨識出來的角色，社會對他們的期待是什麼，有沒有合乎社會要求。這態度主要是感情的(情緒來自大腦邊緣系統的辨識)，也就是說你所感受到的情緒，沒經過大腦思考(前額葉)，就直接受到你所認同的文化態度直接影響。感情、信念和價值的混合體正式文化態度的核心。\n\n我們建構的真實是非物質的，也是物質的。物質文化之所以存在，是因為人有改變世界的能力。同時也改變了文化、改變了自己。是人改變物質世界、物質世界改變文化、文化改變人的循環。例如，紙張和印刷術的出現，讓社會團體想透過控制它，來控制訊息的傳遞。以前一段時間，要有良民證才能擁有一部打字機。資本主義下越來越有一個趨勢，那就是出版社隸屬於，一個與出版毫無關係的大財團下，以便對觀點的流通進行社會控制。\n\n一個穩定的社會文化，一定有其存在的原因，相較於其他文化的優勢、特權，能從文化競爭中搶到更多資源。\n\n社會控制的問題和印刷機器或電視攝影機之類的物質文化的存在與否關係較少，而是和這類物質文化在某一體系中的運用有關。如果我們忽略了物質本身和使用物質的方式，這兩者之間的不同，那我們進一步就會賦予物質文化自己的生命，以為物質文化可以完全支配我們。就像社會體系中角色和佔據角色的人的差別，物質文化中的東西和使用東西的人，是兩個不同的概念。\n\n物質文化是社會文化的一個重要的部分，對於社會一樣。人也常忘了意識到自己所處的物質文化，也只是眾多物質文化其中之一。人是可以改變物質文化的。\n\n我們太容易忘記，文化的總體其實是人類豐富潛能想像的產品。哲學家蘇姍朗格寫道：「我們活在觀念的網絡中，編織網絡的纖維是我們自己創造出來的。」我們就好像住在一個由文化建構的小盒子中，不論是在家庭中、在工作場所中，或是社會中都是如此。我們的視野很少能夠超越小盒子，主要的原因是... 我們連這小盒子的存在都不知道。住在盒子裡，我們看不到外面，就以為自己的文化是最好的、是唯一的文化，這就稱為「種族中心主義」。只有意識到盒子的本身，其他可能性才會開啟。\n\n在複雜社會中，主宰的團體往往用他們建構真實的文化觀念去應用到其他人身上。\n\n文化可以同時引導我們往兩個方向看。文化可以讓我們往內看，看到我們特殊的文化盒子的有限空間。也可以指向盒子本身，引導我們去想像：我們同時在盒子的裡面和外面。這是個充滿能量的經驗。\n\n### 第三章 - 社會生活的結構 p99~p147\n和文化一樣，社會結構的概念是一個社會學實踐的重要關鍵，因為它相當程度地決定了社會生活最令人熟悉而且可預期的樣貌。文化概念形塑的我們如何思考、如何感受。結構則將這些文化概念統整到各種連結人與人、人與體系、體系與體系之間的社會關係。\n\n當我們在生活中經歷了某些戲劇化的變化時，我們會覺得迷失，這是因對我們在一個或多個社會體系中的結構位置改變了。自己的社會位置是什麼，這個問題意味著「我是誰、能做什麼、該做什麼、意義及目標是什麼」。找不到位置的話，也失去了定位體系，這時候我們就會感受到迷失。\n\n社會結構有兩層意義：第一層意義是關於社會生活各層面中的社會關係是如何安排。第二層意義，社會結構指的是社會體系中各種資源的分配。分配包含每個角色的資源和權力，以及人們在角色位置的分配。\n\n一個人的「身份地位」就是一個人在體系中所佔據的結構位置；而我們「參與」一個體系的意思就是我們在這個體系中佔據了一個以上的身份地位。在這裡「身份地位」既是位置，也是佔據這個位置的人。請注意這兩者之間的差異，任何人都可以佔據這個身份位置，不管有沒有人佔據，這個身份位置都會存在。\n\n這種「身份位置」與「佔據此身份位置之個人」之間的區分，對於理解社會生活如何運作有關鍵的意義。如果我們混淆了這兩者的話，我們很可能會犯了企圖用個人因素來解釋社會結構現象的錯誤。\n\n總統他們只是坐在這個位置上的人。沒有任何一個位置只賦予在位者權利而不同時加諸各種限制的；他們所居的職位和一個巨大的職位結構連在一起，這個結構不僅只有政府內部、也有政府之外的一些位置。這些關係正是限制了總統能做什麼、不能做什麼的因素。\n\n更複雜的事，我們同時身處於各種體系之中，這表示我們同時具有許多不同的身份。有些身份是我們與生俱來的，像種族、性別、家庭中的身份。有些身份則是我們在人生過程中獲得的：學生、工人、職員、導師、伴侶、博士。不管是先天或後天獲得的身份，也不論我們是不是真的在執行、實踐這些身份，我們都「具有」這些身份。這些「身份」如影隨形，不管是我們自己或是別人，都用這些身份來認識我們。\n\n還有一些身份是不會隨時跟著我們的，因為他們只存在特定情境之中，像是行人、巴士乘客。情境式的身份必須不斷實踐才能維持，只和我在哪裡、當時在做些什麼事有關。\n\n佔有某個位置的身份意義是：它讓我們和各個社會體系產生關連，提供了我們經歷、參與這些體系時，一條阻力最小的路。身份提供了一整套的文化概念，這就是我們所稱的「角色」，它會在角色所有人和角色關係人身上加諸全套的信念、價值、態度與規範。\n\n當一個人的數個角色的價值有所牴觸時，我們稱為角色衝突。像是教授和異性學生的關係，教授會有「老師」和「情人」這兩種角色。從一個結構的觀點來看，老師和學生的性關係是不可能平等的，因為那些決定了他們在體系中的角色，本質上就是不平等的，也沒有辦法被拉平。只要是老師就必然擁有些權力。由於師生戀這種結構角色所會引起的龐大衝突，一個健康的師生戀關係的機率是微乎其微的。這也是為什麼學校和企業都不鼓勵，或明令禁止類似師生戀這種涉及結構權力關係的親密關係。\n\n人生中很多問題都來自於結構性原因。每個家庭總以為自己是特別的，但卻忘了每個家庭的生活是如此驚人的相似。許多心理治療師不會在沒有見到青少年患者的家人之前治療，因為他們知道個人的問題並不是在真空中發生的。我們的內在情緒生活絕不只侷限於我們的生活世界，他們總是發生在社會脈絡之中。\n\n在許多相似結構的社會中，同個角色都有一樣的行為。這時看一個人行為時，重點就從「這一個人個別來說，究竟是好人還是壞人」轉移到「他們所參與的體系本身究竟乘載了多少鼓勵這個行為產生的因子」。例如：家庭暴力犯罪者都具有「男性」、「丈夫」或「父親」身份的事實，有多少是受大眾文化不斷地將控制與暴力當作「真正的男子漢」的根本標記，將控制與暴力光榮化影響呢？\n\n這不是說所有的錯都是社會的問題，而那些家庭暴力施暴者個人都不需要負任何責任。但是要根本改變目前這種家庭暴力行為模式的話，我們必須了解這些家庭暴力模式和阻力最小的路之間的關聯，以及人們如何決定走上這條阻力最小的路。\n\n資本主義賦予財富高度價值，給你一個價值觀：「擁有某個你現在尚未擁有的東西，幾乎是解決任何問題的答案。」\n\n社會結構與文化價值，會給角色想要的內容和取得的能力、如果想要的內容大於其被賦予的取得能力，這個角色就會容易陷入困境。當他陷入困境，人會產生一種緊張、衝突感，想解決這個困境。方法一，壓力下合法認真的工作。方法二，放棄文化價值、跟自己說那些沒什麼了不起的。方法三，用非法的手段取得內容。方法四，反叛，挑戰現有制度及其不公平的機會分配。\n\n價值的分佈，與滿足這些價值的合法機會分佈，兩個落差越大，偏差行為就越可能產生。但這不意味著高犯罪率是因為人們真的是缺乏他們所需要的東西；這意味著高犯罪率是因為人們缺乏那些旁人都有、而且文化價值告訴他們應該有，而他卻沒有的東西。研究顯示，不論城市的所得平均是多少，在民眾收入最不平等的城市裡，竊盜、搶劫案的發生率最高。\n\n在結構中加入新的角色，社會體系就會劇烈變化。像是生小孩之後的家庭，會發生一些結構現象。\n\n如果體系中的人知道結構就是設計成這樣子的話，他們可能會覺得好受一點。不會只怪罪於其他人的改變、對他的行為。\n\n我們可以問，是體系中的哪些互動模式引起了這個社會現象。\n\n全力是一種不管對方是否同意，權力擁有者都能控制事件、資源與人們能力；權力是一種掌控、強迫、宰制的工具。\n\n對自己身處的社會體系問下面的問題。例如：家庭究竟是什麼？家庭為什麼重要？一個經濟體系應該為參與其中的人做些什麼？\n\n類似文化與社會結構的概念，是我們思考社會生活的工具。讓我們聚焦在生活的不同層面上，最後再把這些東西重新拼裝成一個整體。但這個想法會讓我們把他們視為兩個獨立的事物。但兩者從來未曾獨立存在過。\n\n結構的每一個面向都和文化象徵、文化概念有關。文化影響結構、結構中的人解釋文化，形成因果循環。\n\n### 第四章 - 人口與人類生態學\n人 - 社會體系 - 物質環境 - 人，循環。\n\n### 第五章 - 我們、它和社會互動 p177~p206\n嬰兒不能區辨世界與自己兩者的差別；對他們來說，所有事物都是以他們為中心的一個大「整體」。因此嬰兒無法認知他人是獨立存在的、有思有感的個體。嬰兒只是以事物存在的方式去聽去感覺，並不能理解我和事物的關聯，也不知道如何解釋他們。\n\n米德提出我們是透過發現他人的內心世界，而學會思索自我的。這些認知最初發生於當人們使用語言談論自己、談論我們、談論任何他們經驗到的事實。語言是連結自我經驗和他人經驗的橋樑。藉由發現他人如何經驗自我，我們發現人類自我的可能性。我們開始意識到自己的觀點，我們以為的事實，其實只是一種觀點。之後就可以用思考其他人一樣，使用概念來思考自我。\n\n自我如同其他建構出來的事實，也是一個建構出來的事實。從文化概念中建構出一個我們是誰的真實。透過角色關係來認識我們的不只是一般人，我們自己主要也是以這種方式來認識自己。\n\n我們是依賴外在資訊與自我的資訊，去建構自我的概念和感覺的。外在資訊的來源主要以兩種「他人」的形式存在。一種是對我而言的重要他人(Significant others)；他們像是鏡子一般反映出我們的形象，而我們透過鏡中的形象認識自己是誰。生命初期，自我的資訊都來自於家庭成員、玩伴這些重要他人。社會化之後開始能理解「一般他人」。一般他人不是特定的個人或團體，而是我們的觀念，用觀念想像一般人類會怎麼看待某個社會情境和該情境裡所屬的不同身份的人。\n\n構成一般他人的概念是文化性的，是對身份擁有者的一組概念。\n\n人們只看我們的外表，就認為他們知道我們所屬的身份；聯想我們是怎樣的人。就這層意義而言，我們不只以文化的意義建構真實，因為真實不論就身份、角色和一般他人而言，也全都受到結構的影響。(作者認為文化和結構是獨立的兩件事、我認為結構是文化一部份...)\n\n我們是誰，不在於自己本身，而是由我們對社會體系的參與以及學習如何參與的社會化過程來決定的。我是誰？對誰來說？\n\n沒有了身份和角色，從社會意義上來說，我們就不存在了。這概念並不減低我們作為人的價值；它僅僅意味著我們的存在超越了個體的範圍，個體既不是一切事物的開端，也不是其終點。有些人拒絕任何既定模式而活，反而使他們的行為符合了某種文化模式。\n\n我們如何參與體系的關鍵在於社會互動這個概念，而社會互動的關鍵在於行動(Action)和舉止(Behavior)的區別。有意義基礎的舉止就是行動；而行動則是我們與他人互動、參與社會體系和社會生活的基石。\n\n高夫曼：我們就都像舞台上的演員。不停地自我表演、同時也是觀眾。但我們始終都在做我們自己，即使我們不見得能自在坦然地承認自己在扮演的事實，也不喜歡承認自己用表演來影響他人對我們的觀感。這個我和拒絕承認這是「真實的我」的我，兩者都一樣是真實的「我」。\n\n如果我們沒有辦法不斷意識到我們的自我和我們所參與的社會生活之間的高度複雜性，進而整合我們的各種角色，會是我們因為無知而參與那些會結惡果的社會體系；也會畫地自限，不企圖改變這些惡行。\n\n我們是電視劇中的角色，有編劇寫得最小阻力的劇情，但不同的是每個演員也有自我意志去選擇人生中的行動。如果我們在劇本是壞人的角色，並不代表我們是壞人。但也不代表我們只能演出壞人。我們和體系文化之間的關係是動態的、鮮活的。我們創造了世界；世界也造就了我們。我們同時是文化的客體與主體。\n\n我們就像即興性演出的爵士樂手，沒有學過基礎樂理就不會演奏：必須學會分辨升降記號、大小調，會彈奏不同的和弦，還要能容和節拍、旋律和音調... blah blah。樂手必須知道定義和構成爵士樂這種音樂形式的文化符號和概念；知道這些東西如何影響樂手的思考、聆聽與想像途徑。然而，爵士樂手面對音樂時所依循的社些樂理、文化形式，是他們創作的基礎；樂手可以掰紐玩弄這些「規則」，以一種既熟悉(爵士樂、音樂)又創新的方式，挑戰既有限制。\n\n社會生活和我們的關係，就像爵士樂和爵士樂手們的關係一樣。\n\n社會互動是由人們創造和維持一個特定的現實感所用的各種方式所構成的。社會互動透過行動和外表來進行。行動和外表互為表裡。\n\n社會情境是透過社會真實而界定，而這社會真實也只有在人們主動形塑和維持之下才存在。\n\n我們不斷的用我們對真實如何建構的知識，來理解外界發生了什麼；以及我們該如何扮演我們的角色，讓世界運轉下去。社會中的真實是透過某些模式的社會行動才存在的。這些維持真實的技巧總是一再重複使用，所以往往這些技巧常有儀式性質。像是兩人相愛的親密關係透過，睡前道晚安、吻、掛上電話前說我愛你，等儀式來維持。就像互動儀式中的許多層面，一直要到某方面偏離了這些固定的儀式，我們才會發現這張網上破了一個洞，少掉的那塊就是他們本來應該做、卻沒有照著做的部分。\n\n### 第六章 - 實踐社會學，思索未來p207-p238\n「我愛你」是一種有意圖的表演式語言(performative language)，第一次說「我愛你」不僅是取悅他人而已，而是一種邀請，一種意圖的表示，想要改變一種社會關係。\n\n若要解決社會問題，我們一開始就得把問題的社會面看清楚。如果這點沒做到，那麼我們對於社會問題的解釋，就會不正確，對於解決問題的方向也會有偏差。如果分配方式不改變，就算人再努力讓排列順序改變，最有錢的一部份人、和最窮的一部份人分配到的比例還是一樣的，貧窮的問題一樣不會解決。\n","source":"_posts/見樹又見林-書摘-心得.md","raw":"---\ntitle: 見樹又見林 - 書摘 & 心得\ntags:\n  - sociology\n  - 社會學\ndate: 2016-07-23 09:01:00\n---\n\n### 書摘的摘要\n社會學是一種讓你看到社會現象背後，整體樣貌的工具，看清楚後就可以尋求一點一滴的改變方法。\n\n用個人主義的方式理解世界，將無法理解社會現象。\n\n社會學中有很多概念工具。社會體系中有文化與結構。社會文化中有符號、信念、價值觀、規範、物質環境。社會結構中有角色、與角色的關係與資源分配。\n\n「社會文化」是社會學中的一個概念工具。文化中的「符號/概念」限制了你對現實世界的理解，我們處於文化中只能透過符號/概念在心中建構出來的真實理解，如果文化中沒有這概念，就無法理解。文化中的「信念、價值觀與規範」，是人判斷哪個選擇比較好、做或不做的依歸，形塑了社會體系中每個角色最小阻力的路。文化中的「物質環境」，像是電視機、手機、農業、工業社會，都會被文化影響、也會影響文化。人常忘了自己的文化只是眾多文化的一種，透過意識到文化盒子的存在，人可以看到自己社會體系的侷限、也可以想像在不同社會體系的世界會怎樣。\n\n「社會結構」是社會學中的另一個概念工具。角色有天生的像是性別、後天的像是職業和情境式的像是行人。人同時會參與多個社會體系，在每個社會體系中扮演一個以上的角色。透過角色關係，每個角色有他的權力與限制，有他阻力最小的路。角色位置和佔據角色位置的人是兩個不同的概念，扮演這個角色的人可以決定要不要，這個角色在社會中被期待的方式走。所以理解一個人的行為時要，理解是結構性的原因，還是個人的選擇。每個社會體系會賦予每個「角色位置」，想要的內容(ex: 資本社會：財富)，和獲得這些內容的合法機會。如果想要的和機會相差太大，這個角色就會容易陷入困境，而對社會體系有四種偏差行為，創新、反叛、退縮與脫離。\n\n人透過行動參與社會體系，社會體系改變現實中的物質環境，物質環境影響人，形成一個循環、這就是人類的生態學。\n\n自我和其他文化中的概念一樣，只是一個被文化符號建構出來的真實。我們是誰，不在於自己本身，而是由我們對社會體系的參與以及學習如何參與的社會化過程來決定的。\n\n社會體系就像一齣電視劇，劇本為文化、場景為物質世界、角色為社會體系中的身份。我們就是其中的演員，大多數人從個人主義的視角看世界，忘了我們可以透過挑劇本、挑角色。如果沒有意識到社會體系的盒子，就只能一直演同個劇本、同個角色，嗯 你的演員人生入戲太深就這樣子了。自己現在的劇本、現在的角色是什麼呢？現在扮演的角色、社會體系真的存在嗎？有其他人也參與這個你想像中的社會體系嗎？還是只是你自己以為而已。透過理解社會學去理解你生活中的劇本，好好演出你的人生、改變其他人的人生。\n\n第一次說「我愛你」不僅是取悅他人而已，而是一種邀請，一種意圖的表示，想要改變一種社會關係。\n\n### 本書介紹 p1~p7\n\n社會學存在的理由是我們身處的社會中總有一些無所謂的苦難的現象。碰到這個時候，我們會問：「為什麼會這樣？」這時社會學成為找到這問題答案的一個工具，幫助我們理解事情如何相互牽連，看清楚後，也就能尋求一點一滴的改變方法。社會學無法讓你全盤理解整個世界，但可以思辨如何參與在生活中的環境，像是社區、家庭和公司。\n\n社會學提供的是一種有系統的思考方式。實踐社會學，使得我們觀察、思索、理解這個世界，改變這個我們身處其中的世界。社會學中有很多理論，都由社會學的本質核心觀念而來。這本書不介紹一大堆理論和專有名詞，但會介紹這個核心觀念，讓人能從社會學的角度來看這個世界。\n\n### 第一章 - 森林、樹群，還有那件事 p8~p42\n多元的社會中的差異會形成特權的基礎，不平等持續的現象，是因為大家都不願意討論特權。因為討論時，享有特權的人會覺得自己被攻擊、沒有特權的人害怕可能會被報復所以不討論。「享有特權的人討論時覺得自己被攻擊」的原因是他們用個人主義的方式看世界，這看法在美國尤其普遍。個人主義的問題是他們忽略了社會中的現象，除了每個個人之外也受社會中的各種關係影響。社會學要研究森林、樹、樹與樹之間的關係。我們叫我們參與的那廣大一點的世界「社會體系」。家庭、公司都是社會體系的一種。社會體系中的角色不等於佔據那個角色的人，個人主義的角度無法理解這點，所以當我們在討論特權「角色」時，他們會以為我們在攻擊「佔據這個角色的個人」。我們必須理解社會體系不同於我，我也不是社會體系本身。\n\n社會體系中會有社會規則，形成每個人面對到最小阻力的路。如果只把社會體系的這些規則當作權威，當成人外在的系統，忘了人是社會體系的一部份、社會規則運作需要人配合，就會忘記自己是可以改變社會體系的。\n\n人參與社會體系會發生什麼事取決於系統本身和運作規則、人在其中的作為。體系影響參與者的想法、感受和行為，靠著就是鋪陳出這些阻力最小的路，雖然任何時刻參與其中的人都有無限多種事可做，但我們通常都不這麼想，只看到體系中很有限的幾個可能性。人也許會同時參與多個體系，然後不同體系中最小阻力的路互相衝突，讓人覺得進退兩難，社會學叫這種情況「角色衝突」\n\n個人主義對理解社會現象沒有用，因為他只看到人、沒看到社會體系。個人主義沒法解釋，不同社會間同個現象個人的差異(ex: 自殺率)。社會學會問「在 xxx 社會體系中，yyy 會覺得做 zzz 是最小阻力的路的原因是什麼？」靠這個問題來探究比自己範圍更大一點的外在情境。但要注意，我們無法只看人，就理解體系的運作；我們也無法只看體系的運作，就理解人的一舉一動。個人主義的人常會問：「是怎樣的人會做出如此殘暴的事？」。把社會現象簡化為「什麼樣的人」的緣由，忽略這些人所身處的社會體系。\n\n在社會體系中總是會和最小阻力的路有所牽連，因為即使你不照社會規則走，其他人會照社會規則來對待你。\n\n社會現象，和參與人有關、又跟他們無關。無關是因為並不是他們創造出這個種族歧視的社會。有關是因為，對於如何參與這種族歧視的社會，人總是還有一些選擇。\n\n那社會中的人該如何呢？透過社會學我們可以知道，不用為社會問題感到自責，因為這不是我的錯。社會學也讓人了解到如何透過參與這個社會，讓我做的選擇如何影響這個社會體系。\n\n個人式的解決之道，無法處理社會問題。社會學對改變社會，比起個人式採用更為複雜的模型，同時著眼社會生活的不同層次。透過體系的層次、個人的層次一起看社會問題。\n\n社會體系影響人，人的行為影響社會體系的運作，就這樣不停循環著。每個人對同個社會體系的理解的、對同個社會體系的心理模型也不同，理解每個人的想法、理解每個體系。這就是社會學要研究的事。\n\n簡單說：實踐社會學會問兩個問題，「人們參與之中的是什麼？」「人們又如何參與？」兩個問題相互碰撞。本書比較著重第一個問題，對於社會體系的分析。\n\n### 第二章 - 文化 — 符號、觀念和生活的種種 p43~p95\n\n人透過詞彙/符號，把感官經驗在心中重新建構一個真實。然後在這個詞彙建構真實的基礎上思考、判斷、做出行為。然而人沒有意識到在心中建構真實時，人也正在選擇。這選擇是一個創造性描述的過程(像是翻譯)，選擇詞彙的同時也就建構出了新的真實。\n\n詞彙從哪裡來？答案是，我所參與的社會是有文化的，那文化主要包含符號，特別是語言中的詞彙和各種想法。文化同時是物質的，像是社會生活中的「東西」、也是非物質性的，透過符號和想法來思考並且賦予任何事物意義。\n\n當我們命名一個感官上的東西，例如「雷聲」，在最簡單的意義下，我們藉著對它的感受，創造了與它的關係。如果沒有命名，我們不會注意到它、會被人有限的注意力忽略。我們的注意力只能集中在一小部分上，唯有透過符號命名，我們才能把注意力集中在這些事物上，我們才能建構一個真實。蘇珊.朗格：『用符號去建構真實，是人類之所以能成為人類最重要的關鍵』\n\n(os: 世界的大小由想像的範圍決定。符號像是 support vector/basis 界定了世界的邊界，用符號把真實投影在心中世界。)\n\n語言可以建構各式各樣的真實，包括我們沒有感官經驗的真實。像是我們不能聽到、聞到或觸摸到所謂的愛。我們看到他人的行為，但行為本身不是愛，而是我們把它想成：「這行為意味著這個人愛我們。」像是大多數人沒能直接觀察到的「原子」，光是透過語言文字就足夠建構出我們視為的現實。在這個意義下，符號的力量遠遠超過它標示的東西。\n\n對於同一件事人有不同的理解版本。每個人心中對於每個符號的意義有不同理解。\n\n每個文化的第一個目的，是提供一種人們可以辨識什麼是真的，什麼是假的方法，這是所謂的信念。在某一意義下，符號是最簡單的信仰陳述，字典的每一個定義就是宣稱某些東西是真實存在的。當文化定義某些是真的，不管實際上是真的還是假的，都會有真實的後果。稱為「顯而易見」的，卻未必是真的，只是在某一特定文化中，被預設為無需懷疑的。(文化中大家都當真的事物...)\n\n文化中有價值觀。價值滲透到我們生活的每個層面，因為種種價值為我們提供一個方法，以便在很多看起來都相似的事物間做選擇。價值除了影響我們怎麼選擇行動的路線之外，還影響我們怎麼看待、對待我們自己和別人。人常忘了，我們把價值當成真實本身自然而然的一部份，而不把它當成是「關於」社會如何建構真實的想法。除了人的基因中的基本偏好，大多數的偏好是來自於在某一特定文化中經由「社會化」所學來的價值。社會體系的組織方式，決定了價值的選擇。經驗過越多文化，我越意識到自己的文化只是一個文化而已，也看到自己總是從文化所提供的有限可能中選擇。\n\n作為個人，我可以意識到文化實質存在，並且形塑我們的觀點和經驗，包括我認為我要的是什麼。我唯有藉著把我自己從我身處的文化所提供的狹隘選擇範圍解放出來，才能擴大我的「自由」。要達到這目的，我需要「跨越出」我習慣的文化框架，這樣才能看到我處的文化「框架」，其實只是很多可能的一種。\n\n價值就像是語法原則，我們用它來解釋從未見過的句子。至於我們怎麼應用那些原則，完全看我們自己。文化中的價值有時會被轉換成規範(norm)，以獎勵和懲罰的「社會後果」來要求人們遵守。若能改變他所參與的「社會體系」，在不同文化規範下就能改變他行動的社會後果。\n\n為什麼要有規範？功能學派認為每個社會體系都有一些要求，在達到這些要求之後社會體系才能運作。如果沒有規範，社會之中的關係就會被瓦解。這關係主要包含我們對彼此的期望。規範對於界定體系的疆界也很重要，規範告訴我們區別自己人與其他人。最能獲得社群的接受並能形成影響的方法是，從一開始就接受這社群的文化。拒絕接受的話，這文化就不會接受你。\n\n文化觀念對人們來說是在體系中應該有怎樣的角色。小孩子玩在一起一定要成立「一國」，第一件事是訂定規則，服從的人才能加入。規則本身是什麼不重要，重要的是建立一種比較大的東西，使成員感覺自己是其中一員，同時也讓成員藉此知道自己是誰。法國社會大師涂爾幹把這種集體感覺的「我們」，當成社會生活的基礎，這是唯一可以控制人們行為的方式。這就是道德，體系中一種共同分享的感覺。沒有這集體感覺，人們會失落，社會體系會瓦解。\n\n所有規範都帶有歸屬和認定的色彩。如果道德是屬於歸屬的問題，那些被視為外人的人，會被當成違反道德準則的偏差者對待，不是因為他們做了什麼，而是因為他們就是他們。在不同形式的社會不平等和壓迫中，這扮演關鍵的角色。\n\n功能學派的學派的觀點是有了規範社會才能運作。但這個觀點沒法看到的是：規範可以排除和壓迫社會上某些人。我們很難理解為什麼一個需要有這樣的安排，讓其中有些團體取得優勢，而讓其他成員承受痛苦。(價值的方向性？)\n\n從社會學的衝突觀點來看，比較能理解社會中存在的有系統的排擠、剝削、宰制和濫權。優勢團體會藉著自己的權利和影響去形塑文化以利於自己的利益；包括保護自己的特權。資本主義中有資本的人有權力，他們會形塑一個文化來保護有資本的人，所以在文化中特別強調不是每個文化中有的「私有財產」的概念。價值為影響別種價值，所以看起來只是保護財產的規範，也可能維護者以特權和不平等為基礎的社會秩序。社會生活的每個面向就是：我們在容易直接了解當地看到的連結關係，其實只是冰山一角。整體理解是社會學實踐很重要的面向，能帶我們深入表層，發覺背後關係的連結。\n\n文化的態度：文化作為感覺。信念、價值觀和規範，對我們如何認識真實，如何思考真實，言行舉止該如何，有很大的影響。他們使我們對人們(ex: 同性戀)有某些感覺。對在這文化中，這類被辨識出來的角色，社會對他們的期待是什麼，有沒有合乎社會要求。這態度主要是感情的(情緒來自大腦邊緣系統的辨識)，也就是說你所感受到的情緒，沒經過大腦思考(前額葉)，就直接受到你所認同的文化態度直接影響。感情、信念和價值的混合體正式文化態度的核心。\n\n我們建構的真實是非物質的，也是物質的。物質文化之所以存在，是因為人有改變世界的能力。同時也改變了文化、改變了自己。是人改變物質世界、物質世界改變文化、文化改變人的循環。例如，紙張和印刷術的出現，讓社會團體想透過控制它，來控制訊息的傳遞。以前一段時間，要有良民證才能擁有一部打字機。資本主義下越來越有一個趨勢，那就是出版社隸屬於，一個與出版毫無關係的大財團下，以便對觀點的流通進行社會控制。\n\n一個穩定的社會文化，一定有其存在的原因，相較於其他文化的優勢、特權，能從文化競爭中搶到更多資源。\n\n社會控制的問題和印刷機器或電視攝影機之類的物質文化的存在與否關係較少，而是和這類物質文化在某一體系中的運用有關。如果我們忽略了物質本身和使用物質的方式，這兩者之間的不同，那我們進一步就會賦予物質文化自己的生命，以為物質文化可以完全支配我們。就像社會體系中角色和佔據角色的人的差別，物質文化中的東西和使用東西的人，是兩個不同的概念。\n\n物質文化是社會文化的一個重要的部分，對於社會一樣。人也常忘了意識到自己所處的物質文化，也只是眾多物質文化其中之一。人是可以改變物質文化的。\n\n我們太容易忘記，文化的總體其實是人類豐富潛能想像的產品。哲學家蘇姍朗格寫道：「我們活在觀念的網絡中，編織網絡的纖維是我們自己創造出來的。」我們就好像住在一個由文化建構的小盒子中，不論是在家庭中、在工作場所中，或是社會中都是如此。我們的視野很少能夠超越小盒子，主要的原因是... 我們連這小盒子的存在都不知道。住在盒子裡，我們看不到外面，就以為自己的文化是最好的、是唯一的文化，這就稱為「種族中心主義」。只有意識到盒子的本身，其他可能性才會開啟。\n\n在複雜社會中，主宰的團體往往用他們建構真實的文化觀念去應用到其他人身上。\n\n文化可以同時引導我們往兩個方向看。文化可以讓我們往內看，看到我們特殊的文化盒子的有限空間。也可以指向盒子本身，引導我們去想像：我們同時在盒子的裡面和外面。這是個充滿能量的經驗。\n\n### 第三章 - 社會生活的結構 p99~p147\n和文化一樣，社會結構的概念是一個社會學實踐的重要關鍵，因為它相當程度地決定了社會生活最令人熟悉而且可預期的樣貌。文化概念形塑的我們如何思考、如何感受。結構則將這些文化概念統整到各種連結人與人、人與體系、體系與體系之間的社會關係。\n\n當我們在生活中經歷了某些戲劇化的變化時，我們會覺得迷失，這是因對我們在一個或多個社會體系中的結構位置改變了。自己的社會位置是什麼，這個問題意味著「我是誰、能做什麼、該做什麼、意義及目標是什麼」。找不到位置的話，也失去了定位體系，這時候我們就會感受到迷失。\n\n社會結構有兩層意義：第一層意義是關於社會生活各層面中的社會關係是如何安排。第二層意義，社會結構指的是社會體系中各種資源的分配。分配包含每個角色的資源和權力，以及人們在角色位置的分配。\n\n一個人的「身份地位」就是一個人在體系中所佔據的結構位置；而我們「參與」一個體系的意思就是我們在這個體系中佔據了一個以上的身份地位。在這裡「身份地位」既是位置，也是佔據這個位置的人。請注意這兩者之間的差異，任何人都可以佔據這個身份位置，不管有沒有人佔據，這個身份位置都會存在。\n\n這種「身份位置」與「佔據此身份位置之個人」之間的區分，對於理解社會生活如何運作有關鍵的意義。如果我們混淆了這兩者的話，我們很可能會犯了企圖用個人因素來解釋社會結構現象的錯誤。\n\n總統他們只是坐在這個位置上的人。沒有任何一個位置只賦予在位者權利而不同時加諸各種限制的；他們所居的職位和一個巨大的職位結構連在一起，這個結構不僅只有政府內部、也有政府之外的一些位置。這些關係正是限制了總統能做什麼、不能做什麼的因素。\n\n更複雜的事，我們同時身處於各種體系之中，這表示我們同時具有許多不同的身份。有些身份是我們與生俱來的，像種族、性別、家庭中的身份。有些身份則是我們在人生過程中獲得的：學生、工人、職員、導師、伴侶、博士。不管是先天或後天獲得的身份，也不論我們是不是真的在執行、實踐這些身份，我們都「具有」這些身份。這些「身份」如影隨形，不管是我們自己或是別人，都用這些身份來認識我們。\n\n還有一些身份是不會隨時跟著我們的，因為他們只存在特定情境之中，像是行人、巴士乘客。情境式的身份必須不斷實踐才能維持，只和我在哪裡、當時在做些什麼事有關。\n\n佔有某個位置的身份意義是：它讓我們和各個社會體系產生關連，提供了我們經歷、參與這些體系時，一條阻力最小的路。身份提供了一整套的文化概念，這就是我們所稱的「角色」，它會在角色所有人和角色關係人身上加諸全套的信念、價值、態度與規範。\n\n當一個人的數個角色的價值有所牴觸時，我們稱為角色衝突。像是教授和異性學生的關係，教授會有「老師」和「情人」這兩種角色。從一個結構的觀點來看，老師和學生的性關係是不可能平等的，因為那些決定了他們在體系中的角色，本質上就是不平等的，也沒有辦法被拉平。只要是老師就必然擁有些權力。由於師生戀這種結構角色所會引起的龐大衝突，一個健康的師生戀關係的機率是微乎其微的。這也是為什麼學校和企業都不鼓勵，或明令禁止類似師生戀這種涉及結構權力關係的親密關係。\n\n人生中很多問題都來自於結構性原因。每個家庭總以為自己是特別的，但卻忘了每個家庭的生活是如此驚人的相似。許多心理治療師不會在沒有見到青少年患者的家人之前治療，因為他們知道個人的問題並不是在真空中發生的。我們的內在情緒生活絕不只侷限於我們的生活世界，他們總是發生在社會脈絡之中。\n\n在許多相似結構的社會中，同個角色都有一樣的行為。這時看一個人行為時，重點就從「這一個人個別來說，究竟是好人還是壞人」轉移到「他們所參與的體系本身究竟乘載了多少鼓勵這個行為產生的因子」。例如：家庭暴力犯罪者都具有「男性」、「丈夫」或「父親」身份的事實，有多少是受大眾文化不斷地將控制與暴力當作「真正的男子漢」的根本標記，將控制與暴力光榮化影響呢？\n\n這不是說所有的錯都是社會的問題，而那些家庭暴力施暴者個人都不需要負任何責任。但是要根本改變目前這種家庭暴力行為模式的話，我們必須了解這些家庭暴力模式和阻力最小的路之間的關聯，以及人們如何決定走上這條阻力最小的路。\n\n資本主義賦予財富高度價值，給你一個價值觀：「擁有某個你現在尚未擁有的東西，幾乎是解決任何問題的答案。」\n\n社會結構與文化價值，會給角色想要的內容和取得的能力、如果想要的內容大於其被賦予的取得能力，這個角色就會容易陷入困境。當他陷入困境，人會產生一種緊張、衝突感，想解決這個困境。方法一，壓力下合法認真的工作。方法二，放棄文化價值、跟自己說那些沒什麼了不起的。方法三，用非法的手段取得內容。方法四，反叛，挑戰現有制度及其不公平的機會分配。\n\n價值的分佈，與滿足這些價值的合法機會分佈，兩個落差越大，偏差行為就越可能產生。但這不意味著高犯罪率是因為人們真的是缺乏他們所需要的東西；這意味著高犯罪率是因為人們缺乏那些旁人都有、而且文化價值告訴他們應該有，而他卻沒有的東西。研究顯示，不論城市的所得平均是多少，在民眾收入最不平等的城市裡，竊盜、搶劫案的發生率最高。\n\n在結構中加入新的角色，社會體系就會劇烈變化。像是生小孩之後的家庭，會發生一些結構現象。\n\n如果體系中的人知道結構就是設計成這樣子的話，他們可能會覺得好受一點。不會只怪罪於其他人的改變、對他的行為。\n\n我們可以問，是體系中的哪些互動模式引起了這個社會現象。\n\n全力是一種不管對方是否同意，權力擁有者都能控制事件、資源與人們能力；權力是一種掌控、強迫、宰制的工具。\n\n對自己身處的社會體系問下面的問題。例如：家庭究竟是什麼？家庭為什麼重要？一個經濟體系應該為參與其中的人做些什麼？\n\n類似文化與社會結構的概念，是我們思考社會生活的工具。讓我們聚焦在生活的不同層面上，最後再把這些東西重新拼裝成一個整體。但這個想法會讓我們把他們視為兩個獨立的事物。但兩者從來未曾獨立存在過。\n\n結構的每一個面向都和文化象徵、文化概念有關。文化影響結構、結構中的人解釋文化，形成因果循環。\n\n### 第四章 - 人口與人類生態學\n人 - 社會體系 - 物質環境 - 人，循環。\n\n### 第五章 - 我們、它和社會互動 p177~p206\n嬰兒不能區辨世界與自己兩者的差別；對他們來說，所有事物都是以他們為中心的一個大「整體」。因此嬰兒無法認知他人是獨立存在的、有思有感的個體。嬰兒只是以事物存在的方式去聽去感覺，並不能理解我和事物的關聯，也不知道如何解釋他們。\n\n米德提出我們是透過發現他人的內心世界，而學會思索自我的。這些認知最初發生於當人們使用語言談論自己、談論我們、談論任何他們經驗到的事實。語言是連結自我經驗和他人經驗的橋樑。藉由發現他人如何經驗自我，我們發現人類自我的可能性。我們開始意識到自己的觀點，我們以為的事實，其實只是一種觀點。之後就可以用思考其他人一樣，使用概念來思考自我。\n\n自我如同其他建構出來的事實，也是一個建構出來的事實。從文化概念中建構出一個我們是誰的真實。透過角色關係來認識我們的不只是一般人，我們自己主要也是以這種方式來認識自己。\n\n我們是依賴外在資訊與自我的資訊，去建構自我的概念和感覺的。外在資訊的來源主要以兩種「他人」的形式存在。一種是對我而言的重要他人(Significant others)；他們像是鏡子一般反映出我們的形象，而我們透過鏡中的形象認識自己是誰。生命初期，自我的資訊都來自於家庭成員、玩伴這些重要他人。社會化之後開始能理解「一般他人」。一般他人不是特定的個人或團體，而是我們的觀念，用觀念想像一般人類會怎麼看待某個社會情境和該情境裡所屬的不同身份的人。\n\n構成一般他人的概念是文化性的，是對身份擁有者的一組概念。\n\n人們只看我們的外表，就認為他們知道我們所屬的身份；聯想我們是怎樣的人。就這層意義而言，我們不只以文化的意義建構真實，因為真實不論就身份、角色和一般他人而言，也全都受到結構的影響。(作者認為文化和結構是獨立的兩件事、我認為結構是文化一部份...)\n\n我們是誰，不在於自己本身，而是由我們對社會體系的參與以及學習如何參與的社會化過程來決定的。我是誰？對誰來說？\n\n沒有了身份和角色，從社會意義上來說，我們就不存在了。這概念並不減低我們作為人的價值；它僅僅意味著我們的存在超越了個體的範圍，個體既不是一切事物的開端，也不是其終點。有些人拒絕任何既定模式而活，反而使他們的行為符合了某種文化模式。\n\n我們如何參與體系的關鍵在於社會互動這個概念，而社會互動的關鍵在於行動(Action)和舉止(Behavior)的區別。有意義基礎的舉止就是行動；而行動則是我們與他人互動、參與社會體系和社會生活的基石。\n\n高夫曼：我們就都像舞台上的演員。不停地自我表演、同時也是觀眾。但我們始終都在做我們自己，即使我們不見得能自在坦然地承認自己在扮演的事實，也不喜歡承認自己用表演來影響他人對我們的觀感。這個我和拒絕承認這是「真實的我」的我，兩者都一樣是真實的「我」。\n\n如果我們沒有辦法不斷意識到我們的自我和我們所參與的社會生活之間的高度複雜性，進而整合我們的各種角色，會是我們因為無知而參與那些會結惡果的社會體系；也會畫地自限，不企圖改變這些惡行。\n\n我們是電視劇中的角色，有編劇寫得最小阻力的劇情，但不同的是每個演員也有自我意志去選擇人生中的行動。如果我們在劇本是壞人的角色，並不代表我們是壞人。但也不代表我們只能演出壞人。我們和體系文化之間的關係是動態的、鮮活的。我們創造了世界；世界也造就了我們。我們同時是文化的客體與主體。\n\n我們就像即興性演出的爵士樂手，沒有學過基礎樂理就不會演奏：必須學會分辨升降記號、大小調，會彈奏不同的和弦，還要能容和節拍、旋律和音調... blah blah。樂手必須知道定義和構成爵士樂這種音樂形式的文化符號和概念；知道這些東西如何影響樂手的思考、聆聽與想像途徑。然而，爵士樂手面對音樂時所依循的社些樂理、文化形式，是他們創作的基礎；樂手可以掰紐玩弄這些「規則」，以一種既熟悉(爵士樂、音樂)又創新的方式，挑戰既有限制。\n\n社會生活和我們的關係，就像爵士樂和爵士樂手們的關係一樣。\n\n社會互動是由人們創造和維持一個特定的現實感所用的各種方式所構成的。社會互動透過行動和外表來進行。行動和外表互為表裡。\n\n社會情境是透過社會真實而界定，而這社會真實也只有在人們主動形塑和維持之下才存在。\n\n我們不斷的用我們對真實如何建構的知識，來理解外界發生了什麼；以及我們該如何扮演我們的角色，讓世界運轉下去。社會中的真實是透過某些模式的社會行動才存在的。這些維持真實的技巧總是一再重複使用，所以往往這些技巧常有儀式性質。像是兩人相愛的親密關係透過，睡前道晚安、吻、掛上電話前說我愛你，等儀式來維持。就像互動儀式中的許多層面，一直要到某方面偏離了這些固定的儀式，我們才會發現這張網上破了一個洞，少掉的那塊就是他們本來應該做、卻沒有照著做的部分。\n\n### 第六章 - 實踐社會學，思索未來p207-p238\n「我愛你」是一種有意圖的表演式語言(performative language)，第一次說「我愛你」不僅是取悅他人而已，而是一種邀請，一種意圖的表示，想要改變一種社會關係。\n\n若要解決社會問題，我們一開始就得把問題的社會面看清楚。如果這點沒做到，那麼我們對於社會問題的解釋，就會不正確，對於解決問題的方向也會有偏差。如果分配方式不改變，就算人再努力讓排列順序改變，最有錢的一部份人、和最窮的一部份人分配到的比例還是一樣的，貧窮的問題一樣不會解決。\n","slug":"見樹又見林-書摘-心得","published":1,"updated":"2017-12-25T02:19:53.078Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjblkzcmb001dxq9ktdhe2iaa","content":"<h3 id=\"書摘的摘要\"><a href=\"#書摘的摘要\" class=\"headerlink\" title=\"書摘的摘要\"></a>書摘的摘要</h3><p>社會學是一種讓你看到社會現象背後，整體樣貌的工具，看清楚後就可以尋求一點一滴的改變方法。</p>\n<p>用個人主義的方式理解世界，將無法理解社會現象。</p>\n<p>社會學中有很多概念工具。社會體系中有文化與結構。社會文化中有符號、信念、價值觀、規範、物質環境。社會結構中有角色、與角色的關係與資源分配。</p>\n<p>「社會文化」是社會學中的一個概念工具。文化中的「符號/概念」限制了你對現實世界的理解，我們處於文化中只能透過符號/概念在心中建構出來的真實理解，如果文化中沒有這概念，就無法理解。文化中的「信念、價值觀與規範」，是人判斷哪個選擇比較好、做或不做的依歸，形塑了社會體系中每個角色最小阻力的路。文化中的「物質環境」，像是電視機、手機、農業、工業社會，都會被文化影響、也會影響文化。人常忘了自己的文化只是眾多文化的一種，透過意識到文化盒子的存在，人可以看到自己社會體系的侷限、也可以想像在不同社會體系的世界會怎樣。</p>\n<p>「社會結構」是社會學中的另一個概念工具。角色有天生的像是性別、後天的像是職業和情境式的像是行人。人同時會參與多個社會體系，在每個社會體系中扮演一個以上的角色。透過角色關係，每個角色有他的權力與限制，有他阻力最小的路。角色位置和佔據角色位置的人是兩個不同的概念，扮演這個角色的人可以決定要不要，這個角色在社會中被期待的方式走。所以理解一個人的行為時要，理解是結構性的原因，還是個人的選擇。每個社會體系會賦予每個「角色位置」，想要的內容(ex: 資本社會：財富)，和獲得這些內容的合法機會。如果想要的和機會相差太大，這個角色就會容易陷入困境，而對社會體系有四種偏差行為，創新、反叛、退縮與脫離。</p>\n<p>人透過行動參與社會體系，社會體系改變現實中的物質環境，物質環境影響人，形成一個循環、這就是人類的生態學。</p>\n<p>自我和其他文化中的概念一樣，只是一個被文化符號建構出來的真實。我們是誰，不在於自己本身，而是由我們對社會體系的參與以及學習如何參與的社會化過程來決定的。</p>\n<p>社會體系就像一齣電視劇，劇本為文化、場景為物質世界、角色為社會體系中的身份。我們就是其中的演員，大多數人從個人主義的視角看世界，忘了我們可以透過挑劇本、挑角色。如果沒有意識到社會體系的盒子，就只能一直演同個劇本、同個角色，嗯 你的演員人生入戲太深就這樣子了。自己現在的劇本、現在的角色是什麼呢？現在扮演的角色、社會體系真的存在嗎？有其他人也參與這個你想像中的社會體系嗎？還是只是你自己以為而已。透過理解社會學去理解你生活中的劇本，好好演出你的人生、改變其他人的人生。</p>\n<p>第一次說「我愛你」不僅是取悅他人而已，而是一種邀請，一種意圖的表示，想要改變一種社會關係。</p>\n<h3 id=\"本書介紹-p1-p7\"><a href=\"#本書介紹-p1-p7\" class=\"headerlink\" title=\"本書介紹 p1~p7\"></a>本書介紹 p1~p7</h3><p>社會學存在的理由是我們身處的社會中總有一些無所謂的苦難的現象。碰到這個時候，我們會問：「為什麼會這樣？」這時社會學成為找到這問題答案的一個工具，幫助我們理解事情如何相互牽連，看清楚後，也就能尋求一點一滴的改變方法。社會學無法讓你全盤理解整個世界，但可以思辨如何參與在生活中的環境，像是社區、家庭和公司。</p>\n<p>社會學提供的是一種有系統的思考方式。實踐社會學，使得我們觀察、思索、理解這個世界，改變這個我們身處其中的世界。社會學中有很多理論，都由社會學的本質核心觀念而來。這本書不介紹一大堆理論和專有名詞，但會介紹這個核心觀念，讓人能從社會學的角度來看這個世界。</p>\n<h3 id=\"第一章-森林、樹群，還有那件事-p8-p42\"><a href=\"#第一章-森林、樹群，還有那件事-p8-p42\" class=\"headerlink\" title=\"第一章 - 森林、樹群，還有那件事 p8~p42\"></a>第一章 - 森林、樹群，還有那件事 p8~p42</h3><p>多元的社會中的差異會形成特權的基礎，不平等持續的現象，是因為大家都不願意討論特權。因為討論時，享有特權的人會覺得自己被攻擊、沒有特權的人害怕可能會被報復所以不討論。「享有特權的人討論時覺得自己被攻擊」的原因是他們用個人主義的方式看世界，這看法在美國尤其普遍。個人主義的問題是他們忽略了社會中的現象，除了每個個人之外也受社會中的各種關係影響。社會學要研究森林、樹、樹與樹之間的關係。我們叫我們參與的那廣大一點的世界「社會體系」。家庭、公司都是社會體系的一種。社會體系中的角色不等於佔據那個角色的人，個人主義的角度無法理解這點，所以當我們在討論特權「角色」時，他們會以為我們在攻擊「佔據這個角色的個人」。我們必須理解社會體系不同於我，我也不是社會體系本身。</p>\n<p>社會體系中會有社會規則，形成每個人面對到最小阻力的路。如果只把社會體系的這些規則當作權威，當成人外在的系統，忘了人是社會體系的一部份、社會規則運作需要人配合，就會忘記自己是可以改變社會體系的。</p>\n<p>人參與社會體系會發生什麼事取決於系統本身和運作規則、人在其中的作為。體系影響參與者的想法、感受和行為，靠著就是鋪陳出這些阻力最小的路，雖然任何時刻參與其中的人都有無限多種事可做，但我們通常都不這麼想，只看到體系中很有限的幾個可能性。人也許會同時參與多個體系，然後不同體系中最小阻力的路互相衝突，讓人覺得進退兩難，社會學叫這種情況「角色衝突」</p>\n<p>個人主義對理解社會現象沒有用，因為他只看到人、沒看到社會體系。個人主義沒法解釋，不同社會間同個現象個人的差異(ex: 自殺率)。社會學會問「在 xxx 社會體系中，yyy 會覺得做 zzz 是最小阻力的路的原因是什麼？」靠這個問題來探究比自己範圍更大一點的外在情境。但要注意，我們無法只看人，就理解體系的運作；我們也無法只看體系的運作，就理解人的一舉一動。個人主義的人常會問：「是怎樣的人會做出如此殘暴的事？」。把社會現象簡化為「什麼樣的人」的緣由，忽略這些人所身處的社會體系。</p>\n<p>在社會體系中總是會和最小阻力的路有所牽連，因為即使你不照社會規則走，其他人會照社會規則來對待你。</p>\n<p>社會現象，和參與人有關、又跟他們無關。無關是因為並不是他們創造出這個種族歧視的社會。有關是因為，對於如何參與這種族歧視的社會，人總是還有一些選擇。</p>\n<p>那社會中的人該如何呢？透過社會學我們可以知道，不用為社會問題感到自責，因為這不是我的錯。社會學也讓人了解到如何透過參與這個社會，讓我做的選擇如何影響這個社會體系。</p>\n<p>個人式的解決之道，無法處理社會問題。社會學對改變社會，比起個人式採用更為複雜的模型，同時著眼社會生活的不同層次。透過體系的層次、個人的層次一起看社會問題。</p>\n<p>社會體系影響人，人的行為影響社會體系的運作，就這樣不停循環著。每個人對同個社會體系的理解的、對同個社會體系的心理模型也不同，理解每個人的想法、理解每個體系。這就是社會學要研究的事。</p>\n<p>簡單說：實踐社會學會問兩個問題，「人們參與之中的是什麼？」「人們又如何參與？」兩個問題相互碰撞。本書比較著重第一個問題，對於社會體系的分析。</p>\n<h3 id=\"第二章-文化-—-符號、觀念和生活的種種-p43-p95\"><a href=\"#第二章-文化-—-符號、觀念和生活的種種-p43-p95\" class=\"headerlink\" title=\"第二章 - 文化 — 符號、觀念和生活的種種 p43~p95\"></a>第二章 - 文化 — 符號、觀念和生活的種種 p43~p95</h3><p>人透過詞彙/符號，把感官經驗在心中重新建構一個真實。然後在這個詞彙建構真實的基礎上思考、判斷、做出行為。然而人沒有意識到在心中建構真實時，人也正在選擇。這選擇是一個創造性描述的過程(像是翻譯)，選擇詞彙的同時也就建構出了新的真實。</p>\n<p>詞彙從哪裡來？答案是，我所參與的社會是有文化的，那文化主要包含符號，特別是語言中的詞彙和各種想法。文化同時是物質的，像是社會生活中的「東西」、也是非物質性的，透過符號和想法來思考並且賦予任何事物意義。</p>\n<p>當我們命名一個感官上的東西，例如「雷聲」，在最簡單的意義下，我們藉著對它的感受，創造了與它的關係。如果沒有命名，我們不會注意到它、會被人有限的注意力忽略。我們的注意力只能集中在一小部分上，唯有透過符號命名，我們才能把注意力集中在這些事物上，我們才能建構一個真實。蘇珊.朗格：『用符號去建構真實，是人類之所以能成為人類最重要的關鍵』</p>\n<p>(os: 世界的大小由想像的範圍決定。符號像是 support vector/basis 界定了世界的邊界，用符號把真實投影在心中世界。)</p>\n<p>語言可以建構各式各樣的真實，包括我們沒有感官經驗的真實。像是我們不能聽到、聞到或觸摸到所謂的愛。我們看到他人的行為，但行為本身不是愛，而是我們把它想成：「這行為意味著這個人愛我們。」像是大多數人沒能直接觀察到的「原子」，光是透過語言文字就足夠建構出我們視為的現實。在這個意義下，符號的力量遠遠超過它標示的東西。</p>\n<p>對於同一件事人有不同的理解版本。每個人心中對於每個符號的意義有不同理解。</p>\n<p>每個文化的第一個目的，是提供一種人們可以辨識什麼是真的，什麼是假的方法，這是所謂的信念。在某一意義下，符號是最簡單的信仰陳述，字典的每一個定義就是宣稱某些東西是真實存在的。當文化定義某些是真的，不管實際上是真的還是假的，都會有真實的後果。稱為「顯而易見」的，卻未必是真的，只是在某一特定文化中，被預設為無需懷疑的。(文化中大家都當真的事物…)</p>\n<p>文化中有價值觀。價值滲透到我們生活的每個層面，因為種種價值為我們提供一個方法，以便在很多看起來都相似的事物間做選擇。價值除了影響我們怎麼選擇行動的路線之外，還影響我們怎麼看待、對待我們自己和別人。人常忘了，我們把價值當成真實本身自然而然的一部份，而不把它當成是「關於」社會如何建構真實的想法。除了人的基因中的基本偏好，大多數的偏好是來自於在某一特定文化中經由「社會化」所學來的價值。社會體系的組織方式，決定了價值的選擇。經驗過越多文化，我越意識到自己的文化只是一個文化而已，也看到自己總是從文化所提供的有限可能中選擇。</p>\n<p>作為個人，我可以意識到文化實質存在，並且形塑我們的觀點和經驗，包括我認為我要的是什麼。我唯有藉著把我自己從我身處的文化所提供的狹隘選擇範圍解放出來，才能擴大我的「自由」。要達到這目的，我需要「跨越出」我習慣的文化框架，這樣才能看到我處的文化「框架」，其實只是很多可能的一種。</p>\n<p>價值就像是語法原則，我們用它來解釋從未見過的句子。至於我們怎麼應用那些原則，完全看我們自己。文化中的價值有時會被轉換成規範(norm)，以獎勵和懲罰的「社會後果」來要求人們遵守。若能改變他所參與的「社會體系」，在不同文化規範下就能改變他行動的社會後果。</p>\n<p>為什麼要有規範？功能學派認為每個社會體系都有一些要求，在達到這些要求之後社會體系才能運作。如果沒有規範，社會之中的關係就會被瓦解。這關係主要包含我們對彼此的期望。規範對於界定體系的疆界也很重要，規範告訴我們區別自己人與其他人。最能獲得社群的接受並能形成影響的方法是，從一開始就接受這社群的文化。拒絕接受的話，這文化就不會接受你。</p>\n<p>文化觀念對人們來說是在體系中應該有怎樣的角色。小孩子玩在一起一定要成立「一國」，第一件事是訂定規則，服從的人才能加入。規則本身是什麼不重要，重要的是建立一種比較大的東西，使成員感覺自己是其中一員，同時也讓成員藉此知道自己是誰。法國社會大師涂爾幹把這種集體感覺的「我們」，當成社會生活的基礎，這是唯一可以控制人們行為的方式。這就是道德，體系中一種共同分享的感覺。沒有這集體感覺，人們會失落，社會體系會瓦解。</p>\n<p>所有規範都帶有歸屬和認定的色彩。如果道德是屬於歸屬的問題，那些被視為外人的人，會被當成違反道德準則的偏差者對待，不是因為他們做了什麼，而是因為他們就是他們。在不同形式的社會不平等和壓迫中，這扮演關鍵的角色。</p>\n<p>功能學派的學派的觀點是有了規範社會才能運作。但這個觀點沒法看到的是：規範可以排除和壓迫社會上某些人。我們很難理解為什麼一個需要有這樣的安排，讓其中有些團體取得優勢，而讓其他成員承受痛苦。(價值的方向性？)</p>\n<p>從社會學的衝突觀點來看，比較能理解社會中存在的有系統的排擠、剝削、宰制和濫權。優勢團體會藉著自己的權利和影響去形塑文化以利於自己的利益；包括保護自己的特權。資本主義中有資本的人有權力，他們會形塑一個文化來保護有資本的人，所以在文化中特別強調不是每個文化中有的「私有財產」的概念。價值為影響別種價值，所以看起來只是保護財產的規範，也可能維護者以特權和不平等為基礎的社會秩序。社會生活的每個面向就是：我們在容易直接了解當地看到的連結關係，其實只是冰山一角。整體理解是社會學實踐很重要的面向，能帶我們深入表層，發覺背後關係的連結。</p>\n<p>文化的態度：文化作為感覺。信念、價值觀和規範，對我們如何認識真實，如何思考真實，言行舉止該如何，有很大的影響。他們使我們對人們(ex: 同性戀)有某些感覺。對在這文化中，這類被辨識出來的角色，社會對他們的期待是什麼，有沒有合乎社會要求。這態度主要是感情的(情緒來自大腦邊緣系統的辨識)，也就是說你所感受到的情緒，沒經過大腦思考(前額葉)，就直接受到你所認同的文化態度直接影響。感情、信念和價值的混合體正式文化態度的核心。</p>\n<p>我們建構的真實是非物質的，也是物質的。物質文化之所以存在，是因為人有改變世界的能力。同時也改變了文化、改變了自己。是人改變物質世界、物質世界改變文化、文化改變人的循環。例如，紙張和印刷術的出現，讓社會團體想透過控制它，來控制訊息的傳遞。以前一段時間，要有良民證才能擁有一部打字機。資本主義下越來越有一個趨勢，那就是出版社隸屬於，一個與出版毫無關係的大財團下，以便對觀點的流通進行社會控制。</p>\n<p>一個穩定的社會文化，一定有其存在的原因，相較於其他文化的優勢、特權，能從文化競爭中搶到更多資源。</p>\n<p>社會控制的問題和印刷機器或電視攝影機之類的物質文化的存在與否關係較少，而是和這類物質文化在某一體系中的運用有關。如果我們忽略了物質本身和使用物質的方式，這兩者之間的不同，那我們進一步就會賦予物質文化自己的生命，以為物質文化可以完全支配我們。就像社會體系中角色和佔據角色的人的差別，物質文化中的東西和使用東西的人，是兩個不同的概念。</p>\n<p>物質文化是社會文化的一個重要的部分，對於社會一樣。人也常忘了意識到自己所處的物質文化，也只是眾多物質文化其中之一。人是可以改變物質文化的。</p>\n<p>我們太容易忘記，文化的總體其實是人類豐富潛能想像的產品。哲學家蘇姍朗格寫道：「我們活在觀念的網絡中，編織網絡的纖維是我們自己創造出來的。」我們就好像住在一個由文化建構的小盒子中，不論是在家庭中、在工作場所中，或是社會中都是如此。我們的視野很少能夠超越小盒子，主要的原因是… 我們連這小盒子的存在都不知道。住在盒子裡，我們看不到外面，就以為自己的文化是最好的、是唯一的文化，這就稱為「種族中心主義」。只有意識到盒子的本身，其他可能性才會開啟。</p>\n<p>在複雜社會中，主宰的團體往往用他們建構真實的文化觀念去應用到其他人身上。</p>\n<p>文化可以同時引導我們往兩個方向看。文化可以讓我們往內看，看到我們特殊的文化盒子的有限空間。也可以指向盒子本身，引導我們去想像：我們同時在盒子的裡面和外面。這是個充滿能量的經驗。</p>\n<h3 id=\"第三章-社會生活的結構-p99-p147\"><a href=\"#第三章-社會生活的結構-p99-p147\" class=\"headerlink\" title=\"第三章 - 社會生活的結構 p99~p147\"></a>第三章 - 社會生活的結構 p99~p147</h3><p>和文化一樣，社會結構的概念是一個社會學實踐的重要關鍵，因為它相當程度地決定了社會生活最令人熟悉而且可預期的樣貌。文化概念形塑的我們如何思考、如何感受。結構則將這些文化概念統整到各種連結人與人、人與體系、體系與體系之間的社會關係。</p>\n<p>當我們在生活中經歷了某些戲劇化的變化時，我們會覺得迷失，這是因對我們在一個或多個社會體系中的結構位置改變了。自己的社會位置是什麼，這個問題意味著「我是誰、能做什麼、該做什麼、意義及目標是什麼」。找不到位置的話，也失去了定位體系，這時候我們就會感受到迷失。</p>\n<p>社會結構有兩層意義：第一層意義是關於社會生活各層面中的社會關係是如何安排。第二層意義，社會結構指的是社會體系中各種資源的分配。分配包含每個角色的資源和權力，以及人們在角色位置的分配。</p>\n<p>一個人的「身份地位」就是一個人在體系中所佔據的結構位置；而我們「參與」一個體系的意思就是我們在這個體系中佔據了一個以上的身份地位。在這裡「身份地位」既是位置，也是佔據這個位置的人。請注意這兩者之間的差異，任何人都可以佔據這個身份位置，不管有沒有人佔據，這個身份位置都會存在。</p>\n<p>這種「身份位置」與「佔據此身份位置之個人」之間的區分，對於理解社會生活如何運作有關鍵的意義。如果我們混淆了這兩者的話，我們很可能會犯了企圖用個人因素來解釋社會結構現象的錯誤。</p>\n<p>總統他們只是坐在這個位置上的人。沒有任何一個位置只賦予在位者權利而不同時加諸各種限制的；他們所居的職位和一個巨大的職位結構連在一起，這個結構不僅只有政府內部、也有政府之外的一些位置。這些關係正是限制了總統能做什麼、不能做什麼的因素。</p>\n<p>更複雜的事，我們同時身處於各種體系之中，這表示我們同時具有許多不同的身份。有些身份是我們與生俱來的，像種族、性別、家庭中的身份。有些身份則是我們在人生過程中獲得的：學生、工人、職員、導師、伴侶、博士。不管是先天或後天獲得的身份，也不論我們是不是真的在執行、實踐這些身份，我們都「具有」這些身份。這些「身份」如影隨形，不管是我們自己或是別人，都用這些身份來認識我們。</p>\n<p>還有一些身份是不會隨時跟著我們的，因為他們只存在特定情境之中，像是行人、巴士乘客。情境式的身份必須不斷實踐才能維持，只和我在哪裡、當時在做些什麼事有關。</p>\n<p>佔有某個位置的身份意義是：它讓我們和各個社會體系產生關連，提供了我們經歷、參與這些體系時，一條阻力最小的路。身份提供了一整套的文化概念，這就是我們所稱的「角色」，它會在角色所有人和角色關係人身上加諸全套的信念、價值、態度與規範。</p>\n<p>當一個人的數個角色的價值有所牴觸時，我們稱為角色衝突。像是教授和異性學生的關係，教授會有「老師」和「情人」這兩種角色。從一個結構的觀點來看，老師和學生的性關係是不可能平等的，因為那些決定了他們在體系中的角色，本質上就是不平等的，也沒有辦法被拉平。只要是老師就必然擁有些權力。由於師生戀這種結構角色所會引起的龐大衝突，一個健康的師生戀關係的機率是微乎其微的。這也是為什麼學校和企業都不鼓勵，或明令禁止類似師生戀這種涉及結構權力關係的親密關係。</p>\n<p>人生中很多問題都來自於結構性原因。每個家庭總以為自己是特別的，但卻忘了每個家庭的生活是如此驚人的相似。許多心理治療師不會在沒有見到青少年患者的家人之前治療，因為他們知道個人的問題並不是在真空中發生的。我們的內在情緒生活絕不只侷限於我們的生活世界，他們總是發生在社會脈絡之中。</p>\n<p>在許多相似結構的社會中，同個角色都有一樣的行為。這時看一個人行為時，重點就從「這一個人個別來說，究竟是好人還是壞人」轉移到「他們所參與的體系本身究竟乘載了多少鼓勵這個行為產生的因子」。例如：家庭暴力犯罪者都具有「男性」、「丈夫」或「父親」身份的事實，有多少是受大眾文化不斷地將控制與暴力當作「真正的男子漢」的根本標記，將控制與暴力光榮化影響呢？</p>\n<p>這不是說所有的錯都是社會的問題，而那些家庭暴力施暴者個人都不需要負任何責任。但是要根本改變目前這種家庭暴力行為模式的話，我們必須了解這些家庭暴力模式和阻力最小的路之間的關聯，以及人們如何決定走上這條阻力最小的路。</p>\n<p>資本主義賦予財富高度價值，給你一個價值觀：「擁有某個你現在尚未擁有的東西，幾乎是解決任何問題的答案。」</p>\n<p>社會結構與文化價值，會給角色想要的內容和取得的能力、如果想要的內容大於其被賦予的取得能力，這個角色就會容易陷入困境。當他陷入困境，人會產生一種緊張、衝突感，想解決這個困境。方法一，壓力下合法認真的工作。方法二，放棄文化價值、跟自己說那些沒什麼了不起的。方法三，用非法的手段取得內容。方法四，反叛，挑戰現有制度及其不公平的機會分配。</p>\n<p>價值的分佈，與滿足這些價值的合法機會分佈，兩個落差越大，偏差行為就越可能產生。但這不意味著高犯罪率是因為人們真的是缺乏他們所需要的東西；這意味著高犯罪率是因為人們缺乏那些旁人都有、而且文化價值告訴他們應該有，而他卻沒有的東西。研究顯示，不論城市的所得平均是多少，在民眾收入最不平等的城市裡，竊盜、搶劫案的發生率最高。</p>\n<p>在結構中加入新的角色，社會體系就會劇烈變化。像是生小孩之後的家庭，會發生一些結構現象。</p>\n<p>如果體系中的人知道結構就是設計成這樣子的話，他們可能會覺得好受一點。不會只怪罪於其他人的改變、對他的行為。</p>\n<p>我們可以問，是體系中的哪些互動模式引起了這個社會現象。</p>\n<p>全力是一種不管對方是否同意，權力擁有者都能控制事件、資源與人們能力；權力是一種掌控、強迫、宰制的工具。</p>\n<p>對自己身處的社會體系問下面的問題。例如：家庭究竟是什麼？家庭為什麼重要？一個經濟體系應該為參與其中的人做些什麼？</p>\n<p>類似文化與社會結構的概念，是我們思考社會生活的工具。讓我們聚焦在生活的不同層面上，最後再把這些東西重新拼裝成一個整體。但這個想法會讓我們把他們視為兩個獨立的事物。但兩者從來未曾獨立存在過。</p>\n<p>結構的每一個面向都和文化象徵、文化概念有關。文化影響結構、結構中的人解釋文化，形成因果循環。</p>\n<h3 id=\"第四章-人口與人類生態學\"><a href=\"#第四章-人口與人類生態學\" class=\"headerlink\" title=\"第四章 - 人口與人類生態學\"></a>第四章 - 人口與人類生態學</h3><p>人 - 社會體系 - 物質環境 - 人，循環。</p>\n<h3 id=\"第五章-我們、它和社會互動-p177-p206\"><a href=\"#第五章-我們、它和社會互動-p177-p206\" class=\"headerlink\" title=\"第五章 - 我們、它和社會互動 p177~p206\"></a>第五章 - 我們、它和社會互動 p177~p206</h3><p>嬰兒不能區辨世界與自己兩者的差別；對他們來說，所有事物都是以他們為中心的一個大「整體」。因此嬰兒無法認知他人是獨立存在的、有思有感的個體。嬰兒只是以事物存在的方式去聽去感覺，並不能理解我和事物的關聯，也不知道如何解釋他們。</p>\n<p>米德提出我們是透過發現他人的內心世界，而學會思索自我的。這些認知最初發生於當人們使用語言談論自己、談論我們、談論任何他們經驗到的事實。語言是連結自我經驗和他人經驗的橋樑。藉由發現他人如何經驗自我，我們發現人類自我的可能性。我們開始意識到自己的觀點，我們以為的事實，其實只是一種觀點。之後就可以用思考其他人一樣，使用概念來思考自我。</p>\n<p>自我如同其他建構出來的事實，也是一個建構出來的事實。從文化概念中建構出一個我們是誰的真實。透過角色關係來認識我們的不只是一般人，我們自己主要也是以這種方式來認識自己。</p>\n<p>我們是依賴外在資訊與自我的資訊，去建構自我的概念和感覺的。外在資訊的來源主要以兩種「他人」的形式存在。一種是對我而言的重要他人(Significant others)；他們像是鏡子一般反映出我們的形象，而我們透過鏡中的形象認識自己是誰。生命初期，自我的資訊都來自於家庭成員、玩伴這些重要他人。社會化之後開始能理解「一般他人」。一般他人不是特定的個人或團體，而是我們的觀念，用觀念想像一般人類會怎麼看待某個社會情境和該情境裡所屬的不同身份的人。</p>\n<p>構成一般他人的概念是文化性的，是對身份擁有者的一組概念。</p>\n<p>人們只看我們的外表，就認為他們知道我們所屬的身份；聯想我們是怎樣的人。就這層意義而言，我們不只以文化的意義建構真實，因為真實不論就身份、角色和一般他人而言，也全都受到結構的影響。(作者認為文化和結構是獨立的兩件事、我認為結構是文化一部份…)</p>\n<p>我們是誰，不在於自己本身，而是由我們對社會體系的參與以及學習如何參與的社會化過程來決定的。我是誰？對誰來說？</p>\n<p>沒有了身份和角色，從社會意義上來說，我們就不存在了。這概念並不減低我們作為人的價值；它僅僅意味著我們的存在超越了個體的範圍，個體既不是一切事物的開端，也不是其終點。有些人拒絕任何既定模式而活，反而使他們的行為符合了某種文化模式。</p>\n<p>我們如何參與體系的關鍵在於社會互動這個概念，而社會互動的關鍵在於行動(Action)和舉止(Behavior)的區別。有意義基礎的舉止就是行動；而行動則是我們與他人互動、參與社會體系和社會生活的基石。</p>\n<p>高夫曼：我們就都像舞台上的演員。不停地自我表演、同時也是觀眾。但我們始終都在做我們自己，即使我們不見得能自在坦然地承認自己在扮演的事實，也不喜歡承認自己用表演來影響他人對我們的觀感。這個我和拒絕承認這是「真實的我」的我，兩者都一樣是真實的「我」。</p>\n<p>如果我們沒有辦法不斷意識到我們的自我和我們所參與的社會生活之間的高度複雜性，進而整合我們的各種角色，會是我們因為無知而參與那些會結惡果的社會體系；也會畫地自限，不企圖改變這些惡行。</p>\n<p>我們是電視劇中的角色，有編劇寫得最小阻力的劇情，但不同的是每個演員也有自我意志去選擇人生中的行動。如果我們在劇本是壞人的角色，並不代表我們是壞人。但也不代表我們只能演出壞人。我們和體系文化之間的關係是動態的、鮮活的。我們創造了世界；世界也造就了我們。我們同時是文化的客體與主體。</p>\n<p>我們就像即興性演出的爵士樂手，沒有學過基礎樂理就不會演奏：必須學會分辨升降記號、大小調，會彈奏不同的和弦，還要能容和節拍、旋律和音調… blah blah。樂手必須知道定義和構成爵士樂這種音樂形式的文化符號和概念；知道這些東西如何影響樂手的思考、聆聽與想像途徑。然而，爵士樂手面對音樂時所依循的社些樂理、文化形式，是他們創作的基礎；樂手可以掰紐玩弄這些「規則」，以一種既熟悉(爵士樂、音樂)又創新的方式，挑戰既有限制。</p>\n<p>社會生活和我們的關係，就像爵士樂和爵士樂手們的關係一樣。</p>\n<p>社會互動是由人們創造和維持一個特定的現實感所用的各種方式所構成的。社會互動透過行動和外表來進行。行動和外表互為表裡。</p>\n<p>社會情境是透過社會真實而界定，而這社會真實也只有在人們主動形塑和維持之下才存在。</p>\n<p>我們不斷的用我們對真實如何建構的知識，來理解外界發生了什麼；以及我們該如何扮演我們的角色，讓世界運轉下去。社會中的真實是透過某些模式的社會行動才存在的。這些維持真實的技巧總是一再重複使用，所以往往這些技巧常有儀式性質。像是兩人相愛的親密關係透過，睡前道晚安、吻、掛上電話前說我愛你，等儀式來維持。就像互動儀式中的許多層面，一直要到某方面偏離了這些固定的儀式，我們才會發現這張網上破了一個洞，少掉的那塊就是他們本來應該做、卻沒有照著做的部分。</p>\n<h3 id=\"第六章-實踐社會學，思索未來p207-p238\"><a href=\"#第六章-實踐社會學，思索未來p207-p238\" class=\"headerlink\" title=\"第六章 - 實踐社會學，思索未來p207-p238\"></a>第六章 - 實踐社會學，思索未來p207-p238</h3><p>「我愛你」是一種有意圖的表演式語言(performative language)，第一次說「我愛你」不僅是取悅他人而已，而是一種邀請，一種意圖的表示，想要改變一種社會關係。</p>\n<p>若要解決社會問題，我們一開始就得把問題的社會面看清楚。如果這點沒做到，那麼我們對於社會問題的解釋，就會不正確，對於解決問題的方向也會有偏差。如果分配方式不改變，就算人再努力讓排列順序改變，最有錢的一部份人、和最窮的一部份人分配到的比例還是一樣的，貧窮的問題一樣不會解決。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"書摘的摘要\"><a href=\"#書摘的摘要\" class=\"headerlink\" title=\"書摘的摘要\"></a>書摘的摘要</h3><p>社會學是一種讓你看到社會現象背後，整體樣貌的工具，看清楚後就可以尋求一點一滴的改變方法。</p>\n<p>用個人主義的方式理解世界，將無法理解社會現象。</p>\n<p>社會學中有很多概念工具。社會體系中有文化與結構。社會文化中有符號、信念、價值觀、規範、物質環境。社會結構中有角色、與角色的關係與資源分配。</p>\n<p>「社會文化」是社會學中的一個概念工具。文化中的「符號/概念」限制了你對現實世界的理解，我們處於文化中只能透過符號/概念在心中建構出來的真實理解，如果文化中沒有這概念，就無法理解。文化中的「信念、價值觀與規範」，是人判斷哪個選擇比較好、做或不做的依歸，形塑了社會體系中每個角色最小阻力的路。文化中的「物質環境」，像是電視機、手機、農業、工業社會，都會被文化影響、也會影響文化。人常忘了自己的文化只是眾多文化的一種，透過意識到文化盒子的存在，人可以看到自己社會體系的侷限、也可以想像在不同社會體系的世界會怎樣。</p>\n<p>「社會結構」是社會學中的另一個概念工具。角色有天生的像是性別、後天的像是職業和情境式的像是行人。人同時會參與多個社會體系，在每個社會體系中扮演一個以上的角色。透過角色關係，每個角色有他的權力與限制，有他阻力最小的路。角色位置和佔據角色位置的人是兩個不同的概念，扮演這個角色的人可以決定要不要，這個角色在社會中被期待的方式走。所以理解一個人的行為時要，理解是結構性的原因，還是個人的選擇。每個社會體系會賦予每個「角色位置」，想要的內容(ex: 資本社會：財富)，和獲得這些內容的合法機會。如果想要的和機會相差太大，這個角色就會容易陷入困境，而對社會體系有四種偏差行為，創新、反叛、退縮與脫離。</p>\n<p>人透過行動參與社會體系，社會體系改變現實中的物質環境，物質環境影響人，形成一個循環、這就是人類的生態學。</p>\n<p>自我和其他文化中的概念一樣，只是一個被文化符號建構出來的真實。我們是誰，不在於自己本身，而是由我們對社會體系的參與以及學習如何參與的社會化過程來決定的。</p>\n<p>社會體系就像一齣電視劇，劇本為文化、場景為物質世界、角色為社會體系中的身份。我們就是其中的演員，大多數人從個人主義的視角看世界，忘了我們可以透過挑劇本、挑角色。如果沒有意識到社會體系的盒子，就只能一直演同個劇本、同個角色，嗯 你的演員人生入戲太深就這樣子了。自己現在的劇本、現在的角色是什麼呢？現在扮演的角色、社會體系真的存在嗎？有其他人也參與這個你想像中的社會體系嗎？還是只是你自己以為而已。透過理解社會學去理解你生活中的劇本，好好演出你的人生、改變其他人的人生。</p>\n<p>第一次說「我愛你」不僅是取悅他人而已，而是一種邀請，一種意圖的表示，想要改變一種社會關係。</p>\n<h3 id=\"本書介紹-p1-p7\"><a href=\"#本書介紹-p1-p7\" class=\"headerlink\" title=\"本書介紹 p1~p7\"></a>本書介紹 p1~p7</h3><p>社會學存在的理由是我們身處的社會中總有一些無所謂的苦難的現象。碰到這個時候，我們會問：「為什麼會這樣？」這時社會學成為找到這問題答案的一個工具，幫助我們理解事情如何相互牽連，看清楚後，也就能尋求一點一滴的改變方法。社會學無法讓你全盤理解整個世界，但可以思辨如何參與在生活中的環境，像是社區、家庭和公司。</p>\n<p>社會學提供的是一種有系統的思考方式。實踐社會學，使得我們觀察、思索、理解這個世界，改變這個我們身處其中的世界。社會學中有很多理論，都由社會學的本質核心觀念而來。這本書不介紹一大堆理論和專有名詞，但會介紹這個核心觀念，讓人能從社會學的角度來看這個世界。</p>\n<h3 id=\"第一章-森林、樹群，還有那件事-p8-p42\"><a href=\"#第一章-森林、樹群，還有那件事-p8-p42\" class=\"headerlink\" title=\"第一章 - 森林、樹群，還有那件事 p8~p42\"></a>第一章 - 森林、樹群，還有那件事 p8~p42</h3><p>多元的社會中的差異會形成特權的基礎，不平等持續的現象，是因為大家都不願意討論特權。因為討論時，享有特權的人會覺得自己被攻擊、沒有特權的人害怕可能會被報復所以不討論。「享有特權的人討論時覺得自己被攻擊」的原因是他們用個人主義的方式看世界，這看法在美國尤其普遍。個人主義的問題是他們忽略了社會中的現象，除了每個個人之外也受社會中的各種關係影響。社會學要研究森林、樹、樹與樹之間的關係。我們叫我們參與的那廣大一點的世界「社會體系」。家庭、公司都是社會體系的一種。社會體系中的角色不等於佔據那個角色的人，個人主義的角度無法理解這點，所以當我們在討論特權「角色」時，他們會以為我們在攻擊「佔據這個角色的個人」。我們必須理解社會體系不同於我，我也不是社會體系本身。</p>\n<p>社會體系中會有社會規則，形成每個人面對到最小阻力的路。如果只把社會體系的這些規則當作權威，當成人外在的系統，忘了人是社會體系的一部份、社會規則運作需要人配合，就會忘記自己是可以改變社會體系的。</p>\n<p>人參與社會體系會發生什麼事取決於系統本身和運作規則、人在其中的作為。體系影響參與者的想法、感受和行為，靠著就是鋪陳出這些阻力最小的路，雖然任何時刻參與其中的人都有無限多種事可做，但我們通常都不這麼想，只看到體系中很有限的幾個可能性。人也許會同時參與多個體系，然後不同體系中最小阻力的路互相衝突，讓人覺得進退兩難，社會學叫這種情況「角色衝突」</p>\n<p>個人主義對理解社會現象沒有用，因為他只看到人、沒看到社會體系。個人主義沒法解釋，不同社會間同個現象個人的差異(ex: 自殺率)。社會學會問「在 xxx 社會體系中，yyy 會覺得做 zzz 是最小阻力的路的原因是什麼？」靠這個問題來探究比自己範圍更大一點的外在情境。但要注意，我們無法只看人，就理解體系的運作；我們也無法只看體系的運作，就理解人的一舉一動。個人主義的人常會問：「是怎樣的人會做出如此殘暴的事？」。把社會現象簡化為「什麼樣的人」的緣由，忽略這些人所身處的社會體系。</p>\n<p>在社會體系中總是會和最小阻力的路有所牽連，因為即使你不照社會規則走，其他人會照社會規則來對待你。</p>\n<p>社會現象，和參與人有關、又跟他們無關。無關是因為並不是他們創造出這個種族歧視的社會。有關是因為，對於如何參與這種族歧視的社會，人總是還有一些選擇。</p>\n<p>那社會中的人該如何呢？透過社會學我們可以知道，不用為社會問題感到自責，因為這不是我的錯。社會學也讓人了解到如何透過參與這個社會，讓我做的選擇如何影響這個社會體系。</p>\n<p>個人式的解決之道，無法處理社會問題。社會學對改變社會，比起個人式採用更為複雜的模型，同時著眼社會生活的不同層次。透過體系的層次、個人的層次一起看社會問題。</p>\n<p>社會體系影響人，人的行為影響社會體系的運作，就這樣不停循環著。每個人對同個社會體系的理解的、對同個社會體系的心理模型也不同，理解每個人的想法、理解每個體系。這就是社會學要研究的事。</p>\n<p>簡單說：實踐社會學會問兩個問題，「人們參與之中的是什麼？」「人們又如何參與？」兩個問題相互碰撞。本書比較著重第一個問題，對於社會體系的分析。</p>\n<h3 id=\"第二章-文化-—-符號、觀念和生活的種種-p43-p95\"><a href=\"#第二章-文化-—-符號、觀念和生活的種種-p43-p95\" class=\"headerlink\" title=\"第二章 - 文化 — 符號、觀念和生活的種種 p43~p95\"></a>第二章 - 文化 — 符號、觀念和生活的種種 p43~p95</h3><p>人透過詞彙/符號，把感官經驗在心中重新建構一個真實。然後在這個詞彙建構真實的基礎上思考、判斷、做出行為。然而人沒有意識到在心中建構真實時，人也正在選擇。這選擇是一個創造性描述的過程(像是翻譯)，選擇詞彙的同時也就建構出了新的真實。</p>\n<p>詞彙從哪裡來？答案是，我所參與的社會是有文化的，那文化主要包含符號，特別是語言中的詞彙和各種想法。文化同時是物質的，像是社會生活中的「東西」、也是非物質性的，透過符號和想法來思考並且賦予任何事物意義。</p>\n<p>當我們命名一個感官上的東西，例如「雷聲」，在最簡單的意義下，我們藉著對它的感受，創造了與它的關係。如果沒有命名，我們不會注意到它、會被人有限的注意力忽略。我們的注意力只能集中在一小部分上，唯有透過符號命名，我們才能把注意力集中在這些事物上，我們才能建構一個真實。蘇珊.朗格：『用符號去建構真實，是人類之所以能成為人類最重要的關鍵』</p>\n<p>(os: 世界的大小由想像的範圍決定。符號像是 support vector/basis 界定了世界的邊界，用符號把真實投影在心中世界。)</p>\n<p>語言可以建構各式各樣的真實，包括我們沒有感官經驗的真實。像是我們不能聽到、聞到或觸摸到所謂的愛。我們看到他人的行為，但行為本身不是愛，而是我們把它想成：「這行為意味著這個人愛我們。」像是大多數人沒能直接觀察到的「原子」，光是透過語言文字就足夠建構出我們視為的現實。在這個意義下，符號的力量遠遠超過它標示的東西。</p>\n<p>對於同一件事人有不同的理解版本。每個人心中對於每個符號的意義有不同理解。</p>\n<p>每個文化的第一個目的，是提供一種人們可以辨識什麼是真的，什麼是假的方法，這是所謂的信念。在某一意義下，符號是最簡單的信仰陳述，字典的每一個定義就是宣稱某些東西是真實存在的。當文化定義某些是真的，不管實際上是真的還是假的，都會有真實的後果。稱為「顯而易見」的，卻未必是真的，只是在某一特定文化中，被預設為無需懷疑的。(文化中大家都當真的事物…)</p>\n<p>文化中有價值觀。價值滲透到我們生活的每個層面，因為種種價值為我們提供一個方法，以便在很多看起來都相似的事物間做選擇。價值除了影響我們怎麼選擇行動的路線之外，還影響我們怎麼看待、對待我們自己和別人。人常忘了，我們把價值當成真實本身自然而然的一部份，而不把它當成是「關於」社會如何建構真實的想法。除了人的基因中的基本偏好，大多數的偏好是來自於在某一特定文化中經由「社會化」所學來的價值。社會體系的組織方式，決定了價值的選擇。經驗過越多文化，我越意識到自己的文化只是一個文化而已，也看到自己總是從文化所提供的有限可能中選擇。</p>\n<p>作為個人，我可以意識到文化實質存在，並且形塑我們的觀點和經驗，包括我認為我要的是什麼。我唯有藉著把我自己從我身處的文化所提供的狹隘選擇範圍解放出來，才能擴大我的「自由」。要達到這目的，我需要「跨越出」我習慣的文化框架，這樣才能看到我處的文化「框架」，其實只是很多可能的一種。</p>\n<p>價值就像是語法原則，我們用它來解釋從未見過的句子。至於我們怎麼應用那些原則，完全看我們自己。文化中的價值有時會被轉換成規範(norm)，以獎勵和懲罰的「社會後果」來要求人們遵守。若能改變他所參與的「社會體系」，在不同文化規範下就能改變他行動的社會後果。</p>\n<p>為什麼要有規範？功能學派認為每個社會體系都有一些要求，在達到這些要求之後社會體系才能運作。如果沒有規範，社會之中的關係就會被瓦解。這關係主要包含我們對彼此的期望。規範對於界定體系的疆界也很重要，規範告訴我們區別自己人與其他人。最能獲得社群的接受並能形成影響的方法是，從一開始就接受這社群的文化。拒絕接受的話，這文化就不會接受你。</p>\n<p>文化觀念對人們來說是在體系中應該有怎樣的角色。小孩子玩在一起一定要成立「一國」，第一件事是訂定規則，服從的人才能加入。規則本身是什麼不重要，重要的是建立一種比較大的東西，使成員感覺自己是其中一員，同時也讓成員藉此知道自己是誰。法國社會大師涂爾幹把這種集體感覺的「我們」，當成社會生活的基礎，這是唯一可以控制人們行為的方式。這就是道德，體系中一種共同分享的感覺。沒有這集體感覺，人們會失落，社會體系會瓦解。</p>\n<p>所有規範都帶有歸屬和認定的色彩。如果道德是屬於歸屬的問題，那些被視為外人的人，會被當成違反道德準則的偏差者對待，不是因為他們做了什麼，而是因為他們就是他們。在不同形式的社會不平等和壓迫中，這扮演關鍵的角色。</p>\n<p>功能學派的學派的觀點是有了規範社會才能運作。但這個觀點沒法看到的是：規範可以排除和壓迫社會上某些人。我們很難理解為什麼一個需要有這樣的安排，讓其中有些團體取得優勢，而讓其他成員承受痛苦。(價值的方向性？)</p>\n<p>從社會學的衝突觀點來看，比較能理解社會中存在的有系統的排擠、剝削、宰制和濫權。優勢團體會藉著自己的權利和影響去形塑文化以利於自己的利益；包括保護自己的特權。資本主義中有資本的人有權力，他們會形塑一個文化來保護有資本的人，所以在文化中特別強調不是每個文化中有的「私有財產」的概念。價值為影響別種價值，所以看起來只是保護財產的規範，也可能維護者以特權和不平等為基礎的社會秩序。社會生活的每個面向就是：我們在容易直接了解當地看到的連結關係，其實只是冰山一角。整體理解是社會學實踐很重要的面向，能帶我們深入表層，發覺背後關係的連結。</p>\n<p>文化的態度：文化作為感覺。信念、價值觀和規範，對我們如何認識真實，如何思考真實，言行舉止該如何，有很大的影響。他們使我們對人們(ex: 同性戀)有某些感覺。對在這文化中，這類被辨識出來的角色，社會對他們的期待是什麼，有沒有合乎社會要求。這態度主要是感情的(情緒來自大腦邊緣系統的辨識)，也就是說你所感受到的情緒，沒經過大腦思考(前額葉)，就直接受到你所認同的文化態度直接影響。感情、信念和價值的混合體正式文化態度的核心。</p>\n<p>我們建構的真實是非物質的，也是物質的。物質文化之所以存在，是因為人有改變世界的能力。同時也改變了文化、改變了自己。是人改變物質世界、物質世界改變文化、文化改變人的循環。例如，紙張和印刷術的出現，讓社會團體想透過控制它，來控制訊息的傳遞。以前一段時間，要有良民證才能擁有一部打字機。資本主義下越來越有一個趨勢，那就是出版社隸屬於，一個與出版毫無關係的大財團下，以便對觀點的流通進行社會控制。</p>\n<p>一個穩定的社會文化，一定有其存在的原因，相較於其他文化的優勢、特權，能從文化競爭中搶到更多資源。</p>\n<p>社會控制的問題和印刷機器或電視攝影機之類的物質文化的存在與否關係較少，而是和這類物質文化在某一體系中的運用有關。如果我們忽略了物質本身和使用物質的方式，這兩者之間的不同，那我們進一步就會賦予物質文化自己的生命，以為物質文化可以完全支配我們。就像社會體系中角色和佔據角色的人的差別，物質文化中的東西和使用東西的人，是兩個不同的概念。</p>\n<p>物質文化是社會文化的一個重要的部分，對於社會一樣。人也常忘了意識到自己所處的物質文化，也只是眾多物質文化其中之一。人是可以改變物質文化的。</p>\n<p>我們太容易忘記，文化的總體其實是人類豐富潛能想像的產品。哲學家蘇姍朗格寫道：「我們活在觀念的網絡中，編織網絡的纖維是我們自己創造出來的。」我們就好像住在一個由文化建構的小盒子中，不論是在家庭中、在工作場所中，或是社會中都是如此。我們的視野很少能夠超越小盒子，主要的原因是… 我們連這小盒子的存在都不知道。住在盒子裡，我們看不到外面，就以為自己的文化是最好的、是唯一的文化，這就稱為「種族中心主義」。只有意識到盒子的本身，其他可能性才會開啟。</p>\n<p>在複雜社會中，主宰的團體往往用他們建構真實的文化觀念去應用到其他人身上。</p>\n<p>文化可以同時引導我們往兩個方向看。文化可以讓我們往內看，看到我們特殊的文化盒子的有限空間。也可以指向盒子本身，引導我們去想像：我們同時在盒子的裡面和外面。這是個充滿能量的經驗。</p>\n<h3 id=\"第三章-社會生活的結構-p99-p147\"><a href=\"#第三章-社會生活的結構-p99-p147\" class=\"headerlink\" title=\"第三章 - 社會生活的結構 p99~p147\"></a>第三章 - 社會生活的結構 p99~p147</h3><p>和文化一樣，社會結構的概念是一個社會學實踐的重要關鍵，因為它相當程度地決定了社會生活最令人熟悉而且可預期的樣貌。文化概念形塑的我們如何思考、如何感受。結構則將這些文化概念統整到各種連結人與人、人與體系、體系與體系之間的社會關係。</p>\n<p>當我們在生活中經歷了某些戲劇化的變化時，我們會覺得迷失，這是因對我們在一個或多個社會體系中的結構位置改變了。自己的社會位置是什麼，這個問題意味著「我是誰、能做什麼、該做什麼、意義及目標是什麼」。找不到位置的話，也失去了定位體系，這時候我們就會感受到迷失。</p>\n<p>社會結構有兩層意義：第一層意義是關於社會生活各層面中的社會關係是如何安排。第二層意義，社會結構指的是社會體系中各種資源的分配。分配包含每個角色的資源和權力，以及人們在角色位置的分配。</p>\n<p>一個人的「身份地位」就是一個人在體系中所佔據的結構位置；而我們「參與」一個體系的意思就是我們在這個體系中佔據了一個以上的身份地位。在這裡「身份地位」既是位置，也是佔據這個位置的人。請注意這兩者之間的差異，任何人都可以佔據這個身份位置，不管有沒有人佔據，這個身份位置都會存在。</p>\n<p>這種「身份位置」與「佔據此身份位置之個人」之間的區分，對於理解社會生活如何運作有關鍵的意義。如果我們混淆了這兩者的話，我們很可能會犯了企圖用個人因素來解釋社會結構現象的錯誤。</p>\n<p>總統他們只是坐在這個位置上的人。沒有任何一個位置只賦予在位者權利而不同時加諸各種限制的；他們所居的職位和一個巨大的職位結構連在一起，這個結構不僅只有政府內部、也有政府之外的一些位置。這些關係正是限制了總統能做什麼、不能做什麼的因素。</p>\n<p>更複雜的事，我們同時身處於各種體系之中，這表示我們同時具有許多不同的身份。有些身份是我們與生俱來的，像種族、性別、家庭中的身份。有些身份則是我們在人生過程中獲得的：學生、工人、職員、導師、伴侶、博士。不管是先天或後天獲得的身份，也不論我們是不是真的在執行、實踐這些身份，我們都「具有」這些身份。這些「身份」如影隨形，不管是我們自己或是別人，都用這些身份來認識我們。</p>\n<p>還有一些身份是不會隨時跟著我們的，因為他們只存在特定情境之中，像是行人、巴士乘客。情境式的身份必須不斷實踐才能維持，只和我在哪裡、當時在做些什麼事有關。</p>\n<p>佔有某個位置的身份意義是：它讓我們和各個社會體系產生關連，提供了我們經歷、參與這些體系時，一條阻力最小的路。身份提供了一整套的文化概念，這就是我們所稱的「角色」，它會在角色所有人和角色關係人身上加諸全套的信念、價值、態度與規範。</p>\n<p>當一個人的數個角色的價值有所牴觸時，我們稱為角色衝突。像是教授和異性學生的關係，教授會有「老師」和「情人」這兩種角色。從一個結構的觀點來看，老師和學生的性關係是不可能平等的，因為那些決定了他們在體系中的角色，本質上就是不平等的，也沒有辦法被拉平。只要是老師就必然擁有些權力。由於師生戀這種結構角色所會引起的龐大衝突，一個健康的師生戀關係的機率是微乎其微的。這也是為什麼學校和企業都不鼓勵，或明令禁止類似師生戀這種涉及結構權力關係的親密關係。</p>\n<p>人生中很多問題都來自於結構性原因。每個家庭總以為自己是特別的，但卻忘了每個家庭的生活是如此驚人的相似。許多心理治療師不會在沒有見到青少年患者的家人之前治療，因為他們知道個人的問題並不是在真空中發生的。我們的內在情緒生活絕不只侷限於我們的生活世界，他們總是發生在社會脈絡之中。</p>\n<p>在許多相似結構的社會中，同個角色都有一樣的行為。這時看一個人行為時，重點就從「這一個人個別來說，究竟是好人還是壞人」轉移到「他們所參與的體系本身究竟乘載了多少鼓勵這個行為產生的因子」。例如：家庭暴力犯罪者都具有「男性」、「丈夫」或「父親」身份的事實，有多少是受大眾文化不斷地將控制與暴力當作「真正的男子漢」的根本標記，將控制與暴力光榮化影響呢？</p>\n<p>這不是說所有的錯都是社會的問題，而那些家庭暴力施暴者個人都不需要負任何責任。但是要根本改變目前這種家庭暴力行為模式的話，我們必須了解這些家庭暴力模式和阻力最小的路之間的關聯，以及人們如何決定走上這條阻力最小的路。</p>\n<p>資本主義賦予財富高度價值，給你一個價值觀：「擁有某個你現在尚未擁有的東西，幾乎是解決任何問題的答案。」</p>\n<p>社會結構與文化價值，會給角色想要的內容和取得的能力、如果想要的內容大於其被賦予的取得能力，這個角色就會容易陷入困境。當他陷入困境，人會產生一種緊張、衝突感，想解決這個困境。方法一，壓力下合法認真的工作。方法二，放棄文化價值、跟自己說那些沒什麼了不起的。方法三，用非法的手段取得內容。方法四，反叛，挑戰現有制度及其不公平的機會分配。</p>\n<p>價值的分佈，與滿足這些價值的合法機會分佈，兩個落差越大，偏差行為就越可能產生。但這不意味著高犯罪率是因為人們真的是缺乏他們所需要的東西；這意味著高犯罪率是因為人們缺乏那些旁人都有、而且文化價值告訴他們應該有，而他卻沒有的東西。研究顯示，不論城市的所得平均是多少，在民眾收入最不平等的城市裡，竊盜、搶劫案的發生率最高。</p>\n<p>在結構中加入新的角色，社會體系就會劇烈變化。像是生小孩之後的家庭，會發生一些結構現象。</p>\n<p>如果體系中的人知道結構就是設計成這樣子的話，他們可能會覺得好受一點。不會只怪罪於其他人的改變、對他的行為。</p>\n<p>我們可以問，是體系中的哪些互動模式引起了這個社會現象。</p>\n<p>全力是一種不管對方是否同意，權力擁有者都能控制事件、資源與人們能力；權力是一種掌控、強迫、宰制的工具。</p>\n<p>對自己身處的社會體系問下面的問題。例如：家庭究竟是什麼？家庭為什麼重要？一個經濟體系應該為參與其中的人做些什麼？</p>\n<p>類似文化與社會結構的概念，是我們思考社會生活的工具。讓我們聚焦在生活的不同層面上，最後再把這些東西重新拼裝成一個整體。但這個想法會讓我們把他們視為兩個獨立的事物。但兩者從來未曾獨立存在過。</p>\n<p>結構的每一個面向都和文化象徵、文化概念有關。文化影響結構、結構中的人解釋文化，形成因果循環。</p>\n<h3 id=\"第四章-人口與人類生態學\"><a href=\"#第四章-人口與人類生態學\" class=\"headerlink\" title=\"第四章 - 人口與人類生態學\"></a>第四章 - 人口與人類生態學</h3><p>人 - 社會體系 - 物質環境 - 人，循環。</p>\n<h3 id=\"第五章-我們、它和社會互動-p177-p206\"><a href=\"#第五章-我們、它和社會互動-p177-p206\" class=\"headerlink\" title=\"第五章 - 我們、它和社會互動 p177~p206\"></a>第五章 - 我們、它和社會互動 p177~p206</h3><p>嬰兒不能區辨世界與自己兩者的差別；對他們來說，所有事物都是以他們為中心的一個大「整體」。因此嬰兒無法認知他人是獨立存在的、有思有感的個體。嬰兒只是以事物存在的方式去聽去感覺，並不能理解我和事物的關聯，也不知道如何解釋他們。</p>\n<p>米德提出我們是透過發現他人的內心世界，而學會思索自我的。這些認知最初發生於當人們使用語言談論自己、談論我們、談論任何他們經驗到的事實。語言是連結自我經驗和他人經驗的橋樑。藉由發現他人如何經驗自我，我們發現人類自我的可能性。我們開始意識到自己的觀點，我們以為的事實，其實只是一種觀點。之後就可以用思考其他人一樣，使用概念來思考自我。</p>\n<p>自我如同其他建構出來的事實，也是一個建構出來的事實。從文化概念中建構出一個我們是誰的真實。透過角色關係來認識我們的不只是一般人，我們自己主要也是以這種方式來認識自己。</p>\n<p>我們是依賴外在資訊與自我的資訊，去建構自我的概念和感覺的。外在資訊的來源主要以兩種「他人」的形式存在。一種是對我而言的重要他人(Significant others)；他們像是鏡子一般反映出我們的形象，而我們透過鏡中的形象認識自己是誰。生命初期，自我的資訊都來自於家庭成員、玩伴這些重要他人。社會化之後開始能理解「一般他人」。一般他人不是特定的個人或團體，而是我們的觀念，用觀念想像一般人類會怎麼看待某個社會情境和該情境裡所屬的不同身份的人。</p>\n<p>構成一般他人的概念是文化性的，是對身份擁有者的一組概念。</p>\n<p>人們只看我們的外表，就認為他們知道我們所屬的身份；聯想我們是怎樣的人。就這層意義而言，我們不只以文化的意義建構真實，因為真實不論就身份、角色和一般他人而言，也全都受到結構的影響。(作者認為文化和結構是獨立的兩件事、我認為結構是文化一部份…)</p>\n<p>我們是誰，不在於自己本身，而是由我們對社會體系的參與以及學習如何參與的社會化過程來決定的。我是誰？對誰來說？</p>\n<p>沒有了身份和角色，從社會意義上來說，我們就不存在了。這概念並不減低我們作為人的價值；它僅僅意味著我們的存在超越了個體的範圍，個體既不是一切事物的開端，也不是其終點。有些人拒絕任何既定模式而活，反而使他們的行為符合了某種文化模式。</p>\n<p>我們如何參與體系的關鍵在於社會互動這個概念，而社會互動的關鍵在於行動(Action)和舉止(Behavior)的區別。有意義基礎的舉止就是行動；而行動則是我們與他人互動、參與社會體系和社會生活的基石。</p>\n<p>高夫曼：我們就都像舞台上的演員。不停地自我表演、同時也是觀眾。但我們始終都在做我們自己，即使我們不見得能自在坦然地承認自己在扮演的事實，也不喜歡承認自己用表演來影響他人對我們的觀感。這個我和拒絕承認這是「真實的我」的我，兩者都一樣是真實的「我」。</p>\n<p>如果我們沒有辦法不斷意識到我們的自我和我們所參與的社會生活之間的高度複雜性，進而整合我們的各種角色，會是我們因為無知而參與那些會結惡果的社會體系；也會畫地自限，不企圖改變這些惡行。</p>\n<p>我們是電視劇中的角色，有編劇寫得最小阻力的劇情，但不同的是每個演員也有自我意志去選擇人生中的行動。如果我們在劇本是壞人的角色，並不代表我們是壞人。但也不代表我們只能演出壞人。我們和體系文化之間的關係是動態的、鮮活的。我們創造了世界；世界也造就了我們。我們同時是文化的客體與主體。</p>\n<p>我們就像即興性演出的爵士樂手，沒有學過基礎樂理就不會演奏：必須學會分辨升降記號、大小調，會彈奏不同的和弦，還要能容和節拍、旋律和音調… blah blah。樂手必須知道定義和構成爵士樂這種音樂形式的文化符號和概念；知道這些東西如何影響樂手的思考、聆聽與想像途徑。然而，爵士樂手面對音樂時所依循的社些樂理、文化形式，是他們創作的基礎；樂手可以掰紐玩弄這些「規則」，以一種既熟悉(爵士樂、音樂)又創新的方式，挑戰既有限制。</p>\n<p>社會生活和我們的關係，就像爵士樂和爵士樂手們的關係一樣。</p>\n<p>社會互動是由人們創造和維持一個特定的現實感所用的各種方式所構成的。社會互動透過行動和外表來進行。行動和外表互為表裡。</p>\n<p>社會情境是透過社會真實而界定，而這社會真實也只有在人們主動形塑和維持之下才存在。</p>\n<p>我們不斷的用我們對真實如何建構的知識，來理解外界發生了什麼；以及我們該如何扮演我們的角色，讓世界運轉下去。社會中的真實是透過某些模式的社會行動才存在的。這些維持真實的技巧總是一再重複使用，所以往往這些技巧常有儀式性質。像是兩人相愛的親密關係透過，睡前道晚安、吻、掛上電話前說我愛你，等儀式來維持。就像互動儀式中的許多層面，一直要到某方面偏離了這些固定的儀式，我們才會發現這張網上破了一個洞，少掉的那塊就是他們本來應該做、卻沒有照著做的部分。</p>\n<h3 id=\"第六章-實踐社會學，思索未來p207-p238\"><a href=\"#第六章-實踐社會學，思索未來p207-p238\" class=\"headerlink\" title=\"第六章 - 實踐社會學，思索未來p207-p238\"></a>第六章 - 實踐社會學，思索未來p207-p238</h3><p>「我愛你」是一種有意圖的表演式語言(performative language)，第一次說「我愛你」不僅是取悅他人而已，而是一種邀請，一種意圖的表示，想要改變一種社會關係。</p>\n<p>若要解決社會問題，我們一開始就得把問題的社會面看清楚。如果這點沒做到，那麼我們對於社會問題的解釋，就會不正確，對於解決問題的方向也會有偏差。如果分配方式不改變，就算人再努力讓排列順序改變，最有錢的一部份人、和最窮的一部份人分配到的比例還是一樣的，貧窮的問題一樣不會解決。</p>\n"},{"title":"資訊架構學是什麼？","date":"2016-04-28T17:22:00.000Z","_content":"\n這邊試著用解構的方式來說明資訊架構 (information architecture) 這門學問。\n\n設計活動就是在某些限制下，生出某個東西來達成某個目的的過程。\n\n所以可以理解「設計資訊架構」的過程中，設計出來的某個東西指是「架構/結構 (architecture / structure)」、而且這個架構的改變對象是「資訊」(information)，接著透過新產生的「資訊互動」達成我們的目的。\n\n簡單說，資訊架構透過設計「結構」、讓人和「資訊」有不同的互動，來達成我們背後期望的目的。\n\n舉例來說：\n```\n1. 程式碼的資訊架構\n結構：檔案命名、目錄名稱、放的位置、如何引用、設計模式\n資訊：程式碼\n目的：讓程式碼容易被理解、容易修改、容易查找、容易維護\n\n2. 網站的資訊架構\n結構：搜尋列、標籤、sitemap、瀏覽列、超連結、分頁...\n資訊：文章、圖片、服務、功能\n目的：讓人能找到想要的資訊、讓購買率上升、讓使用者達成他想做的行為\n\n3. 書本的資訊架構\n結構：段落、內容的順序、章節、標題、註解\n資訊：文字、圖\n目的：讓人更能透過閱讀能理解內容\n\n4. 愛買的資訊架構\n結構：商品走道的規劃、服務台的位置、結帳的位置\n資訊：商品、愛買提供的試吃服務\n目的：賣出更多商品\n\n5. 臥室的資訊架構\n結構：物品的擺放位置 (櫥櫃裡、牆面)\n資訊：物品\n目的：主人想...\n```\n##### 資訊是相對的\n對不同的人，同樣的資料會是不同的資訊；在不同的環境(context)下，同樣的資料會是不同的資訊。資訊不光只有資料、在電腦科學裡，功能/函數也是資訊的一種。\n\n##### 設計的目的是多方向的\n有設計者本身的目的、有對使用者的目的、有對其他關係人的目的。也就是說，只要是跟人相關的活動都要理解這些人想要的是什麼、目標是什麼。和使用者中心設計 (User-Centric Design) 一樣。\n\n##### 設計模式 (Design Pattern / Design Principle)\n只要是設計就會有比較好的設計模式來增加設計的成功率。所以通常我們在資訊架構中所學的就是這些「架構的設計模式」，對不同的資訊、不同的目的、不同的人都會有不同的「架構的設計模式」。評估一個「架構的設計模式」的方式就是觀察資訊擺在這個架構下，資訊到底會有什麼不同，能達到什麼不同互動。\n\n##### 被架構後的資訊\n資訊經過架構後還是資訊，資訊的不同點不外乎就這些：資訊容易不容易「理解、瀏覽、找到、關聯、傳遞、同步、容錯、不失真、記住、更新、處理、新增、刪除...」 根據不同的設計目的，設計不同結構，讓原來的資訊的這些面向變得不同，以達成我們的目的，這就是資訊架構學的使用方法。\n\n##### Domain Knowledge\n架構的設計模式太多了、資訊也太多種類、人也太多種，細節就看相關領域的書吧~ 只是時時記得，有「變動世界的架構」的選項，變動後一切就會變得不一樣。就像 google / facebook，完全改變了人們和資訊的互動方式、產生方式。\n\n##### facebook的資訊架構\n```\n結構：News feed & notification 系統 & 好友列表\n資訊：發文、按讚、分享、加入社群的行為、閱讀時間\n目的：讓世界變得充滿萬惡的讚能量、讓人都只看到自己想看的\n```\n最後說一下，其實設計流程是結構的一種、結構也是資訊的一種，從資訊流動來看世界是不是越來越有趣了呢？下圖是資訊架構和其他領域的關係。\n\n![](https://2.bp.blogspot.com/-i0LfHhueZE0/VyLLxBozfrI/AAAAAAAA4d0/RNN2m0bbHxY1APCUV5Rn-O9d-Th5sV0XwCKgB/s640/IMG_3868.JPG)\n\n在使用者經驗分層中，每層都是息息相關的，如果哪一層壞了，整個就壞了。所以從上圖我們可以知道：要做好資訊架構，我們必須做好設計研究、對內容有了解、對功能有能力去實作；要展現好的資訊架構，我們必須做好互動、介面、資訊、視覺設計，不然光只有好的架構，使用者經驗不會好。所以... 工作的時間到了。\n\n參考：\n\n1\\. Eight Principles of Information Architecture, 2010 - Dan Brown\n\n2\\. Information Architecture 100, 2013 - 長谷川敦士\n\n3\\. The Elements of User Experience, 2010 - Jesse James Garrett\n\n4\\. Information Architecture: blueprints for the web, 2009 - Christina Wodtke and Austin Govella\n","source":"_posts/資訊架構學是什麼？.md","raw":"---\ntitle: 資訊架構學是什麼？\ntags:\n  - IA\n  - information architecture\n  - ux\ndate: 2016-04-29 01:22:00\n---\n\n這邊試著用解構的方式來說明資訊架構 (information architecture) 這門學問。\n\n設計活動就是在某些限制下，生出某個東西來達成某個目的的過程。\n\n所以可以理解「設計資訊架構」的過程中，設計出來的某個東西指是「架構/結構 (architecture / structure)」、而且這個架構的改變對象是「資訊」(information)，接著透過新產生的「資訊互動」達成我們的目的。\n\n簡單說，資訊架構透過設計「結構」、讓人和「資訊」有不同的互動，來達成我們背後期望的目的。\n\n舉例來說：\n```\n1. 程式碼的資訊架構\n結構：檔案命名、目錄名稱、放的位置、如何引用、設計模式\n資訊：程式碼\n目的：讓程式碼容易被理解、容易修改、容易查找、容易維護\n\n2. 網站的資訊架構\n結構：搜尋列、標籤、sitemap、瀏覽列、超連結、分頁...\n資訊：文章、圖片、服務、功能\n目的：讓人能找到想要的資訊、讓購買率上升、讓使用者達成他想做的行為\n\n3. 書本的資訊架構\n結構：段落、內容的順序、章節、標題、註解\n資訊：文字、圖\n目的：讓人更能透過閱讀能理解內容\n\n4. 愛買的資訊架構\n結構：商品走道的規劃、服務台的位置、結帳的位置\n資訊：商品、愛買提供的試吃服務\n目的：賣出更多商品\n\n5. 臥室的資訊架構\n結構：物品的擺放位置 (櫥櫃裡、牆面)\n資訊：物品\n目的：主人想...\n```\n##### 資訊是相對的\n對不同的人，同樣的資料會是不同的資訊；在不同的環境(context)下，同樣的資料會是不同的資訊。資訊不光只有資料、在電腦科學裡，功能/函數也是資訊的一種。\n\n##### 設計的目的是多方向的\n有設計者本身的目的、有對使用者的目的、有對其他關係人的目的。也就是說，只要是跟人相關的活動都要理解這些人想要的是什麼、目標是什麼。和使用者中心設計 (User-Centric Design) 一樣。\n\n##### 設計模式 (Design Pattern / Design Principle)\n只要是設計就會有比較好的設計模式來增加設計的成功率。所以通常我們在資訊架構中所學的就是這些「架構的設計模式」，對不同的資訊、不同的目的、不同的人都會有不同的「架構的設計模式」。評估一個「架構的設計模式」的方式就是觀察資訊擺在這個架構下，資訊到底會有什麼不同，能達到什麼不同互動。\n\n##### 被架構後的資訊\n資訊經過架構後還是資訊，資訊的不同點不外乎就這些：資訊容易不容易「理解、瀏覽、找到、關聯、傳遞、同步、容錯、不失真、記住、更新、處理、新增、刪除...」 根據不同的設計目的，設計不同結構，讓原來的資訊的這些面向變得不同，以達成我們的目的，這就是資訊架構學的使用方法。\n\n##### Domain Knowledge\n架構的設計模式太多了、資訊也太多種類、人也太多種，細節就看相關領域的書吧~ 只是時時記得，有「變動世界的架構」的選項，變動後一切就會變得不一樣。就像 google / facebook，完全改變了人們和資訊的互動方式、產生方式。\n\n##### facebook的資訊架構\n```\n結構：News feed & notification 系統 & 好友列表\n資訊：發文、按讚、分享、加入社群的行為、閱讀時間\n目的：讓世界變得充滿萬惡的讚能量、讓人都只看到自己想看的\n```\n最後說一下，其實設計流程是結構的一種、結構也是資訊的一種，從資訊流動來看世界是不是越來越有趣了呢？下圖是資訊架構和其他領域的關係。\n\n![](https://2.bp.blogspot.com/-i0LfHhueZE0/VyLLxBozfrI/AAAAAAAA4d0/RNN2m0bbHxY1APCUV5Rn-O9d-Th5sV0XwCKgB/s640/IMG_3868.JPG)\n\n在使用者經驗分層中，每層都是息息相關的，如果哪一層壞了，整個就壞了。所以從上圖我們可以知道：要做好資訊架構，我們必須做好設計研究、對內容有了解、對功能有能力去實作；要展現好的資訊架構，我們必須做好互動、介面、資訊、視覺設計，不然光只有好的架構，使用者經驗不會好。所以... 工作的時間到了。\n\n參考：\n\n1\\. Eight Principles of Information Architecture, 2010 - Dan Brown\n\n2\\. Information Architecture 100, 2013 - 長谷川敦士\n\n3\\. The Elements of User Experience, 2010 - Jesse James Garrett\n\n4\\. Information Architecture: blueprints for the web, 2009 - Christina Wodtke and Austin Govella\n","slug":"資訊架構學是什麼？","published":1,"updated":"2017-12-25T02:19:53.078Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjblkzcme001fxq9kry2nna5q","content":"<p>這邊試著用解構的方式來說明資訊架構 (information architecture) 這門學問。</p>\n<p>設計活動就是在某些限制下，生出某個東西來達成某個目的的過程。</p>\n<p>所以可以理解「設計資訊架構」的過程中，設計出來的某個東西指是「架構/結構 (architecture / structure)」、而且這個架構的改變對象是「資訊」(information)，接著透過新產生的「資訊互動」達成我們的目的。</p>\n<p>簡單說，資訊架構透過設計「結構」、讓人和「資訊」有不同的互動，來達成我們背後期望的目的。</p>\n<p>舉例來說：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 程式碼的資訊架構</span><br><span class=\"line\">結構：檔案命名、目錄名稱、放的位置、如何引用、設計模式</span><br><span class=\"line\">資訊：程式碼</span><br><span class=\"line\">目的：讓程式碼容易被理解、容易修改、容易查找、容易維護</span><br><span class=\"line\"></span><br><span class=\"line\">2. 網站的資訊架構</span><br><span class=\"line\">結構：搜尋列、標籤、sitemap、瀏覽列、超連結、分頁...</span><br><span class=\"line\">資訊：文章、圖片、服務、功能</span><br><span class=\"line\">目的：讓人能找到想要的資訊、讓購買率上升、讓使用者達成他想做的行為</span><br><span class=\"line\"></span><br><span class=\"line\">3. 書本的資訊架構</span><br><span class=\"line\">結構：段落、內容的順序、章節、標題、註解</span><br><span class=\"line\">資訊：文字、圖</span><br><span class=\"line\">目的：讓人更能透過閱讀能理解內容</span><br><span class=\"line\"></span><br><span class=\"line\">4. 愛買的資訊架構</span><br><span class=\"line\">結構：商品走道的規劃、服務台的位置、結帳的位置</span><br><span class=\"line\">資訊：商品、愛買提供的試吃服務</span><br><span class=\"line\">目的：賣出更多商品</span><br><span class=\"line\"></span><br><span class=\"line\">5. 臥室的資訊架構</span><br><span class=\"line\">結構：物品的擺放位置 (櫥櫃裡、牆面)</span><br><span class=\"line\">資訊：物品</span><br><span class=\"line\">目的：主人想...</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"資訊是相對的\"><a href=\"#資訊是相對的\" class=\"headerlink\" title=\"資訊是相對的\"></a>資訊是相對的</h5><p>對不同的人，同樣的資料會是不同的資訊；在不同的環境(context)下，同樣的資料會是不同的資訊。資訊不光只有資料、在電腦科學裡，功能/函數也是資訊的一種。</p>\n<h5 id=\"設計的目的是多方向的\"><a href=\"#設計的目的是多方向的\" class=\"headerlink\" title=\"設計的目的是多方向的\"></a>設計的目的是多方向的</h5><p>有設計者本身的目的、有對使用者的目的、有對其他關係人的目的。也就是說，只要是跟人相關的活動都要理解這些人想要的是什麼、目標是什麼。和使用者中心設計 (User-Centric Design) 一樣。</p>\n<h5 id=\"設計模式-Design-Pattern-Design-Principle\"><a href=\"#設計模式-Design-Pattern-Design-Principle\" class=\"headerlink\" title=\"設計模式 (Design Pattern / Design Principle)\"></a>設計模式 (Design Pattern / Design Principle)</h5><p>只要是設計就會有比較好的設計模式來增加設計的成功率。所以通常我們在資訊架構中所學的就是這些「架構的設計模式」，對不同的資訊、不同的目的、不同的人都會有不同的「架構的設計模式」。評估一個「架構的設計模式」的方式就是觀察資訊擺在這個架構下，資訊到底會有什麼不同，能達到什麼不同互動。</p>\n<h5 id=\"被架構後的資訊\"><a href=\"#被架構後的資訊\" class=\"headerlink\" title=\"被架構後的資訊\"></a>被架構後的資訊</h5><p>資訊經過架構後還是資訊，資訊的不同點不外乎就這些：資訊容易不容易「理解、瀏覽、找到、關聯、傳遞、同步、容錯、不失真、記住、更新、處理、新增、刪除…」 根據不同的設計目的，設計不同結構，讓原來的資訊的這些面向變得不同，以達成我們的目的，這就是資訊架構學的使用方法。</p>\n<h5 id=\"Domain-Knowledge\"><a href=\"#Domain-Knowledge\" class=\"headerlink\" title=\"Domain Knowledge\"></a>Domain Knowledge</h5><p>架構的設計模式太多了、資訊也太多種類、人也太多種，細節就看相關領域的書吧~ 只是時時記得，有「變動世界的架構」的選項，變動後一切就會變得不一樣。就像 google / facebook，完全改變了人們和資訊的互動方式、產生方式。</p>\n<h5 id=\"facebook的資訊架構\"><a href=\"#facebook的資訊架構\" class=\"headerlink\" title=\"facebook的資訊架構\"></a>facebook的資訊架構</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">結構：News feed &amp; notification 系統 &amp; 好友列表</span><br><span class=\"line\">資訊：發文、按讚、分享、加入社群的行為、閱讀時間</span><br><span class=\"line\">目的：讓世界變得充滿萬惡的讚能量、讓人都只看到自己想看的</span><br></pre></td></tr></table></figure>\n<p>最後說一下，其實設計流程是結構的一種、結構也是資訊的一種，從資訊流動來看世界是不是越來越有趣了呢？下圖是資訊架構和其他領域的關係。</p>\n<p><img src=\"https://2.bp.blogspot.com/-i0LfHhueZE0/VyLLxBozfrI/AAAAAAAA4d0/RNN2m0bbHxY1APCUV5Rn-O9d-Th5sV0XwCKgB/s640/IMG_3868.JPG\" alt=\"\"></p>\n<p>在使用者經驗分層中，每層都是息息相關的，如果哪一層壞了，整個就壞了。所以從上圖我們可以知道：要做好資訊架構，我們必須做好設計研究、對內容有了解、對功能有能力去實作；要展現好的資訊架構，我們必須做好互動、介面、資訊、視覺設計，不然光只有好的架構，使用者經驗不會好。所以… 工作的時間到了。</p>\n<p>參考：</p>\n<p>1. Eight Principles of Information Architecture, 2010 - Dan Brown</p>\n<p>2. Information Architecture 100, 2013 - 長谷川敦士</p>\n<p>3. The Elements of User Experience, 2010 - Jesse James Garrett</p>\n<p>4. Information Architecture: blueprints for the web, 2009 - Christina Wodtke and Austin Govella</p>\n","site":{"data":{}},"excerpt":"","more":"<p>這邊試著用解構的方式來說明資訊架構 (information architecture) 這門學問。</p>\n<p>設計活動就是在某些限制下，生出某個東西來達成某個目的的過程。</p>\n<p>所以可以理解「設計資訊架構」的過程中，設計出來的某個東西指是「架構/結構 (architecture / structure)」、而且這個架構的改變對象是「資訊」(information)，接著透過新產生的「資訊互動」達成我們的目的。</p>\n<p>簡單說，資訊架構透過設計「結構」、讓人和「資訊」有不同的互動，來達成我們背後期望的目的。</p>\n<p>舉例來說：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 程式碼的資訊架構</span><br><span class=\"line\">結構：檔案命名、目錄名稱、放的位置、如何引用、設計模式</span><br><span class=\"line\">資訊：程式碼</span><br><span class=\"line\">目的：讓程式碼容易被理解、容易修改、容易查找、容易維護</span><br><span class=\"line\"></span><br><span class=\"line\">2. 網站的資訊架構</span><br><span class=\"line\">結構：搜尋列、標籤、sitemap、瀏覽列、超連結、分頁...</span><br><span class=\"line\">資訊：文章、圖片、服務、功能</span><br><span class=\"line\">目的：讓人能找到想要的資訊、讓購買率上升、讓使用者達成他想做的行為</span><br><span class=\"line\"></span><br><span class=\"line\">3. 書本的資訊架構</span><br><span class=\"line\">結構：段落、內容的順序、章節、標題、註解</span><br><span class=\"line\">資訊：文字、圖</span><br><span class=\"line\">目的：讓人更能透過閱讀能理解內容</span><br><span class=\"line\"></span><br><span class=\"line\">4. 愛買的資訊架構</span><br><span class=\"line\">結構：商品走道的規劃、服務台的位置、結帳的位置</span><br><span class=\"line\">資訊：商品、愛買提供的試吃服務</span><br><span class=\"line\">目的：賣出更多商品</span><br><span class=\"line\"></span><br><span class=\"line\">5. 臥室的資訊架構</span><br><span class=\"line\">結構：物品的擺放位置 (櫥櫃裡、牆面)</span><br><span class=\"line\">資訊：物品</span><br><span class=\"line\">目的：主人想...</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"資訊是相對的\"><a href=\"#資訊是相對的\" class=\"headerlink\" title=\"資訊是相對的\"></a>資訊是相對的</h5><p>對不同的人，同樣的資料會是不同的資訊；在不同的環境(context)下，同樣的資料會是不同的資訊。資訊不光只有資料、在電腦科學裡，功能/函數也是資訊的一種。</p>\n<h5 id=\"設計的目的是多方向的\"><a href=\"#設計的目的是多方向的\" class=\"headerlink\" title=\"設計的目的是多方向的\"></a>設計的目的是多方向的</h5><p>有設計者本身的目的、有對使用者的目的、有對其他關係人的目的。也就是說，只要是跟人相關的活動都要理解這些人想要的是什麼、目標是什麼。和使用者中心設計 (User-Centric Design) 一樣。</p>\n<h5 id=\"設計模式-Design-Pattern-Design-Principle\"><a href=\"#設計模式-Design-Pattern-Design-Principle\" class=\"headerlink\" title=\"設計模式 (Design Pattern / Design Principle)\"></a>設計模式 (Design Pattern / Design Principle)</h5><p>只要是設計就會有比較好的設計模式來增加設計的成功率。所以通常我們在資訊架構中所學的就是這些「架構的設計模式」，對不同的資訊、不同的目的、不同的人都會有不同的「架構的設計模式」。評估一個「架構的設計模式」的方式就是觀察資訊擺在這個架構下，資訊到底會有什麼不同，能達到什麼不同互動。</p>\n<h5 id=\"被架構後的資訊\"><a href=\"#被架構後的資訊\" class=\"headerlink\" title=\"被架構後的資訊\"></a>被架構後的資訊</h5><p>資訊經過架構後還是資訊，資訊的不同點不外乎就這些：資訊容易不容易「理解、瀏覽、找到、關聯、傳遞、同步、容錯、不失真、記住、更新、處理、新增、刪除…」 根據不同的設計目的，設計不同結構，讓原來的資訊的這些面向變得不同，以達成我們的目的，這就是資訊架構學的使用方法。</p>\n<h5 id=\"Domain-Knowledge\"><a href=\"#Domain-Knowledge\" class=\"headerlink\" title=\"Domain Knowledge\"></a>Domain Knowledge</h5><p>架構的設計模式太多了、資訊也太多種類、人也太多種，細節就看相關領域的書吧~ 只是時時記得，有「變動世界的架構」的選項，變動後一切就會變得不一樣。就像 google / facebook，完全改變了人們和資訊的互動方式、產生方式。</p>\n<h5 id=\"facebook的資訊架構\"><a href=\"#facebook的資訊架構\" class=\"headerlink\" title=\"facebook的資訊架構\"></a>facebook的資訊架構</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">結構：News feed &amp; notification 系統 &amp; 好友列表</span><br><span class=\"line\">資訊：發文、按讚、分享、加入社群的行為、閱讀時間</span><br><span class=\"line\">目的：讓世界變得充滿萬惡的讚能量、讓人都只看到自己想看的</span><br></pre></td></tr></table></figure>\n<p>最後說一下，其實設計流程是結構的一種、結構也是資訊的一種，從資訊流動來看世界是不是越來越有趣了呢？下圖是資訊架構和其他領域的關係。</p>\n<p><img src=\"https://2.bp.blogspot.com/-i0LfHhueZE0/VyLLxBozfrI/AAAAAAAA4d0/RNN2m0bbHxY1APCUV5Rn-O9d-Th5sV0XwCKgB/s640/IMG_3868.JPG\" alt=\"\"></p>\n<p>在使用者經驗分層中，每層都是息息相關的，如果哪一層壞了，整個就壞了。所以從上圖我們可以知道：要做好資訊架構，我們必須做好設計研究、對內容有了解、對功能有能力去實作；要展現好的資訊架構，我們必須做好互動、介面、資訊、視覺設計，不然光只有好的架構，使用者經驗不會好。所以… 工作的時間到了。</p>\n<p>參考：</p>\n<p>1. Eight Principles of Information Architecture, 2010 - Dan Brown</p>\n<p>2. Information Architecture 100, 2013 - 長谷川敦士</p>\n<p>3. The Elements of User Experience, 2010 - Jesse James Garrett</p>\n<p>4. Information Architecture: blueprints for the web, 2009 - Christina Wodtke and Austin Govella</p>\n"},{"title":"新海誠展 十五年的動畫歷程","date":"2017-12-26T08:22:00.000Z","_content":"\n在新加坡看了「你的名字」、在東京看了「言葉之庭」，在日本喜歡去的地方就是東京新宿御苑、在那裡看著你的名字設定的高中、影片中烏鴉飛過的 NTT DoCoMo 代代木大廈; 言葉之庭的涼亭總是有很多人、因為我總是在晴天的時候去。坐一小時的電車，然後在公園裡鋪上唐吉軻德買的廉價野餐墊、尋找樹蔭、看書、看小朋友奔跑，有時還會繞去人少的千馱谷門逛逛將棋會館，好想買新宿御苑的年間PASS... 扯遠了。\n\n**新海誠** 長野縣出生。是零下十幾度在湖上滑冰看日出、擁有70萬日元電腦的小朋友。國、高中參加過排球部和弓道部，接著跑到東京唸文學系、是建築世家的預定接班人。但他拒絕接班，跟老爸說年輕時有想做的事。2001年就跑去遊戲公司 (Falcom) 做了五年，有名的「英雄傳說系列的 III - V代」他都有參與、主攻美術、動畫、設定之類的。還記得三代的白髮魔女傳好好玩～ 就這樣過著早上6點上班、晚上12點下班的爆肝人生。社畜和「大東京玩具箱」都是真的啊。\n\n在 Falcom 做到第五年的時候就像，村上春樹每天經營的酒吧關門之後寫小說一樣。新海誠12點下班之後開始做動畫「星之聲」到凌晨3點，兩個人都是下班後心中還有創作的渴望，或是說有了再累都不能放棄的夢想，然後才讓這個夢想成真。不過星之聲做一半，他就離職啦～ 閉關工作八個月。\n\n他自幹了一次監督、美術、腳本、作畫... 全包25分鐘的長動畫、太累了，明白了自己適合哪一部分、不適合哪部分，就開始找人一起做了。後來的幾部動畫，「雲之彼端，約定的地方」、「秒速五公分」、「追逐繁星的孩子」、「言葉之庭」和「你的名字」都是和很多人合作的作品，他主要負責原作、腳本、監督。日本文學系、兒童文學繪本社團出生的他，還有寫動畫電影的小說。順帶一提，他在夏天有慢跑習慣、在最近的問答中說現在自己「工作時絕對不熬夜」，每天能專注多久才工作多久。\n\n**新海誠展** 在華山展的內容有從「星之聲」到「你的名字」的動畫製作過程。展場內可以拍照但不能錄影。從文字企劃、分鏡腳本，到人物、場景設定的設定圖像、作畫與修正、合成分鏡圖動畫。都有展出。門票300元。PS: 如果想深入了解動畫產業，強烈建議看 2015年出品、IMDB 8.2 分的動畫「白箱」。\n\n### 動畫製作過程以你的名字舉例\n#### 企劃->分鏡腳本->分鏡腳本動畫->人物、場景設定->原畫\n1. **企劃 (新海誠)**\n  * 概要 (700字)\n  * 故事背景、場景、道具設定 (400字)\n  * 為什麼現在要拍這個故事 (1000字)\n<img src=\"/img/shinhai/1.jpeg\" width=\"360\">\n<img src=\"/img/shinhai/2.jpeg\" width=\"360\">\n<img src=\"/img/shinhai/3.jpeg\" width=\"360\">\n2. **分鏡腳本 (新海誠)**\n  * 分鏡、動作、對話、時間\n  * 分鏡會含畫面走向、人物要加上陰影部分\n  * 分鏡動畫，1700張分鏡、四秒一張 (你的名字藍光有附完整的分鏡影片、新海誠親自配音)\n<img src=\"/img/shinhai/4.jpeg\" width=\"360\">\n<img src=\"/img/shinhai/5_1.jpeg\" width=\"360\">\n3. **角色設定、場景設定 (人設：虎與龍、未聞花名的「田中將賀」)**\n  * 以女主角宮水三葉為例、會有人物的各種角度、長髮短髮、陰影的設定\n  * 另外還會有人物身上的顏色的設計規範\n  * 場景會有遠中近 (系手町、神社附近、三葉的房間)\n  * 每個房間都有設計師先想像好、畫好才開始作畫\n<img src=\"/img/shinhai/5.jpeg\" width=\"360\">\n<img src=\"/img/shinhai/6.jpeg\" width=\"360\">\n<img src=\"/img/shinhai/7.jpeg\" width=\"360\">\n<img src=\"/img/shinhai/8.jpeg\" width=\"360\">\n<img src=\"/img/shinhai/9.jpeg\" width=\"360\">\n4. **作畫 (作畫監督：神隱少女的「安藤雅司」)**\n  * 原畫師對著分鏡腳本畫原畫 (Key Animation)\n  * 動畫師補上原畫間的中間影格\n<img src=\"/img/shinhai/10.jpeg\" width=\"360\">\n<img src=\"/img/shinhai/12.jpeg\" width=\"360\">\n5. **其他**\n  * 音樂、音響、配音、聲優...\n\n### 結語\n展覽中展出每部動畫製作時的部分的企劃、分鏡腳本、人設、原話，可以讓人好好學習如何做一部動畫、寫一個故事。想像，從2014年2000字的文字企劃「若之是夢」怎麼變成2016年100多分鐘的「你的名字」。文字企劃的時候，強調的是靈魂交換、連結(結び)。但沒有提到記憶相關、「你的名字」遺忘的主題。動畫腳本到真正電影之間也省略了不少部分。也不知道在這個企劃，贏了多少胎死腹中的企劃。還有從早期作品到最新的你的名字間的作為一個監督、腳本的成長，這些點都是值得思考玩味的地方。\n\n44歲的新海誠不一樣了。他結婚了、還有一個7歲的女兒。和10年前做「秒速５公分」時，一個人單身、還會做成人遊戲公司(minori) 的動畫、跑去倫敦遊學一年多。他也說311地震之後，日本人需要的東西也不一樣、想做的東西也不一樣了。很期待他下一部會做怎樣的動畫，希望在大紅大紫之後還他能有原來的色彩。\n\nPS: 會日文的朋友推薦買展場的書 (200多頁、1000元)，有所有展出作品的靜態部分、分鏡腳本、原畫、作品分析等。\n\n### 參考資料\n- [新海誠日文wiki](https://ja.wikipedia.org/wiki/新海誠)\n- [映画『君の名は。』公式サイト](http://www.kiminona.com/#interview_ando)\n- [新海誠｜人就是這樣，必須習慣失去](https://www.gigcasa.com/articles/471452)\n- [新海誠導演的世界：渺小的個人與浩瀚的宇宙之關聯](https://www.nippon.com/hk/people/e00107/)\n- [【我用青春換此生】新海誠父親，百年建築公司「新津組」社長談自己兒子新海誠！](http://hkacger.com/archives/30624)\n- [新海誠來中國，聊了聊動畫《你的名字》背後的故事](https://read01.com/2DANER.html#.WkIJFiOKXOR)\n- [新海誠究竟是個怎樣的人](https://read01.com/ERK2R2.html#.WkIJNSOKXOR)\n- [新海誠：十四年，專注製造少女心](https://read01.com/QRGaMA.html#.WkIJTSOKXOR)\n","source":"_posts/新海誠展-十五年動畫歷程.md","raw":"---\ntitle: 新海誠展 十五年的動畫歷程\ntags:\n  - ACGN\n  - 分鏡\ndate: 2017-12-26 16:22:00\n---\n\n在新加坡看了「你的名字」、在東京看了「言葉之庭」，在日本喜歡去的地方就是東京新宿御苑、在那裡看著你的名字設定的高中、影片中烏鴉飛過的 NTT DoCoMo 代代木大廈; 言葉之庭的涼亭總是有很多人、因為我總是在晴天的時候去。坐一小時的電車，然後在公園裡鋪上唐吉軻德買的廉價野餐墊、尋找樹蔭、看書、看小朋友奔跑，有時還會繞去人少的千馱谷門逛逛將棋會館，好想買新宿御苑的年間PASS... 扯遠了。\n\n**新海誠** 長野縣出生。是零下十幾度在湖上滑冰看日出、擁有70萬日元電腦的小朋友。國、高中參加過排球部和弓道部，接著跑到東京唸文學系、是建築世家的預定接班人。但他拒絕接班，跟老爸說年輕時有想做的事。2001年就跑去遊戲公司 (Falcom) 做了五年，有名的「英雄傳說系列的 III - V代」他都有參與、主攻美術、動畫、設定之類的。還記得三代的白髮魔女傳好好玩～ 就這樣過著早上6點上班、晚上12點下班的爆肝人生。社畜和「大東京玩具箱」都是真的啊。\n\n在 Falcom 做到第五年的時候就像，村上春樹每天經營的酒吧關門之後寫小說一樣。新海誠12點下班之後開始做動畫「星之聲」到凌晨3點，兩個人都是下班後心中還有創作的渴望，或是說有了再累都不能放棄的夢想，然後才讓這個夢想成真。不過星之聲做一半，他就離職啦～ 閉關工作八個月。\n\n他自幹了一次監督、美術、腳本、作畫... 全包25分鐘的長動畫、太累了，明白了自己適合哪一部分、不適合哪部分，就開始找人一起做了。後來的幾部動畫，「雲之彼端，約定的地方」、「秒速五公分」、「追逐繁星的孩子」、「言葉之庭」和「你的名字」都是和很多人合作的作品，他主要負責原作、腳本、監督。日本文學系、兒童文學繪本社團出生的他，還有寫動畫電影的小說。順帶一提，他在夏天有慢跑習慣、在最近的問答中說現在自己「工作時絕對不熬夜」，每天能專注多久才工作多久。\n\n**新海誠展** 在華山展的內容有從「星之聲」到「你的名字」的動畫製作過程。展場內可以拍照但不能錄影。從文字企劃、分鏡腳本，到人物、場景設定的設定圖像、作畫與修正、合成分鏡圖動畫。都有展出。門票300元。PS: 如果想深入了解動畫產業，強烈建議看 2015年出品、IMDB 8.2 分的動畫「白箱」。\n\n### 動畫製作過程以你的名字舉例\n#### 企劃->分鏡腳本->分鏡腳本動畫->人物、場景設定->原畫\n1. **企劃 (新海誠)**\n  * 概要 (700字)\n  * 故事背景、場景、道具設定 (400字)\n  * 為什麼現在要拍這個故事 (1000字)\n<img src=\"/img/shinhai/1.jpeg\" width=\"360\">\n<img src=\"/img/shinhai/2.jpeg\" width=\"360\">\n<img src=\"/img/shinhai/3.jpeg\" width=\"360\">\n2. **分鏡腳本 (新海誠)**\n  * 分鏡、動作、對話、時間\n  * 分鏡會含畫面走向、人物要加上陰影部分\n  * 分鏡動畫，1700張分鏡、四秒一張 (你的名字藍光有附完整的分鏡影片、新海誠親自配音)\n<img src=\"/img/shinhai/4.jpeg\" width=\"360\">\n<img src=\"/img/shinhai/5_1.jpeg\" width=\"360\">\n3. **角色設定、場景設定 (人設：虎與龍、未聞花名的「田中將賀」)**\n  * 以女主角宮水三葉為例、會有人物的各種角度、長髮短髮、陰影的設定\n  * 另外還會有人物身上的顏色的設計規範\n  * 場景會有遠中近 (系手町、神社附近、三葉的房間)\n  * 每個房間都有設計師先想像好、畫好才開始作畫\n<img src=\"/img/shinhai/5.jpeg\" width=\"360\">\n<img src=\"/img/shinhai/6.jpeg\" width=\"360\">\n<img src=\"/img/shinhai/7.jpeg\" width=\"360\">\n<img src=\"/img/shinhai/8.jpeg\" width=\"360\">\n<img src=\"/img/shinhai/9.jpeg\" width=\"360\">\n4. **作畫 (作畫監督：神隱少女的「安藤雅司」)**\n  * 原畫師對著分鏡腳本畫原畫 (Key Animation)\n  * 動畫師補上原畫間的中間影格\n<img src=\"/img/shinhai/10.jpeg\" width=\"360\">\n<img src=\"/img/shinhai/12.jpeg\" width=\"360\">\n5. **其他**\n  * 音樂、音響、配音、聲優...\n\n### 結語\n展覽中展出每部動畫製作時的部分的企劃、分鏡腳本、人設、原話，可以讓人好好學習如何做一部動畫、寫一個故事。想像，從2014年2000字的文字企劃「若之是夢」怎麼變成2016年100多分鐘的「你的名字」。文字企劃的時候，強調的是靈魂交換、連結(結び)。但沒有提到記憶相關、「你的名字」遺忘的主題。動畫腳本到真正電影之間也省略了不少部分。也不知道在這個企劃，贏了多少胎死腹中的企劃。還有從早期作品到最新的你的名字間的作為一個監督、腳本的成長，這些點都是值得思考玩味的地方。\n\n44歲的新海誠不一樣了。他結婚了、還有一個7歲的女兒。和10年前做「秒速５公分」時，一個人單身、還會做成人遊戲公司(minori) 的動畫、跑去倫敦遊學一年多。他也說311地震之後，日本人需要的東西也不一樣、想做的東西也不一樣了。很期待他下一部會做怎樣的動畫，希望在大紅大紫之後還他能有原來的色彩。\n\nPS: 會日文的朋友推薦買展場的書 (200多頁、1000元)，有所有展出作品的靜態部分、分鏡腳本、原畫、作品分析等。\n\n### 參考資料\n- [新海誠日文wiki](https://ja.wikipedia.org/wiki/新海誠)\n- [映画『君の名は。』公式サイト](http://www.kiminona.com/#interview_ando)\n- [新海誠｜人就是這樣，必須習慣失去](https://www.gigcasa.com/articles/471452)\n- [新海誠導演的世界：渺小的個人與浩瀚的宇宙之關聯](https://www.nippon.com/hk/people/e00107/)\n- [【我用青春換此生】新海誠父親，百年建築公司「新津組」社長談自己兒子新海誠！](http://hkacger.com/archives/30624)\n- [新海誠來中國，聊了聊動畫《你的名字》背後的故事](https://read01.com/2DANER.html#.WkIJFiOKXOR)\n- [新海誠究竟是個怎樣的人](https://read01.com/ERK2R2.html#.WkIJNSOKXOR)\n- [新海誠：十四年，專注製造少女心](https://read01.com/QRGaMA.html#.WkIJTSOKXOR)\n","slug":"新海誠展-十五年動畫歷程","published":1,"updated":"2017-12-27T01:17:07.740Z","_id":"cjbnd5mnz0000kv9k6nn3m0gc","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在新加坡看了「你的名字」、在東京看了「言葉之庭」，在日本喜歡去的地方就是東京新宿御苑、在那裡看著你的名字設定的高中、影片中烏鴉飛過的 NTT DoCoMo 代代木大廈; 言葉之庭的涼亭總是有很多人、因為我總是在晴天的時候去。坐一小時的電車，然後在公園裡鋪上唐吉軻德買的廉價野餐墊、尋找樹蔭、看書、看小朋友奔跑，有時還會繞去人少的千馱谷門逛逛將棋會館，好想買新宿御苑的年間PASS… 扯遠了。</p>\n<p><strong>新海誠</strong> 長野縣出生。是零下十幾度在湖上滑冰看日出、擁有70萬日元電腦的小朋友。國、高中參加過排球部和弓道部，接著跑到東京唸文學系、是建築世家的預定接班人。但他拒絕接班，跟老爸說年輕時有想做的事。2001年就跑去遊戲公司 (Falcom) 做了五年，有名的「英雄傳說系列的 III - V代」他都有參與、主攻美術、動畫、設定之類的。還記得三代的白髮魔女傳好好玩～ 就這樣過著早上6點上班、晚上12點下班的爆肝人生。社畜和「大東京玩具箱」都是真的啊。</p>\n<p>在 Falcom 做到第五年的時候就像，村上春樹每天經營的酒吧關門之後寫小說一樣。新海誠12點下班之後開始做動畫「星之聲」到凌晨3點，兩個人都是下班後心中還有創作的渴望，或是說有了再累都不能放棄的夢想，然後才讓這個夢想成真。不過星之聲做一半，他就離職啦～ 閉關工作八個月。</p>\n<p>他自幹了一次監督、美術、腳本、作畫… 全包25分鐘的長動畫、太累了，明白了自己適合哪一部分、不適合哪部分，就開始找人一起做了。後來的幾部動畫，「雲之彼端，約定的地方」、「秒速五公分」、「追逐繁星的孩子」、「言葉之庭」和「你的名字」都是和很多人合作的作品，他主要負責原作、腳本、監督。日本文學系、兒童文學繪本社團出生的他，還有寫動畫電影的小說。順帶一提，他在夏天有慢跑習慣、在最近的問答中說現在自己「工作時絕對不熬夜」，每天能專注多久才工作多久。</p>\n<p><strong>新海誠展</strong> 在華山展的內容有從「星之聲」到「你的名字」的動畫製作過程。展場內可以拍照但不能錄影。從文字企劃、分鏡腳本，到人物、場景設定的設定圖像、作畫與修正、合成分鏡圖動畫。都有展出。門票300元。PS: 如果想深入了解動畫產業，強烈建議看 2015年出品、IMDB 8.2 分的動畫「白箱」。</p>\n<h3 id=\"動畫製作過程以你的名字舉例\"><a href=\"#動畫製作過程以你的名字舉例\" class=\"headerlink\" title=\"動畫製作過程以你的名字舉例\"></a>動畫製作過程以你的名字舉例</h3><h4 id=\"企劃-gt-分鏡腳本-gt-分鏡腳本動畫-gt-人物、場景設定-gt-原畫\"><a href=\"#企劃-gt-分鏡腳本-gt-分鏡腳本動畫-gt-人物、場景設定-gt-原畫\" class=\"headerlink\" title=\"企劃-&gt;分鏡腳本-&gt;分鏡腳本動畫-&gt;人物、場景設定-&gt;原畫\"></a>企劃-&gt;分鏡腳本-&gt;分鏡腳本動畫-&gt;人物、場景設定-&gt;原畫</h4><ol>\n<li><strong>企劃 (新海誠)</strong><ul>\n<li>概要 (700字)</li>\n<li>故事背景、場景、道具設定 (400字)</li>\n<li>為什麼現在要拍這個故事 (1000字)<br><img src=\"/img/shinhai/1.jpeg\" width=\"360\"><br><img src=\"/img/shinhai/2.jpeg\" width=\"360\"><br><img src=\"/img/shinhai/3.jpeg\" width=\"360\"></li>\n</ul>\n</li>\n<li><strong>分鏡腳本 (新海誠)</strong><ul>\n<li>分鏡、動作、對話、時間</li>\n<li>分鏡會含畫面走向、人物要加上陰影部分</li>\n<li>分鏡動畫，1700張分鏡、四秒一張 (你的名字藍光有附完整的分鏡影片、新海誠親自配音)<br><img src=\"/img/shinhai/4.jpeg\" width=\"360\"><br><img src=\"/img/shinhai/5_1.jpeg\" width=\"360\"></li>\n</ul>\n</li>\n<li><strong>角色設定、場景設定 (人設：虎與龍、未聞花名的「田中將賀」)</strong><ul>\n<li>以女主角宮水三葉為例、會有人物的各種角度、長髮短髮、陰影的設定</li>\n<li>另外還會有人物身上的顏色的設計規範</li>\n<li>場景會有遠中近 (系手町、神社附近、三葉的房間)</li>\n<li>每個房間都有設計師先想像好、畫好才開始作畫<br><img src=\"/img/shinhai/5.jpeg\" width=\"360\"><br><img src=\"/img/shinhai/6.jpeg\" width=\"360\"><br><img src=\"/img/shinhai/7.jpeg\" width=\"360\"><br><img src=\"/img/shinhai/8.jpeg\" width=\"360\"><br><img src=\"/img/shinhai/9.jpeg\" width=\"360\"></li>\n</ul>\n</li>\n<li><strong>作畫 (作畫監督：神隱少女的「安藤雅司」)</strong><ul>\n<li>原畫師對著分鏡腳本畫原畫 (Key Animation)</li>\n<li>動畫師補上原畫間的中間影格<br><img src=\"/img/shinhai/10.jpeg\" width=\"360\"><br><img src=\"/img/shinhai/12.jpeg\" width=\"360\"></li>\n</ul>\n</li>\n<li><strong>其他</strong><ul>\n<li>音樂、音響、配音、聲優…</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"結語\"><a href=\"#結語\" class=\"headerlink\" title=\"結語\"></a>結語</h3><p>展覽中展出每部動畫製作時的部分的企劃、分鏡腳本、人設、原話，可以讓人好好學習如何做一部動畫、寫一個故事。想像，從2014年2000字的文字企劃「若之是夢」怎麼變成2016年100多分鐘的「你的名字」。文字企劃的時候，強調的是靈魂交換、連結(結び)。但沒有提到記憶相關、「你的名字」遺忘的主題。動畫腳本到真正電影之間也省略了不少部分。也不知道在這個企劃，贏了多少胎死腹中的企劃。還有從早期作品到最新的你的名字間的作為一個監督、腳本的成長，這些點都是值得思考玩味的地方。</p>\n<p>44歲的新海誠不一樣了。他結婚了、還有一個7歲的女兒。和10年前做「秒速５公分」時，一個人單身、還會做成人遊戲公司(minori) 的動畫、跑去倫敦遊學一年多。他也說311地震之後，日本人需要的東西也不一樣、想做的東西也不一樣了。很期待他下一部會做怎樣的動畫，希望在大紅大紫之後還他能有原來的色彩。</p>\n<p>PS: 會日文的朋友推薦買展場的書 (200多頁、1000元)，有所有展出作品的靜態部分、分鏡腳本、原畫、作品分析等。</p>\n<h3 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h3><ul>\n<li><a href=\"https://ja.wikipedia.org/wiki/新海誠\" target=\"_blank\" rel=\"noopener\">新海誠日文wiki</a></li>\n<li><a href=\"http://www.kiminona.com/#interview_ando\" target=\"_blank\" rel=\"noopener\">映画『君の名は。』公式サイト</a></li>\n<li><a href=\"https://www.gigcasa.com/articles/471452\" target=\"_blank\" rel=\"noopener\">新海誠｜人就是這樣，必須習慣失去</a></li>\n<li><a href=\"https://www.nippon.com/hk/people/e00107/\" target=\"_blank\" rel=\"noopener\">新海誠導演的世界：渺小的個人與浩瀚的宇宙之關聯</a></li>\n<li><a href=\"http://hkacger.com/archives/30624\" target=\"_blank\" rel=\"noopener\">【我用青春換此生】新海誠父親，百年建築公司「新津組」社長談自己兒子新海誠！</a></li>\n<li><a href=\"https://read01.com/2DANER.html#.WkIJFiOKXOR\" target=\"_blank\" rel=\"noopener\">新海誠來中國，聊了聊動畫《你的名字》背後的故事</a></li>\n<li><a href=\"https://read01.com/ERK2R2.html#.WkIJNSOKXOR\" target=\"_blank\" rel=\"noopener\">新海誠究竟是個怎樣的人</a></li>\n<li><a href=\"https://read01.com/QRGaMA.html#.WkIJTSOKXOR\" target=\"_blank\" rel=\"noopener\">新海誠：十四年，專注製造少女心</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>在新加坡看了「你的名字」、在東京看了「言葉之庭」，在日本喜歡去的地方就是東京新宿御苑、在那裡看著你的名字設定的高中、影片中烏鴉飛過的 NTT DoCoMo 代代木大廈; 言葉之庭的涼亭總是有很多人、因為我總是在晴天的時候去。坐一小時的電車，然後在公園裡鋪上唐吉軻德買的廉價野餐墊、尋找樹蔭、看書、看小朋友奔跑，有時還會繞去人少的千馱谷門逛逛將棋會館，好想買新宿御苑的年間PASS… 扯遠了。</p>\n<p><strong>新海誠</strong> 長野縣出生。是零下十幾度在湖上滑冰看日出、擁有70萬日元電腦的小朋友。國、高中參加過排球部和弓道部，接著跑到東京唸文學系、是建築世家的預定接班人。但他拒絕接班，跟老爸說年輕時有想做的事。2001年就跑去遊戲公司 (Falcom) 做了五年，有名的「英雄傳說系列的 III - V代」他都有參與、主攻美術、動畫、設定之類的。還記得三代的白髮魔女傳好好玩～ 就這樣過著早上6點上班、晚上12點下班的爆肝人生。社畜和「大東京玩具箱」都是真的啊。</p>\n<p>在 Falcom 做到第五年的時候就像，村上春樹每天經營的酒吧關門之後寫小說一樣。新海誠12點下班之後開始做動畫「星之聲」到凌晨3點，兩個人都是下班後心中還有創作的渴望，或是說有了再累都不能放棄的夢想，然後才讓這個夢想成真。不過星之聲做一半，他就離職啦～ 閉關工作八個月。</p>\n<p>他自幹了一次監督、美術、腳本、作畫… 全包25分鐘的長動畫、太累了，明白了自己適合哪一部分、不適合哪部分，就開始找人一起做了。後來的幾部動畫，「雲之彼端，約定的地方」、「秒速五公分」、「追逐繁星的孩子」、「言葉之庭」和「你的名字」都是和很多人合作的作品，他主要負責原作、腳本、監督。日本文學系、兒童文學繪本社團出生的他，還有寫動畫電影的小說。順帶一提，他在夏天有慢跑習慣、在最近的問答中說現在自己「工作時絕對不熬夜」，每天能專注多久才工作多久。</p>\n<p><strong>新海誠展</strong> 在華山展的內容有從「星之聲」到「你的名字」的動畫製作過程。展場內可以拍照但不能錄影。從文字企劃、分鏡腳本，到人物、場景設定的設定圖像、作畫與修正、合成分鏡圖動畫。都有展出。門票300元。PS: 如果想深入了解動畫產業，強烈建議看 2015年出品、IMDB 8.2 分的動畫「白箱」。</p>\n<h3 id=\"動畫製作過程以你的名字舉例\"><a href=\"#動畫製作過程以你的名字舉例\" class=\"headerlink\" title=\"動畫製作過程以你的名字舉例\"></a>動畫製作過程以你的名字舉例</h3><h4 id=\"企劃-gt-分鏡腳本-gt-分鏡腳本動畫-gt-人物、場景設定-gt-原畫\"><a href=\"#企劃-gt-分鏡腳本-gt-分鏡腳本動畫-gt-人物、場景設定-gt-原畫\" class=\"headerlink\" title=\"企劃-&gt;分鏡腳本-&gt;分鏡腳本動畫-&gt;人物、場景設定-&gt;原畫\"></a>企劃-&gt;分鏡腳本-&gt;分鏡腳本動畫-&gt;人物、場景設定-&gt;原畫</h4><ol>\n<li><strong>企劃 (新海誠)</strong><ul>\n<li>概要 (700字)</li>\n<li>故事背景、場景、道具設定 (400字)</li>\n<li>為什麼現在要拍這個故事 (1000字)<br><img src=\"/img/shinhai/1.jpeg\" width=\"360\"><br><img src=\"/img/shinhai/2.jpeg\" width=\"360\"><br><img src=\"/img/shinhai/3.jpeg\" width=\"360\"></li>\n</ul>\n</li>\n<li><strong>分鏡腳本 (新海誠)</strong><ul>\n<li>分鏡、動作、對話、時間</li>\n<li>分鏡會含畫面走向、人物要加上陰影部分</li>\n<li>分鏡動畫，1700張分鏡、四秒一張 (你的名字藍光有附完整的分鏡影片、新海誠親自配音)<br><img src=\"/img/shinhai/4.jpeg\" width=\"360\"><br><img src=\"/img/shinhai/5_1.jpeg\" width=\"360\"></li>\n</ul>\n</li>\n<li><strong>角色設定、場景設定 (人設：虎與龍、未聞花名的「田中將賀」)</strong><ul>\n<li>以女主角宮水三葉為例、會有人物的各種角度、長髮短髮、陰影的設定</li>\n<li>另外還會有人物身上的顏色的設計規範</li>\n<li>場景會有遠中近 (系手町、神社附近、三葉的房間)</li>\n<li>每個房間都有設計師先想像好、畫好才開始作畫<br><img src=\"/img/shinhai/5.jpeg\" width=\"360\"><br><img src=\"/img/shinhai/6.jpeg\" width=\"360\"><br><img src=\"/img/shinhai/7.jpeg\" width=\"360\"><br><img src=\"/img/shinhai/8.jpeg\" width=\"360\"><br><img src=\"/img/shinhai/9.jpeg\" width=\"360\"></li>\n</ul>\n</li>\n<li><strong>作畫 (作畫監督：神隱少女的「安藤雅司」)</strong><ul>\n<li>原畫師對著分鏡腳本畫原畫 (Key Animation)</li>\n<li>動畫師補上原畫間的中間影格<br><img src=\"/img/shinhai/10.jpeg\" width=\"360\"><br><img src=\"/img/shinhai/12.jpeg\" width=\"360\"></li>\n</ul>\n</li>\n<li><strong>其他</strong><ul>\n<li>音樂、音響、配音、聲優…</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"結語\"><a href=\"#結語\" class=\"headerlink\" title=\"結語\"></a>結語</h3><p>展覽中展出每部動畫製作時的部分的企劃、分鏡腳本、人設、原話，可以讓人好好學習如何做一部動畫、寫一個故事。想像，從2014年2000字的文字企劃「若之是夢」怎麼變成2016年100多分鐘的「你的名字」。文字企劃的時候，強調的是靈魂交換、連結(結び)。但沒有提到記憶相關、「你的名字」遺忘的主題。動畫腳本到真正電影之間也省略了不少部分。也不知道在這個企劃，贏了多少胎死腹中的企劃。還有從早期作品到最新的你的名字間的作為一個監督、腳本的成長，這些點都是值得思考玩味的地方。</p>\n<p>44歲的新海誠不一樣了。他結婚了、還有一個7歲的女兒。和10年前做「秒速５公分」時，一個人單身、還會做成人遊戲公司(minori) 的動畫、跑去倫敦遊學一年多。他也說311地震之後，日本人需要的東西也不一樣、想做的東西也不一樣了。很期待他下一部會做怎樣的動畫，希望在大紅大紫之後還他能有原來的色彩。</p>\n<p>PS: 會日文的朋友推薦買展場的書 (200多頁、1000元)，有所有展出作品的靜態部分、分鏡腳本、原畫、作品分析等。</p>\n<h3 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h3><ul>\n<li><a href=\"https://ja.wikipedia.org/wiki/新海誠\" target=\"_blank\" rel=\"noopener\">新海誠日文wiki</a></li>\n<li><a href=\"http://www.kiminona.com/#interview_ando\" target=\"_blank\" rel=\"noopener\">映画『君の名は。』公式サイト</a></li>\n<li><a href=\"https://www.gigcasa.com/articles/471452\" target=\"_blank\" rel=\"noopener\">新海誠｜人就是這樣，必須習慣失去</a></li>\n<li><a href=\"https://www.nippon.com/hk/people/e00107/\" target=\"_blank\" rel=\"noopener\">新海誠導演的世界：渺小的個人與浩瀚的宇宙之關聯</a></li>\n<li><a href=\"http://hkacger.com/archives/30624\" target=\"_blank\" rel=\"noopener\">【我用青春換此生】新海誠父親，百年建築公司「新津組」社長談自己兒子新海誠！</a></li>\n<li><a href=\"https://read01.com/2DANER.html#.WkIJFiOKXOR\" target=\"_blank\" rel=\"noopener\">新海誠來中國，聊了聊動畫《你的名字》背後的故事</a></li>\n<li><a href=\"https://read01.com/ERK2R2.html#.WkIJNSOKXOR\" target=\"_blank\" rel=\"noopener\">新海誠究竟是個怎樣的人</a></li>\n<li><a href=\"https://read01.com/QRGaMA.html#.WkIJTSOKXOR\" target=\"_blank\" rel=\"noopener\">新海誠：十四年，專注製造少女心</a></li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjblkzckg0007xq9kubu23iom","tag_id":"cjblkzckf0006xq9k60jfdk9s","_id":"cjblkzckk000axq9k1mcqdxgx"},{"post_id":"cjblkzcjo0000xq9kzrac4xli","tag_id":"cjblkzck20002xq9kkqfueb9a","_id":"cjblkzckr000fxq9ko77hho5z"},{"post_id":"cjblkzcjo0000xq9kzrac4xli","tag_id":"cjblkzckf0006xq9k60jfdk9s","_id":"cjblkzckt000hxq9kfvh33adp"},{"post_id":"cjblkzcjo0000xq9kzrac4xli","tag_id":"cjblkzckk0009xq9kb1hwvuuh","_id":"cjblkzcky000kxq9k8s6kfcx3"},{"post_id":"cjblkzcjv0001xq9kxvf5crh9","tag_id":"cjblkzckp000dxq9k6xekbuf7","_id":"cjblkzclm000vxq9ken9w4opr"},{"post_id":"cjblkzcjv0001xq9kxvf5crh9","tag_id":"cjblkzckt000ixq9ku3fsxy5c","_id":"cjblkzclp000xxq9klx8roeva"},{"post_id":"cjblkzcjv0001xq9kxvf5crh9","tag_id":"cjblkzck20002xq9kkqfueb9a","_id":"cjblkzclr0010xq9kawzaokz7"},{"post_id":"cjblkzcjv0001xq9kxvf5crh9","tag_id":"cjblkzcld000qxq9kdp7tefd8","_id":"cjblkzclt0012xq9kz8iagny2"},{"post_id":"cjblkzclq000zxq9kwytp2ryp","tag_id":"cjblkzck20002xq9kkqfueb9a","_id":"cjblkzclw0015xq9kz3mryam5"},{"post_id":"cjblkzclq000zxq9kwytp2ryp","tag_id":"cjblkzckf0006xq9k60jfdk9s","_id":"cjblkzclz0017xq9kk5vg66b9"},{"post_id":"cjblkzck50003xq9kqdt8rlu5","tag_id":"cjblkzclj000txq9kls05pgrh","_id":"cjblkzcmd001exq9k7557gbb7"},{"post_id":"cjblkzck50003xq9kqdt8rlu5","tag_id":"cjblkzclp000yxq9klwxasvbu","_id":"cjblkzcmf001gxq9k443xi3x7"},{"post_id":"cjblkzck50003xq9kqdt8rlu5","tag_id":"cjblkzclu0013xq9k8mfijfww","_id":"cjblkzcmh001ixq9kh47aurfy"},{"post_id":"cjblkzck50003xq9kqdt8rlu5","tag_id":"cjblkzcm10019xq9kab2pxp8e","_id":"cjblkzcmh001jxq9krz2z3qqc"},{"post_id":"cjblkzck80004xq9kup27sh2j","tag_id":"cjblkzck20002xq9kkqfueb9a","_id":"cjblkzcmh001lxq9kis3dsahs"},{"post_id":"cjblkzck80004xq9kup27sh2j","tag_id":"cjblkzcma001cxq9kjwit2anp","_id":"cjblkzcmh001mxq9k6vfbn2mz"},{"post_id":"cjblkzckd0005xq9kbdrk6jkb","tag_id":"cjblkzcmg001hxq9k30zzzh0g","_id":"cjblkzcmi001oxq9k540x33qu"},{"post_id":"cjblkzckd0005xq9kbdrk6jkb","tag_id":"cjblkzcmh001kxq9kxg85ebja","_id":"cjblkzcmi001pxq9kqnrijfyd"},{"post_id":"cjblkzcki0008xq9klfctylwc","tag_id":"cjblkzcmh001nxq9k7ejwtywj","_id":"cjblkzcmi001rxq9kt0muu3iw"},{"post_id":"cjblkzcki0008xq9klfctylwc","tag_id":"cjblkzckf0006xq9k60jfdk9s","_id":"cjblkzcmj001sxq9koaau2s5p"},{"post_id":"cjblkzckk000bxq9kdo564m4d","tag_id":"cjblkzcmi001qxq9kqyzwcgr0","_id":"cjblkzcml001wxq9knb5aowvf"},{"post_id":"cjblkzckk000bxq9kdo564m4d","tag_id":"cjblkzcmj001txq9kriya2buz","_id":"cjblkzcmm001xxq9ky78m1mel"},{"post_id":"cjblkzckk000bxq9kdo564m4d","tag_id":"cjblkzckf0006xq9k60jfdk9s","_id":"cjblkzcmm001zxq9k8b3z7a9a"},{"post_id":"cjblkzckk000bxq9kdo564m4d","tag_id":"cjblkzcmk001uxq9khzvqip4j","_id":"cjblkzcmm0020xq9kde3qi84q"},{"post_id":"cjblkzckn000cxq9ki689mvp8","tag_id":"cjblkzclu0013xq9k8mfijfww","_id":"cjblkzcmo0024xq9klzofjz3l"},{"post_id":"cjblkzckn000cxq9ki689mvp8","tag_id":"cjblkzcmm001yxq9k1q1r3ic5","_id":"cjblkzcmo0025xq9kemj9uqnb"},{"post_id":"cjblkzckn000cxq9ki689mvp8","tag_id":"cjblkzcmm0021xq9kft8tn9sa","_id":"cjblkzcmo0027xq9k62wb6s6x"},{"post_id":"cjblkzckn000cxq9ki689mvp8","tag_id":"cjblkzcmk001uxq9khzvqip4j","_id":"cjblkzcmo0028xq9klrxdmt6p"},{"post_id":"cjblkzckr000gxq9kg6gcqov4","tag_id":"cjblkzcmn0023xq9kvozwijvd","_id":"cjblkzcmp002axq9kmq7aegyq"},{"post_id":"cjblkzcku000jxq9kiolg816r","tag_id":"cjblkzcmo0026xq9kpvnb5ce7","_id":"cjblkzcmp002bxq9k7y72jxkf"},{"post_id":"cjblkzcku000jxq9kiolg816r","tag_id":"cjblkzckf0006xq9k60jfdk9s","_id":"cjblkzcmq002dxq9kk91cg5yo"},{"post_id":"cjblkzckz000lxq9kr5xw1sih","tag_id":"cjblkzcmo0029xq9k18z53phv","_id":"cjblkzcms002jxq9kdkmekmtc"},{"post_id":"cjblkzckz000lxq9kr5xw1sih","tag_id":"cjblkzcmn0023xq9kvozwijvd","_id":"cjblkzcms002kxq9k9s9vujrc"},{"post_id":"cjblkzckz000lxq9kr5xw1sih","tag_id":"cjblkzcmq002exq9kl198jupu","_id":"cjblkzcms002mxq9k2hrz5eb5"},{"post_id":"cjblkzckz000lxq9kr5xw1sih","tag_id":"cjblkzcmr002fxq9kemffnr68","_id":"cjblkzcms002nxq9kzo3p8vcw"},{"post_id":"cjblkzckz000lxq9kr5xw1sih","tag_id":"cjblkzcmr002gxq9kjsmu5kia","_id":"cjblkzcmt002pxq9k48s9t5pu"},{"post_id":"cjblkzckz000lxq9kr5xw1sih","tag_id":"cjblkzcmr002hxq9kf797r4u9","_id":"cjblkzcmt002qxq9kwneyqvn2"},{"post_id":"cjblkzcl3000mxq9kybvrim3u","tag_id":"cjblkzcmn0023xq9kvozwijvd","_id":"cjblkzcmu002txq9khrvi6vkf"},{"post_id":"cjblkzcl3000mxq9kybvrim3u","tag_id":"cjblkzcms002lxq9kd1csrmbp","_id":"cjblkzcmu002uxq9ki6b7g6o4"},{"post_id":"cjblkzcl3000mxq9kybvrim3u","tag_id":"cjblkzcms002oxq9konzp152m","_id":"cjblkzcmu002wxq9kbbi1x5tz"},{"post_id":"cjblkzcl3000mxq9kybvrim3u","tag_id":"cjblkzcmt002rxq9kwshcvsoe","_id":"cjblkzcmu002xxq9kd6e6324u"},{"post_id":"cjblkzcl9000oxq9k1qfr42jm","tag_id":"cjblkzckp000dxq9k6xekbuf7","_id":"cjblkzcmu002zxq9ki5mshz3y"},{"post_id":"cjblkzcl9000oxq9k1qfr42jm","tag_id":"cjblkzckt000ixq9ku3fsxy5c","_id":"cjblkzcmv0030xq9kwoparz3u"},{"post_id":"cjblkzcl9000oxq9k1qfr42jm","tag_id":"cjblkzck20002xq9kkqfueb9a","_id":"cjblkzcmv0032xq9ksyevmikz"},{"post_id":"cjblkzcl9000oxq9k1qfr42jm","tag_id":"cjblkzcma001cxq9kjwit2anp","_id":"cjblkzcmv0033xq9k3ci2cel7"},{"post_id":"cjblkzclb000pxq9km9oxh6c2","tag_id":"cjblkzcmu002vxq9k6trl6bgi","_id":"cjblkzcmw0035xq9kqtjivh74"},{"post_id":"cjblkzclb000pxq9km9oxh6c2","tag_id":"cjblkzcmu002yxq9k6804jf52","_id":"cjblkzcmw0036xq9kh2c4oy8r"},{"post_id":"cjblkzcle000rxq9kdsi39pat","tag_id":"cjblkzcmn0023xq9kvozwijvd","_id":"cjblkzcmw0038xq9k4mdp9410"},{"post_id":"cjblkzcle000rxq9kdsi39pat","tag_id":"cjblkzcmw0034xq9krohcidbg","_id":"cjblkzcmw0039xq9kphe4m5ih"},{"post_id":"cjblkzclg000sxq9k92rd8q18","tag_id":"cjblkzcmn0023xq9kvozwijvd","_id":"cjblkzcmx003cxq9k0yh3xzh0"},{"post_id":"cjblkzclg000sxq9k92rd8q18","tag_id":"cjblkzcmw0034xq9krohcidbg","_id":"cjblkzcmx003dxq9kcslslbne"},{"post_id":"cjblkzclk000uxq9k4rzk4esc","tag_id":"cjblkzcmx003bxq9ko3bz2cf3","_id":"cjblkzcmz003ixq9k6pc6melh"},{"post_id":"cjblkzclk000uxq9k4rzk4esc","tag_id":"cjblkzcmy003exq9kn5xu52qh","_id":"cjblkzcmz003jxq9kv6bagg1k"},{"post_id":"cjblkzclk000uxq9k4rzk4esc","tag_id":"cjblkzcmy003fxq9kr1gjen0x","_id":"cjblkzcmz003lxq9kayoaoahk"},{"post_id":"cjblkzclk000uxq9k4rzk4esc","tag_id":"cjblkzcmy003gxq9k8mbdpk39","_id":"cjblkzcmz003mxq9khv95elmq"},{"post_id":"cjblkzcln000wxq9ksjve1qxq","tag_id":"cjblkzcmy003hxq9kz1owvb4j","_id":"cjblkzcn2003qxq9ksx2qza3n"},{"post_id":"cjblkzcln000wxq9ksjve1qxq","tag_id":"cjblkzcmz003kxq9kcp9rczzy","_id":"cjblkzcn2003rxq9kbn7a55yp"},{"post_id":"cjblkzcln000wxq9ksjve1qxq","tag_id":"cjblkzcn0003nxq9krcfr6tcn","_id":"cjblkzcn2003txq9kvjqsn0ay"},{"post_id":"cjblkzcln000wxq9ksjve1qxq","tag_id":"cjblkzcn1003oxq9kd5llmhpb","_id":"cjblkzcn2003uxq9kd6wofnun"},{"post_id":"cjblkzcls0011xq9k4ndq72qs","tag_id":"cjblkzcmn0023xq9kvozwijvd","_id":"cjblkzcn4003yxq9kgw9q1ql0"},{"post_id":"cjblkzcls0011xq9k4ndq72qs","tag_id":"cjblkzcn2003sxq9kf597bwvb","_id":"cjblkzcn4003zxq9ke5cbru15"},{"post_id":"cjblkzcls0011xq9k4ndq72qs","tag_id":"cjblkzcn2003vxq9kgp3cpll0","_id":"cjblkzcn50041xq9ko254j5do"},{"post_id":"cjblkzcls0011xq9k4ndq72qs","tag_id":"cjblkzcn3003wxq9k3knxjz2z","_id":"cjblkzcn50042xq9kaxmxsdhn"},{"post_id":"cjblkzclu0014xq9kchu3kvt4","tag_id":"cjblkzcmk001uxq9khzvqip4j","_id":"cjblkzcn50044xq9k9j2k9ldq"},{"post_id":"cjblkzclu0014xq9kchu3kvt4","tag_id":"cjblkzckk0009xq9kb1hwvuuh","_id":"cjblkzcn50045xq9kckf98uhe"},{"post_id":"cjblkzclx0016xq9k9b405i3w","tag_id":"cjblkzclp000yxq9klwxasvbu","_id":"cjblkzcn60047xq9kny25gtza"},{"post_id":"cjblkzclx0016xq9k9b405i3w","tag_id":"cjblkzcn40040xq9kxkrn1bfp","_id":"cjblkzcn60048xq9k5prpkx3i"},{"post_id":"cjblkzclx0016xq9k9b405i3w","tag_id":"cjblkzcmg001hxq9k30zzzh0g","_id":"cjblkzcn7004axq9kije54aor"},{"post_id":"cjblkzclz0018xq9ksc87urpb","tag_id":"cjblkzck20002xq9kkqfueb9a","_id":"cjblkzcn7004bxq9kszi9mc1x"},{"post_id":"cjblkzclz0018xq9ksc87urpb","tag_id":"cjblkzcn60046xq9kmsxjwzn5","_id":"cjblkzcn7004dxq9keopykx57"},{"post_id":"cjblkzcm2001axq9kbs0d5lsg","tag_id":"cjblkzcn60049xq9kcgrw7r0l","_id":"cjblkzcn8004fxq9k1r24m954"},{"post_id":"cjblkzcm2001axq9kbs0d5lsg","tag_id":"cjblkzcn7004cxq9kbl98m6vr","_id":"cjblkzcn8004gxq9khsfjk5ch"},{"post_id":"cjblkzcmb001dxq9ktdhe2iaa","tag_id":"cjblkzcn7004exq9kdz3hc3u6","_id":"cjblkzcn9004jxq9k3u9anwvo"},{"post_id":"cjblkzcmb001dxq9ktdhe2iaa","tag_id":"cjblkzcn8004hxq9koy82o30f","_id":"cjblkzcn9004kxq9kum862k0a"},{"post_id":"cjblkzcme001fxq9kry2nna5q","tag_id":"cjblkzcmq002exq9kl198jupu","_id":"cjblkzcna004nxq9k1cn5o8o0"},{"post_id":"cjblkzcme001fxq9kry2nna5q","tag_id":"cjblkzcn9004lxq9kdavp8dad","_id":"cjblkzcna004oxq9ksgrr4ruw"},{"post_id":"cjblkzcme001fxq9kry2nna5q","tag_id":"cjblkzcmw0034xq9krohcidbg","_id":"cjblkzcna004pxq9klk4t4vbw"},{"post_id":"cjbnd5mnz0000kv9k6nn3m0gc","tag_id":"cjbndcg2c0001kv9k3f809vak","_id":"cjbndcg2e0003kv9kqoo7qa8d"},{"post_id":"cjbnd5mnz0000kv9k6nn3m0gc","tag_id":"cjbndcg2d0002kv9ky8z4j3ko","_id":"cjbndcg2e0004kv9kw1gk0bjb"}],"Tag":[{"name":"functional programming","_id":"cjblkzck20002xq9kkqfueb9a"},{"name":"react","_id":"cjblkzckf0006xq9k60jfdk9s"},{"name":"state machine","_id":"cjblkzckk0009xq9kb1hwvuuh"},{"name":"composition","_id":"cjblkzckp000dxq9k6xekbuf7"},{"name":"currying","_id":"cjblkzckt000ixq9ku3fsxy5c"},{"name":"functors","_id":"cjblkzcld000qxq9kdp7tefd8"},{"name":"baas","_id":"cjblkzclj000txq9kls05pgrh"},{"name":"backend","_id":"cjblkzclp000yxq9klwxasvbu"},{"name":"firebase","_id":"cjblkzclu0013xq9k8mfijfww"},{"name":"frontend","_id":"cjblkzcm10019xq9kab2pxp8e"},{"name":"pure function","_id":"cjblkzcma001cxq9kjwit2anp"},{"name":"node","_id":"cjblkzcmg001hxq9k30zzzh0g"},{"name":"yahoo","_id":"cjblkzcmh001kxq9kxg85ebja"},{"name":"flux","_id":"cjblkzcmh001nxq9k7ejwtywj"},{"name":"event system","_id":"cjblkzcmi001qxq9kqyzwcgr0"},{"name":"one way data flow","_id":"cjblkzcmj001txq9kriya2buz"},{"name":"redux","_id":"cjblkzcmk001uxq9khzvqip4j"},{"name":"MobX","_id":"cjblkzcmm001yxq9k1q1r3ic5"},{"name":"Model","_id":"cjblkzcmm0021xq9kft8tn9sa"},{"name":"design","_id":"cjblkzcmn0023xq9kvozwijvd"},{"name":"facebook","_id":"cjblkzcmo0026xq9kpvnb5ce7"},{"name":"agile","_id":"cjblkzcmo0029xq9k18z53phv"},{"name":"IA","_id":"cjblkzcmq002exq9kl198jupu"},{"name":"System Thinking","_id":"cjblkzcmr002fxq9kemffnr68"},{"name":"UCD","_id":"cjblkzcmr002gxq9kjsmu5kia"},{"name":"user story mapping","_id":"cjblkzcmr002hxq9kf797r4u9"},{"name":"framer","_id":"cjblkzcms002lxq9kd1csrmbp"},{"name":"prototyping","_id":"cjblkzcms002oxq9konzp152m"},{"name":"ui","_id":"cjblkzcmt002rxq9kwshcvsoe"},{"name":"empathy","_id":"cjblkzcmu002vxq9k6trl6bgi"},{"name":"hackathon","_id":"cjblkzcmu002yxq9k6804jf52"},{"name":"ux","_id":"cjblkzcmw0034xq9krohcidbg"},{"name":"attention","_id":"cjblkzcmx003bxq9ko3bz2cf3"},{"name":"cognitive psychology","_id":"cjblkzcmy003exq9kn5xu52qh"},{"name":"information","_id":"cjblkzcmy003fxq9kr1gjen0x"},{"name":"psychology","_id":"cjblkzcmy003gxq9k8mbdpk39"},{"name":"coding","_id":"cjblkzcmy003hxq9kz1owvb4j"},{"name":"interaction design","_id":"cjblkzcmz003kxq9kcp9rczzy"},{"name":"refactoring","_id":"cjblkzcn0003nxq9krcfr6tcn"},{"name":"separation of concerns","_id":"cjblkzcn1003oxq9kd5llmhpb"},{"name":"design thinking","_id":"cjblkzcn2003sxq9kf597bwvb"},{"name":"designer","_id":"cjblkzcn2003vxq9kgp3cpll0"},{"name":"engineering","_id":"cjblkzcn3003wxq9k3knxjz2z"},{"name":"express","_id":"cjblkzcn40040xq9kxkrn1bfp"},{"name":"oop","_id":"cjblkzcn60046xq9kmsxjwzn5"},{"name":"vivid dream","_id":"cjblkzcn60049xq9kcgrw7r0l"},{"name":"老子","_id":"cjblkzcn7004cxq9kbl98m6vr"},{"name":"sociology","_id":"cjblkzcn7004exq9kdz3hc3u6"},{"name":"社會學","_id":"cjblkzcn8004hxq9koy82o30f"},{"name":"information architecture","_id":"cjblkzcn9004lxq9kdavp8dad"},{"name":"ACGN","_id":"cjbndcg2c0001kv9k3f809vak"},{"name":"分鏡","_id":"cjbndcg2d0002kv9ky8z4j3ko"}]}}